{
    "assets": {
        "code": {
            "main": " ENABLE_EDITOR = false;\n\n@RegisterAsComponent\nclass MainGame extends MonoBehaviour {\n\n  public static instance : MainGame;\n  public static level: Level_CrossNumbers;\n\n  public nRobotsCreated = 0;\n\n  isRunning : boolean = false;\n\n  finished : boolean = false;\n\n  levelIndex : number = 0;\n  playButton : PlayButton;\n  resetTimer : number = 0;\n\n  winScreen: CustomImage;\n\n  Start() {\n    MainGame.instance = this;\n    let x = new Vector3(0, 0 , 0);\n    let y = new Vector3(2, 2, 2);\n    let a = Utility.VectorDifference(x,y);\n    let b = Utility.VectorDistance(x,y);\n    Debug.Log(a);\n    Debug.Log(b);\n    \n    this.resetTimer = 60;\n    // MainGame.level = Instantiate(Level_CrossNumbers);    \n    \n    // Instantiate(FPSCounterGUI);\n    //This makes the engine runs 10 times as fast.\n    //Great way to check memory leaks\n    // Engine.nFramesPerRenderLoop = 10;\n    //Remove slash if it's in there\n    var phpQuery = GetPHPVariable(\"l\");\n    var phpVar = phpQuery === undefined ? undefined : phpQuery.split('/')[0]; \n    this.levelIndex = phpVar === undefined ? 0 : +phpVar; \n    var isChallenge = GetIsChallenge();\n    Instantiate(HDREnvironment);\nthis.InitWinScreen();\n    //Instantiate(CameraFadeInFadeOut);\n    \n  \n    MainGame.level = Instantiate(Level_CrossNumbers);\n    MainGame.level.robot.push(Robot.main)\n    if(isChallenge){\n      let scriptArea = document.getElementById(\"script-area\"); \n      if (scriptArea) \n      {\n        \n        let obj = ConvertJsonCode(scriptArea.innerText)\n        Object.keys(obj).forEach(robotName =>{\n          let robot = MainGame.level.CreateRobot();\n          \n          robot.robotName = robotName\n          robot.imgUrl = obj[robotName].flag\n        })\n        \n      } \n      MainGame.level.CreateMaze3()\n      return;\n    }\n    let lm = GameObject.FindObjectOfType(LevelManager);\n    if(lm){\n      Instantiate(CameraFadeInFadeOut)\n      loadLevelFromLevelManager(lm, this.levelIndex);\n      \n    }\n    \n  } \n\n  \n\n  Update()\n  {\n    \n    if (!this.playButton)   \n    {\n      this.playButton = Instantiate(PlayButton);\n    }\n\n    //We reset the scene after a while, since memory leaks slow down the game if it's been on for too long\n    if (!this.isRunning)\n    {\n      //Disabled the resetTime, since the memory leak seems to be fixed.\n      //this.resetTimer -= Time.deltaTime;\n      if (this.resetTimer <= 0)\n      {\n        SceneManager.ReloadCurrentScene();\n      }\n    }\n  }\n\n  public InitWinScreen(){\n      this.winScreen =  Instantiate(CustomImage).Init(\"YouWinPopup.png\", 185, 212);\n      this.winScreen.RemoveFromControl();\n  }\n\n  public OnVictory ()\n  {\n    if (this.finished)\n    {\n      return;\n    }\n\n    this.finished = true;\n    // Instantiate(CustomImage).Init(\"YouWinPopup.png\", 185, 212);\n    this.winScreen.AddToControl();\n    var url = Engine.getUrl() + Engine.getFullName(\"ContinueButton.png\", FileType.Texture);\n    var continueButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"ContinueButton\",url);\n    continueButton.widthInPixels = 48;\n    continueButton.heightInPixels = 48;\n    continueButton.topInPixels = 60;\n    continueButton.onPointerClickObservable.add( e => {    \n      \n      var baseUrl = window.location.href.split('?')[0];\n      //If it's the Test Project....\n      if (baseUrl.includes(\"ohvmotqqgzv\"))\n      {\n        Debug.Log(\"This would get you to the next level!\");\n      }else{\n        window.location.href = baseUrl + \"?l=\" + ++this.levelIndex;\n      }\n    });\n    Canvas.main.addControl(continueButton);\n  }\n\n}\n\nasync function loadLevelFromLevelManager(lm: LevelManager, lv: number){\n      setTimeout(()=>{\n        lm.LoadLevel(`Level_${lv}.scn`)\n      },  \n      5000\n      )\n  }\n\nasync function runRobotCode ()\n{\n  let scriptArea = document.getElementById(\"script-area\"); \n  if (scriptArea) \n  {\n    if(GetIsChallenge()){\n      let obj = ConvertJsonCode(scriptArea.innerText)\n      Object.keys(obj).forEach(key=>{\n        let code = obj[key].code;\n        let index = code.indexOf(\"runOpMode\")\n        code = code.slice(0, index + 9) + '_' + key + code.slice(index + 9)\n        eval(code)\n        eval('(async () => {await runOpMode_' + key + '(GetRobot(\"'+ key + '\"));})();'); \n\n      })\n    }else{\n      eval('(async () => {await runOpMode(GetRobot());})();' + scriptArea.innerText);\n    }\n  } \n  else\n  {\n    await runOpModeDebug();\n  }  \n}\n\n\n// The '//BLOCKLY_REPLACE' will be replaced with an empty string\n// This auto comments the testing code below, and places in the blockly code\n// This way you don't have to remove your testing code every time you save to live.\n\n//DO NOT REMOVE THIS COMMENT BELOW\n//BLOCKLY_REPLACE//*\n\n\n//All code below is for testing only and will be auto-commented when in the live engine\n//Note: Don't use multiline commenting in the testing code since this will break the system\n\nfunction GetRobot(name: string = \"testRobot\"){\n\n  let robotList : RobotMoveList = new RobotMoveList();\n\n  robotList.robot = MainGame.level.GetOneRobot(name)\n  Debug.Log(robotList.robot.robotName)\n  // Debug.Log(robotList.robot.name)\n  return robotList\n}\n\nvar x;\n\n// Describe this function...\nasync function ChangeModeToPosition(robot) {\n  await robot.SetMode(MotorModeEnum.RUN_TO_POSITION, \"motorLeft\");\n  await robot.SetMode(MotorModeEnum.RUN_TO_POSITION, \"motorRight\");\n}\n\n// Describe this function...\nasync function StopMotor(robot) {\n  await robot.SetPower(0, \"motorLeft\");\n  await robot.SetPower(0, \"motorRight\");\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \"motorLeft\");\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \"motorRight\");\n  await robot.SetTargetPosition(0, \"motorLeft\");\n  await robot.SetTargetPosition(0, \"motorRight\");\n}\n\n// Describe this function...\nasync function ChangeModeToPower(robot) {\n  await robot.SetMode(MotorModeEnum.RUN_USING_ENCODER, \"motorLeft\");\n  await robot.SetMode(MotorModeEnum.RUN_USING_ENCODER, \"motorRight\");\n}\n\n// Describe this function...\nasync function ChangeDirection(robot) {\n  await robot.SetDirection(MotorDirectionEnum.REVERSE,\"motorLeft\");\n  await robot.SetDirection(MotorDirectionEnum.REVERSE,\"motorRight\");\n}\n\n// Describe this function...\nasync function CheckStop(robot) {\n  while (await OpModeIsActive(robot)) {\n    if (!await robot.IsBusy(\"motorLeft\") && !await robot.IsBusy(\"motorRight\")) {\n      break;\n    }\n  }\n}\n\n// Describe this function...\nasync function TestTargetPosition(robot, x) {\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \"motorLeft\");\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \"motorRight\");\n  await robot.SetTargetPosition((-1 * x), \"motorLeft\");\n  await robot.SetTargetPosition(x, \"motorRight\");\n}\n\n// Describe this function...\nasync function TestSetPower(robot, x) {\n  await robot.SetPower(x, \"motorLeft\");\n  await robot.SetPower((-1 * x), \"motorRight\");\n}\n\n\nasync function\t runOpModeDebug(robot: RobotMoveList = GetRobot()) {\n  Debug.Log(\"start\")\n  // while (await OpModeIsActive(robot)) {\n    Debug.Log(robot.robot.robotName)\n    await ChangeModeToPosition(robot);\n    await robot.SetTargetPosition(20000, \"motorLeft\")\n   \n  // }\n}\n\n\n\n\n/* End Testing Code */\n\n",
            "LevelManager": "class LevelManager extends MonoBehaviour {\n\n  LoadLevel(levelName: string){\n    SceneManager.LoadScene(levelName);\n  }\n}\n",
            "Consts": "//511 = bitmask of 111111111 = up to 9 robots.\nconst ROBOT_LAYER_MASK = 511;\n",
            "DefaultObjects": "class DefaultObjectMaterialTexture extends MonoBehaviour {\n  Setup(texture: string) {\n    var mat = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n    mat.diffuseTexture = TextureSystem.GetSprite(texture);\n\n    mat.diffuseTexture.hasAlpha = true;\n    mat.emissiveTexture = mat.diffuseTexture;\n    mat.backFaceCulling = true;\n\n    this.renderer.GetMesh().material = mat;\n    this.gameObject.AddComponent(BoxCollider);\n    this.transform.eulerAngles.x = 90;\n  }\n}\n\nclass DefaultObjectMaterialColor extends MonoBehaviour {\n  Setup(red: number, green: number, blue: number, alpha: number) {\n    var mat = new BABYLON.StandardMaterial(red.toString() + \".\" + green.toString() + \".\" + blue.toString(), Engine.scene);\n    mat.diffuseColor = new BABYLON.Color3(red, green, blue);\n    mat.roughness = 0.2\n    mat.alpha = alpha;\n    this.renderer.GetMesh().material = mat;\n  }\n}\n\nclass PickableObject extends DefaultObjectMaterialColor {\n  public isPickedUp: boolean = false;\n\n  Update() {\n    if (this.isPickedUp == true) {\n      // this.transform.position.x = MainGame.level.robot.transform.position.x;\n      // this.transform.position.y = 3;\n      // this.transform.position.z = MainGame.level.robot.transform.position.z;\n    }\n  }\n}\n\n// TODO: Rework the Pickup Object\nclass PickupBox extends PickableObject {\n  public velocityY: number = 0;\n\n  Awake() {\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\"Box\", {}));\n    super.Setup(1, 0, 1, 1);\n    this.transform.scale = new Vector3(0.5, 0.5, 0.5);\n    this.gameObject.AddComponent(BoxCollider);\n    this.gameObject.AddComponent(Rigidbody).isKinematic = true;\n  }\n\n}\n\nclass UltraSoundBox extends DefaultObjectMaterialColor {\n\n  Awake() {\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\"Box\", {}));\n    super.Setup(0, 0.5, 1, 1);\n    this.gameObject.AddComponent(BoxCollider).isTrigger = true;\n    this.transform.scale = new Vector3(2, 1, 1);\n  }\n\n  OnTriggerEnter(otherCollider: Collider) {\n    if (otherCollider.GetComponent(PickableObject) != null) {\n      return true;\n    }\n  }\n}\n\nclass CustomImage extends MonoBehaviour\n{\n  image : BABYLON.GUI.Image;\n\n  public Init(name : string, width : number, height : number) : CustomImage\n  {\n    var url = Engine.getUrl() + Engine.getFullName(name, FileType.Texture);\n    this.image = new BABYLON.GUI.Image(\"\", url);\n    this.image.widthInPixels = width;\n    this.image.heightInPixels = height;\n    Canvas.main.addControl(this.image);\n    return this;\n  }\n\n  public RemoveFromControl(){\n    Canvas.main.removeControl(this.image);\n  }\n\n  public AddToControl(){\n    Canvas.main.addControl(this.image);\n  }\n\n  OnDestroy ()\n  {\n    this.image?.dispose();\n  }\n}",
            "ColorBox": "class ColorBox extends MonoBehaviour {\n\n  public color: BABYLON.Color3;\n\n  Awake(){\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\"ColorTag\", { size: 1, height: 1}))\n    this.gameObject.AddComponent(BoxCollider);\n    this.gameObject.AddComponent(Rigidbody);\n    // this.gameObject.AddComponent(Rigidbody);\n    // this.GetComponent(Rigidbody).isKinematic = true;\n  }\n\n  public SetColor(color: BABYLON.Color3){\n    this.color = color;\n    var material = new BABYLON.StandardMaterial(\"mat\",Engine.scene)\n    material.diffuseColor = this.color;\n    material.roughness = 0.1\n    this.renderer.GetMesh().material = material;\n  }\n\n  public GetColor(){\n    return this.color;\n  }  \n}\n",
            "ColorTag": "class ColorTag extends MonoBehaviour {\n  public color: BABYLON.Color3;\n\n  Awake(){\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\"ColorTag\", { size: 1, height: 1}))\n    this.transform.scale.y = 0.1;\n    this.gameObject.AddComponent(BoxCollider).isTrigger = true;\n    this.renderer.GetMesh().receiveShadows = true\n\n  }\n\n  public SetColor(color: BABYLON.Color3){\n    this.color = color;\n    var material = new BABYLON.StandardMaterial(\"mat\",Engine.scene)\n    material.diffuseColor = this.color;\n    this.renderer.GetMesh().material = material;\n  }\n\n  public GetColor(){\n    return this.color;\n  }\n\n  public SetSize(x: number, y: number){\n    this.transform.scale.x = x\n    this.transform.scale.z = y\n  }\n\n  OnTriggerEnter(col: Collider){\n    if(col.GetComponent(Robot) != null){\n      col.GetComponent(Robot).TriggerColorSensorEvent(this.color);\n    }\n  }\n\n  OnTriggerExit(col: Collider){\n    if(col.GetComponent(Robot) != null){\n      col.GetComponent(Robot).TriggerColorSensorEvent(new BABYLON.Color3(1,1,1));\n    }\n  }\n\n  \n}\n",
            "RobotSensor": "class RobotSensor {\n  private sensorPosition: Vector3;\n  private robot: Robot;\n  public enabled: boolean = true;\n  public name: string;\n\n  constructor(name: string, robot: Robot){\n    this.name = name;\n    this.robot = robot;\n  }\n  // public AttachTo(robot: Robot, pos: Vector3 = new Vector3(0,1,0)){\n  //   this.sensorPosition = pos;\n  //   this.robot = robot;\n  // }\n\n}\n",
            "RobotMotor": "class RobotMotor {\n  private direction: MotorDirectionEnum;\n  private name: string;\n  private mode: MotorModeEnum;\n  public enabled: boolean = true;\n  // Use only in RUNT_USING_ENCODER mode\n  private power: number;\n  // Use only in TO_POSITION mode\n  private tickPosition: number;\n  private tickDestination: number;\n  // Use Modern robotics encoder as the reference (vid24 at 2.39)\n  private tickPerRev: number = 1440;\n\n  \n  \n\n  constructor(name: string, direction: MotorDirectionEnum = MotorDirectionEnum.FORWARD, \n    power: number = 0, mode: MotorModeEnum = MotorModeEnum.RUN_USING_ENCODER) {\n    this.name = name;\n    this.direction = direction;\n    this.power = power;\n    this.tickPosition = 0;\n    this.tickDestination = 0;\n  }\n\n  public SetPower(power: number){\n    this.power = power;\n  }\n\n  public GetPower(){\n    return this.power;\n  }\n\n  public SetDirection(direction: MotorDirectionEnum){\n    this.direction = direction;\n  }\n\n  public GetDirection(){\n    return this.direction;\n  }\n\n  public SetName(name: string){\n    this.name = name;\n  }\n\n  public GetName(){\n    return this.name;\n  }\n\n  public ResetEncoder(){\n    this.tickPosition = 0;\n  }\n\n  public SetMode(mode: MotorModeEnum){\n    if(mode == MotorModeEnum.STOP_AND_RESET_ENCODER){\n      this.tickPosition = 0;\n      return;\n    }\n    this.mode = mode;\n  }\n\n  public GetMode(){\n    return this.mode;\n  }\n\n  public AddTickPosition(tick: number = 1){\n    this.tickPosition += tick;\n  }\n\n  public GetTickPosition(){\n    return this.tickPosition;\n  }\n\n  public SetTickDestination(tickDestination: number){\n    this.tickDestination = tickDestination;\n  }\n\n  public GetTickDestination(){\n    return this.tickDestination;\n  }\n\n  public IsWorking(): boolean {\n    if(this.mode == MotorModeEnum.RUN_TO_POSITION){\n      // return true meaning when tickPosition != tickDestination,\n      // meaning motor is working\n      return !(this.tickPosition == this.tickDestination);\n    }else{\n      // return true when the power is not equal 0, meaning motor is \n      // working\n      return this.power !== 0;\n    }\n  }\n}\n\nenum MotorDirectionEnum{\n  FORWARD,\n  REVERSE\n}\n\nenum MotorModeEnum{\n  RUN_USING_ENCODER,\n  RUN_TO_POSITION,\n  STOP_AND_RESET_ENCODER \n}",
            "RobotServo": "class RobotServo {\n  private name: string;\n  private position: number;\n  private target: number;\n  private direction: MotorDirectionEnum;\n  public enabled: boolean = true;\n  // the speed of changing position\n  speed: number = 0.01;\n\n  constructor(name: string, position: number = 0, target: number = 0, direction: MotorDirectionEnum = MotorDirectionEnum.FORWARD){\n    this.name = name;\n    this.position = position;\n    this.target = target;\n    this.direction = direction;\n  }\n\n  public SetName(name: string){\n    this.name = name;\n  }\n\n  public GetName(){\n    return this.name;\n  }\n\n  public SetPosition(position: number){\n    this.position = position;\n  }\n\n  public GetPosition(){\n    return this.position;\n  }\n\n  public SetTarget(target: number){\n    this.target = target;\n  }\n\n  public GetTarget(){\n    return this.target;\n  }\n\n  public SetDirection(direction: MotorDirectionEnum){\n    this.direction = direction\n  }\n\n  public GetDirection(){\n    return this.direction;\n  }\n\n  public AddPosition(pos: number){\n    this.position += pos;\n  }\n  // Use to calculate the final eulerangles\n  public GetRotation(){\n    return this.position * 180;\n  }\n}\n",
            "RobotTouchSensor": "class RobotTouchSensor extends RobotSensor{\n  private isPressed: boolean;\n\n  // TODO: Implement functions for the touchSensor\n}\n",
            "RobotColorDistanceSensor": "class RobotColorDistanceSensor extends RobotSensor{\n  private reflectionValue: number;\n  private distance: number = 500;\n\n  public GetLightDetected(){\n    if(!this.enabled)\n      return 0;\n    return this.reflectionValue;\n  }\n\n  public GetDistance(){\n    return this.distance;\n  }\n\n  public SetDistance(distance: number){\n    if(distance > 0){\n      this.distance = distance;\n    }else{\n      this.distance = 500;\n    }\n\n  }\n\n}\n",
            "RobotColorSensor": "class RobotColorSensor extends RobotSensor{\n  private color: BABYLON.Color3 = new BABYLON.Color3(1,1,1);\n  \n  public GetColor(){\n    if(!this.enabled){\n      return new BABYLON.Color3(0,0,0);\n    }\n    return this.color;\n    \n  }\n\n  public SetColor(color: BABYLON.Color3){\n    if(this.enabled){\n      this.color = color\n    }\n  }\n\n\n}\n",
            "Robot": "class Robot extends MonoBehaviour {\n\n  public static main: Robot;\n  private velocityX: number = 0;\n  private velocityZ: number = 0;\n  public holdingItem: boolean = false;\n  public motorLeft: RobotMotor = new RobotMotor(\"motorLeft\");\n  public motorRight: RobotMotor = new RobotMotor(\"motorRight\");\n  public colorSensor: RobotColorSensor = new RobotColorSensor(\"sensorColor\", this)\n  public distanceSensor: RobotColorDistanceSensor = new RobotColorDistanceSensor(\"distanceSensor\", this)\n  public isDrawing: boolean = true;\n  public positions: Array<BABYLON.Vector3> = new Array();\n  public lastPos: Vector3 = new Vector3(0, 0, 0);\n  public velocity: Vector3 = new Vector3(0, 0, 0);\n  public imgUrl: string;\n  private txtName: BABYLON.GUI.Button3D;\n  \n  public robotName: string = \"testRobot\"\n\n  private frontWheels: Array<BABYLON.Mesh> = new Array();\n\n  private outterFrontWheelMeshName: string = \"Wheel_Mr._Grabby_v4.008\";\n  private innerFrontWheelMeshName: string = \"Wheel.001_Mr._Grabby_v4.003\"; \n\n  // Robot looks\n  public robotColor: BABYLON.Color3;\n\n  public robotGUI: RobotGUI;\n  \n\n  // All components of the robot\n  // Use arrays because we might have more than 2 motors in the future\n  public robotMotors: Array<RobotMotor> = new Array();\n  public robotColorSensors: Array<RobotColorSensor> = new Array();\n  public robotServos: Array<RobotServo> = new Array();\n  public robotTouchSensors: Array<RobotTouchSensor> = new Array();\n  public robotColorDistanceSensors: Array<RobotColorDistanceSensor> = new Array();\n\n  // Raycast variable\n  public bOrigin: BABYLON.Vector3 = new BABYLON.Vector3\n  public downDirection: BABYLON.Vector3 = new BABYLON.Vector3(0,-1,0)\n  public forwardDirection: BABYLON.Vector3\n\n  lines: BABYLON.LinesMesh;\n\n  private m : BABYLON.Mesh;\n  private modelName : string;\n\n\n  Awake() {\n    Robot.main = this;\n    this.InitializeRobot();\n  }\n\n  Start()\n  {\n\n    MainGame.instance.nRobotsCreated++;\n    //Robot layers are 2,4,8,16 etc.\n    var layer = Math.pow(2, MainGame.instance.nRobotsCreated);\n    Debug.Log(\"Robot layer: \" + layer);\n    this.GetComponent(Collider).layer = layer;\n\n    if(GetIsChallenge())\n    {\n      this.robotGUI = Instantiate(RobotGUI)\n      this.robotGUI.robot = this;\n    }\n  }\n\n  /**Dont use anymore (use to manually load the mesh) */\n  SetRobotMesh(meshName: string){\n      this.renderer.LoadMesh(meshName, 0.034, null, false);\n      Debug.Log(meshName);\n      this.modelName = meshName;\n      if(meshName == \"robot_1.obj\"){ \n        this.GetComponent(BoxCollider).size = new Vector3(1.25, 1, 2);\n      }\n      if(meshName == \"robot_2.obj\"){\n        this.GetComponent(BoxCollider).size = new Vector3(1.4, 0.1, 2.2);\n        this.GetComponent(BoxCollider).center = new Vector3(0, -1, 0);\n      }\n      if(meshName == \"robot_3.obj\"){\n        this.GetComponent(BoxCollider).size = new Vector3(1.4, 1, 2);\n        this.GetComponent(BoxCollider).center = new Vector3(0, 0.5, 0);\n      }\n  }\n\n  SetRobotColor(r: number, g:number, b:number){\n    this.robotColor = new BABYLON.Color3(r,g,b);\n  }\n\n  SerRobotWheels(){\n    this.renderer.GetMeshes().forEach((e,i) => {\n      if(e.id.includes(this.outterFrontWheelMeshName) || e.id.includes(this.innerFrontWheelMeshName)){\n        this.frontWheels.push(e);\n      }\n    })\n    Debug.Log(`This robot has ${this.frontWheels.length} wheels`)\n  }\n\n  Update() {\n    \n    //TEMP FIX to avoid shadows freaking out after the robot falls off the cliff\n    if (this.transform.position.y <= -15)\n    {\n      this.GetComponent(Rigidbody).isKinematic = true;\n      return;\n    }\n\n    this.EngineMovement();\n    this.EngineSensor();\n     //This only happens once, when the mesh is loaded\n    if (!this.m )\n    {\n      this.m = this.renderer.GetMesh();   \n      if (this.m)\n      {\n        ColorRobot.SetColor(\"robot_1.obj\", this);\n        //this.SerRobotWheels();\n      }\n      \n    }\n\n  }\n\n  InitializeRobot(){\n    this.positions.push(new BABYLON.Vector3(this.transform.position.x,\n    this.transform.position.y + 0.15,\n    this.transform.position.z));\n    this.robotMotors.push(this.motorLeft);\n    this.robotMotors.push(this.motorRight);\n    this.GetComponent(Rigidbody).friction = 0            \n    this.GetComponent(Rigidbody).useGravity = true;    \n  }\n\n// Handle all the motors and servos\n  EngineMovement() { \n    this.MotorMovement();\n    this.ServoMovement();\n  }\n\n  // Handle all the sensors\n  EngineSensor(){\n    // this.DetectColor();\n    this.DetectDistance();\n  }\n\n  DetectColor(){\n    Vector3.VtoB(this.transform.position, this.bOrigin)\n    let dir = this.downDirection.subtract(this.bOrigin)\n    dir = BABYLON.Vector3.Normalize(dir);\n    let ray = new BABYLON.Ray(this.bOrigin, dir, 2);\n    let hit = Engine.scene.pickWithRay(ray)\n    if(hit.pickedMesh){\n          // Debug.Log(\"Debug = \" + hit.pickedMesh)\n      let obj = Engine.meshToObject[hit.pickedMesh.uniqueId]\n      if(obj){\n        if(obj.GetComponent(ColorTag)){\n          let colTag = obj.GetComponent(ColorTag)\n          if(!Utility.CompareColor(colTag.GetColor(),this.colorSensor.GetColor())){\n            let col = new BABYLON.Color3(colTag.GetColor().r,colTag.GetColor().g,colTag.GetColor().b)\n            this.colorSensor.SetColor(new BABYLON.Color3(\n              col.r,col.g,col.b)\n              );\n          }\n        }else{\n          this.colorSensor.SetColor(new BABYLON.Color3(1,1,1));\n        }\n      }\n      \n    }\n\n  }\n\n  DetectDistance(){\n    if(this.renderer.GetMesh()){\n      Vector3.VtoB(this.transform.position, this.bOrigin)\n     this.forwardDirection = this.renderer.GetMesh().getDirection(new BABYLON.Vector3(0,0,1))\n     this.forwardDirection.normalize()\n     let ray = new BABYLON.Ray(this.bOrigin, this.forwardDirection, 100);\n      let hit = Engine.scene.pickWithRay(ray)\n      this.distanceSensor.SetDistance(hit.distance);\n    }\n     \n    \n  }\n\n  MotorMovement(){\n    const motorLeftMove = Utility.CalculateMotorMovement(this.motorLeft)\n    const motorRightMove = Utility.CalculateMotorMovement(this.motorRight)\n    const rotationPower =  motorLeftMove.rotation + motorRightMove.rotation\n    this.transform.localEulerAngles.y -= rotationPower;\n    let wheelRotation = 0;\n    let axis = new BABYLON.Vector3(1, 1, 1);\n    let angle = 0;\n    let quaternion = BABYLON.Quaternion.RotationAxis(axis, angle);\n\n    if(rotationPower > 0){\n      angle = Math.PI / 8;\n    }else if(rotationPower < 0){\n      angle = -Math.PI / 8;\n    }\n    if(this.frontWheels){\n      this.frontWheels.forEach(e=>{\n      e.rotationQuaternion = quaternion;\n    })\n    }\n    \n    let movingSpeed = motorLeftMove.direction + motorRightMove.direction;\n    \n    let movingAngle = Math.floor(this.transform.localEulerAngles.y);\n    let maxSpeed = 30;\n    this.gameObject.GetComponent(Rigidbody).angularVelocity = new Vector3(0,0,0);\n    //this.transform.transformNode.translate(BABYLON.Axis.Z, motorLeftMove.direction + motorRightMove.direction);\n    let vel = this.gameObject.GetComponent(Rigidbody).velocity.clone();\n    vel.x = Math.sin(movingAngle * Mathf.Deg2Rad) * movingSpeed * maxSpeed;\n    vel.z = Math.cos(movingAngle * Mathf.Deg2Rad) * movingSpeed * maxSpeed;\n    \n    this.gameObject.GetComponent(Rigidbody).velocity = vel;\n\n    this.transform.localEulerAngles.x = 0;\n    this.transform.localEulerAngles.z = 0;\n\n    // this.ManageGravity();\n  }\n\n  ManageGravity(){\n    Vector3.VtoB(this.transform.position, this.bOrigin)\n    let dir = this.downDirection.subtract(this.bOrigin)\n    dir = BABYLON.Vector3.Normalize(dir);\n    let ray = new BABYLON.Ray(this.bOrigin, dir, 5);\n    let hit = Engine.scene.pickWithRay(ray)\n    if(hit.pickedMesh && hit.pickedMesh.name != this.name){\n      this.GetComponent(Rigidbody).useGravity = false     \n    }else{\n      this.GetComponent(Rigidbody).useGravity = true  \n    }\n  }\n\n  ServoMovement(){\n    this.robotServos.forEach(servo=>{\n      const rot = Utility.GetServoRotation(servo);\n      // TODO: Do something with the servo by using rot as the rotation (such as robot arms)\n      \n    })\n  }\n\n  TouchSensorDetection(){\n    this.robotTouchSensors.forEach(touchSensor=>{\n      // TODO: Set the detection function\n    })\n  }\n\n  // All motor setup functions\n  SetPowerInternal(power: number, engine: string){\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\n    if(motor){\n      motor.SetPower(power);\n    }else{\n      Debug.Log(\"motor is not found\")\n    }\n  }\n\n  // To set motor mode by motor name\n  SetMode(mode: MotorModeEnum, engine: string ){\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\n    if(motor){\n      motor.SetMode(mode);\n    }\n  }\n\n  TriggerColorSensorEvent(color: BABYLON.Color3){\n      this.colorSensor.SetColor(color);\n  }\n\n  SetTargetPosition(pos: number, engine: string){\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\n    if(motor){\n      motor.SetTickDestination(pos);\n    }\n  }\n\n  GetTargetPosition(engine: string){\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\n    if(motor){\n     // Debug.Log(motor.GetTickPosition())\n      return motor.GetTickPosition()\n    }\n    return undefined;\n  } \n\n  SetDirection(direction: MotorDirectionEnum, engine: string){\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\n    if(motor){\n      motor.SetDirection(direction);\n    }\n  }  \n\n  IsMoving(): boolean{\n    return this.motorLeft.IsWorking() && this.motorRight.IsWorking();\n  } \n\n  OnTriggerEnter(otherCollider: Collider) {\n    if (otherCollider.GetComponent(PickableObject) != null) {\n     // Debug.Log(\"GOT HERE\")\n      return true;\n    }\n  }\n\n  // Helping Function for debuging th\n  Drawing() {\n    if (this.isDrawing == true) {\n\n      this.lines?.dispose();\n\n      this.lines = BABYLON.Mesh.CreateLines(\"lines\", this.positions, Engine.scene, true);\n      this.lines.color = new BABYLON.Color3(1, 0, 0);\n      if ((Math.sqrt((Math.pow(this.positions[this.positions.length - 1].x - this.transform.position.x, 2)) +\n        (Math.pow(this.positions[this.positions.length - 1].z - this.transform.position.z, 2)))) > 0.2) {\n        this.positions.push(new BABYLON.Vector3(this.transform.position.x,\n          0.1,\n          this.transform.position.z));\n      }\n    }\n\n    if (Input.GetKeyDown(KeyCode.R)) {\n      if (this.isDrawing == false) {\n        this.isDrawing = true;\n      }\n\n      else if (this.isDrawing == true) {\n        this.isDrawing = false;\n        this.positions.length = 0;\n        this.positions.push(new BABYLON.Vector3(this.transform.position.x,\n          this.transform.position.y + 0.1,\n          this.transform.position.z));\n      }\n    }\n  }\n}\n\n\n",
            "RobotGUI": "class RobotGUI extends MonoBehaviour {\n\n  public robot: Robot;\n  private button: BABYLON.GUI.Button3D\n  private imgPlane: BABYLON.Mesh\n  private initiate: boolean = false;\n\n  private manager : BABYLON.GUI.GUI3DManager;\n\n  Update(){\n    // return right away if there is no robot\n    if(this.robot == null){\n      return;\n    }\n\n    // create the tags if we never (it's here to make sure we have the robot)\n    if(!this.initiate){\n      this.InitiateButton ();\n      this.initiate = true;\n    }\n\n    // move the button along the robot\n    this.MoveButton();\n  }\n\n  \n  InitiateButton(){\n    //We store this as an instance variable so we can dispose of it after!\n    this.manager = new BABYLON.GUI.GUI3DManager(Engine.scene);\n    this.button = new BABYLON.GUI.Button3D(\"name\");\n    this.manager.addControl(this.button);\n    this.button.node.rotation = new BABYLON.Vector3(0, 180 * Mathf.Deg2Rad, 0)\n    this.button.scaling = new BABYLON.Vector3(2,0.5,1);\n    this.button.mesh.material.alpha = 0.5\n        \n    var text1 = new BABYLON.GUI.TextBlock();\n    text1.text = this.robot.robotName;\n    text1.color = \"white\";\n    text1.alpha = 10\n    text1.fontSize = 25;\n    this.button.content = text1; \n\n    this.imgPlane = BABYLON.Mesh.CreatePlane(\"img\", 0.5, Engine.scene);\n    this.imgPlane.scaling = new BABYLON.Vector3(1,0.7,1)\n    this.imgPlane.rotation = new BABYLON.Vector3(0, 180 * Mathf.Deg2Rad, 0)\n    let mat = new BABYLON.StandardMaterial(\"flagImg\", Engine.scene);\n    mat.diffuseTexture = new BABYLON.Texture(this.robot.imgUrl, Engine.scene);\n    this.imgPlane.material = mat;\n  }\n\n   MoveButton(){\n    let pos: BABYLON.Vector3 = new BABYLON.Vector3(0);\n    Vector3.VtoB(this.robot.transform.position, pos);\n    pos.y += 1\n    if (this.button) {this.button.position = pos.clone()}\n    pos.y += 0.6\n    this.imgPlane.position = pos.clone()\n  }\n\n  OnDestroy()\n  {\n    this.manager.dispose();\n    this.imgPlane.dispose();\n  }\n}\n",
            "RobotMoveList": "class RobotMoveList extends MonoBehaviour {\n\n  current : Move;\n\n  robot : Robot;\n\n  Start(){\n    \n  }\n\n  async SetPower (power, engine)\n  {\n    return new SetPowerObj(this, power, engine).Run();\n  }\n\n  async Sleep (timeLeft){\n    return new SleepObj(this, timeLeft).Run();\n  }\n\n  async WaitForStart(){\n\n  }\n\n  async SetDirection(direction: MotorDirectionEnum, engine: string) {\n    return new SetDirectionObj(this, direction, engine).Run();\n  }\n\n  async SetMode(mode: MotorModeEnum, engine: string) {\n    return new SetModeObj(this, mode, engine).Run();\n  }\n\n  async SetTargetPosition(power: number, engine: string) {\n    return new SetTargetPositionObj(this, power * 0.1, engine).Run();\n  }\n\n  async GetTargetPosition(engine: string) {\n    return this.robot.GetTargetPosition(engine)\n  }\n\n  async WaitUntilAtPosition() {\n    return new WaitUntilAtPositionObj(this).Run()\n  }\n\n  async IsBusy(engine: string) {\n    return new IsBusyObject(this, engine).Run();\n  }\n\n  async WaitUntilGetColor(color: BABYLON.Color3){\n    return new WaitUntilGetColorObj(this, color).Run();\n  }\n\n  GetColorRed(){\n    return this.robot.colorSensor.GetColor().r;\n  }\n\n  GetColorGreen(){\n    return this.robot.colorSensor.GetColor().g;\n  }\n\n  GetColorBlue(){\n    return this.robot.colorSensor.GetColor().b;\n  }\n\n  GetDistance(){\n    return this.robot.distanceSensor.GetDistance();\n  }\n}\n",
            "Moves": "abstract class Move {\n  // public static current: Move;\n\n  protected moveList : RobotMoveList;\n\n\n  constructor (moveList : RobotMoveList)\n  {\n    this.moveList = moveList;\n  }\n\n  // public get robot(): Robot {\n  //   return Robot.main;\n  // }\n\n  async Run() {\n    this.moveList.current = this;\n    return await new Promise(resolve => {\n      var func = () => {\n        //I'm 99% sure this is a memory leak but let's just assume it's tiny\n        //Since we can't cancel async methods, we have to pause old moves instead\n        //When we reload the scene, we also set the Move.current to null\n        if (this.moveList.current == this) {\n          this.Update();\n\n          if (this.IsCompleted()) {\n            this.OnDestroy();\n            Engine.scene.onBeforePhysicsObservable.removeCallback(func);\n            resolve(this.GetReturnValue());\n          }\n        }\n        else {\n          //Move event listener is removed and the move will never complete\n          //The move is now destined to wonder our memory forever- never to be accessed. Poor move.\n          Engine.scene.onBeforePhysicsObservable.removeCallback(func);\n\n        }\n      }\n      Engine.scene.onBeforePhysicsObservable.add(func);\n      if (this.DoesRunInstant()) {\n        func();\n      }\n    });\n  }\n\n  DoesRunInstant(): boolean {\n    return true;\n  }\n\n  OnDestroy(): void {\n\n  }\n\n  Update(): void {\n\n  }\n\n  //By default all moves complete instantly.\n  IsCompleted(): boolean {\n    return true;\n  }\n\n  GetReturnValue(): any {\n    return null;\n  }\n}\n\n\nclass MovementMove extends Move {\n  public speed: number = 0.01;\n  public distance: number;\n\n  constructor(moveList: RobotMoveList,distance: number = 1) {\n    super(moveList);\n    this.distance = distance;\n  }\n\n  IsCompleted() {\n    return this.distance <= 0;\n  }\n\n  Update() {\n\n    this.distance -= this.speed;\n  }\n\n  OnDestroy() {\n    this.speed = 0;\n  }\n\n\n\n}\n\nclass MoveRight extends MovementMove {\n\n  Update() {\n    this.moveList.robot.transform.position.x += this.speed;\n    super.Update();\n  }\n}\n\nclass MoveLeft extends MovementMove {\n\n  Update() {\n    this.moveList.robot.transform.position.x -= this.speed;\n    super.Update();\n  }\n}\n\nclass MoveForward extends MovementMove {\n\n  Update() {\n    this.moveList.robot.transform.position.z += this.speed;\n    super.Update();\n  }\n}\n\nclass MoveBackward extends MovementMove {\n\n  Update() {\n    this.moveList.robot.transform.position.z -= this.speed;\n    super.Update();\n  }\n}\n\n\nclass PickupObj extends Move {\n\n  // constructor() {\n    \n    // MainGame.level.robot.gameObject.AddComponent(BoxCollider).isTrigger = true;\n  // }\n\n  OnDestroy() {\n    // Destroy(MainGame.level.robot.GetComponent(BoxCollider));\n  }\n}\n\n// class Drop extends Move {\n//   constructor ()\n//   {\n//     super();\n//     this.pickupObject.isPickedUp = false;\n//   }\n\n// }\n\n\nclass SleepObj extends Move {\n  public timeLeft: number;\n\n  constructor(moveList: RobotMoveList,timeLeft: number) {\n    super(moveList);\n    this.timeLeft = timeLeft;\n  }\n\n  Update() {\n    //Multiply by 1000 to support milliseconds\n    //No longer using Time.deltaTime since EVERYTHING is now frame-based\n    //Assuming 0.017, which is 60 FPS\n    this.timeLeft -= 0.017 * 1000;\n  }\n\n  IsCompleted() {\n    return this.timeLeft <= 0;\n  }\n\n}\n\n// =================== Set Motor Direction =================\n\nclass SetDirectionObj extends Move {\n\n  constructor(moveList: RobotMoveList, direction: MotorDirectionEnum, engine: string) {\n    super(moveList);\n    //We only set the direction once. The robot keeps moving after it's been set, even after this move has completed.\n    this.moveList.robot.SetDirection(direction, engine);\n  }\n}\n\n//=============== Set Motor Mode =================\n\n\n\nclass SetModeObj extends Move {\n  constructor(moveList: RobotMoveList, mode: MotorModeEnum, engine: string) {\n    super(moveList);\n    this.moveList.robot.SetMode(mode, engine)\n  }\n}\n\n//================ Set Motor Power =====================\n\n/*\nfunction SetPower(power: number, engine: string) {\n  Robot.main.SetPower(power, engine);\n}\n*/\n\nclass SetPowerObj extends Move {\n\n  constructor(moveList : RobotMoveList, power: number, engine: string) {\n    super(moveList);\n    moveList.robot.SetPowerInternal(power, engine);\n  }\n}\n\n//================ Set Motor Target Position =====================\n\n\n\nclass SetTargetPositionObj extends Move {\n\n  constructor(moveList: RobotMoveList, power: number, engine: string) {\n    super(moveList);\n    moveList.robot.SetTargetPosition(power, engine);\n\n  }\n}\n\nclass GetTargetPositionObj extends Move {\n  engineName: string\n  constructor(moveList: RobotMoveList, engine: string) {\n    super(moveList);\n    this.engineName = engine;\n  }\n\n  GetReturnValue() {\n    return this.moveList.robot.GetTargetPosition(this.engineName);\n  }\n}\n\n\n// ================= Set stop when motor finish moving ========\n\n\n\nclass WaitUntilAtPositionObj extends Move {\n\n  constructor(moveList: RobotMoveList) {\n    super(moveList);\n  }\n\n  IsCompleted() {\n    return this.moveList.robot.motorLeft.GetTickPosition() == this.moveList.robot.motorLeft.GetTickDestination()\n      && this.moveList.robot.motorRight.GetTickPosition() == this.moveList.robot.motorRight.GetTickDestination();\n  }\n}\n\n// ================= Set only one motor ====================\n\n\n\nclass IsBusyObject extends Move {\n  engine: string;\n  constructor(moveList: RobotMoveList, engine: string) {\n    super(moveList);\n    this.engine = engine\n\n  }\n\n  IsCompleted() {\n    return this.moveList.robot == Robot.main;\n  }\n\n\n  GetReturnValue() {\n    const motor = Robot.main.robotMotors.find(motor => motor.GetName() === this.engine)\n    // Debug.Log(motor.GetName())\n    if (motor) {\n      // Debug.Log(motor.GetTickDestination() + \" : \" + motor.GetTickPosition())\n      return Math.floor(motor.GetTickPosition()) != Math.floor(motor.GetTickDestination())\n    }\n    return true;\n  }\n}\n\nclass TouchSensorCheck extends Move {\n  public result: boolean = false;\n\n  Start() {\n    //this.gameObject.AddComponent(BoxCollider).isTrigger = true;\n  }\n\n  Update() {\n    // this.transform.position.x = this.robot.transform.position.x;\n    // this.transform.position.z = this.robot.transform.position.z;\n  }\n\n  /*\n  OnTriggerEnter(otherCollider: Collider) {\n    if (otherCollider.GetComponent(PickupObject) != null) {\n      Debug.Log(\"HOWDY\");\n      this.result = true;\n    }\n  }\n  */\n\n  TouchSensorResult(): boolean {\n    return this.result;\n  }\n\n}\n\n\n\n",
            "SensorDetect": "abstract class Sensor \n{ \n\n  protected moveList: RobotMoveList\n  // public get robot (): Robot\n  // {\n  //   return Robot.main;\n  // }\n\n  constructor(moveList: RobotMoveList){\n    this.moveList = moveList;\n  }\n\n  async Run ()\n  {\n      return await new Promise(resolve => \n      {\n        var func = () => {\n          this.Update();\n          \n          if (this.IsCompleted())\n          {\n            this.OnDestroy();\n            Engine.scene.onBeforeRenderObservable.removeCallback(func);\n            resolve(this.GetReturnValue());\n          }\n      }\n      Engine.scene.onBeforeRenderObservable.add(func);\n      if (this.DoesRunInstant())\n      {\n        func();\n      }\n    });\n  }\n\n  DoesRunInstant () : boolean\n  {\n    return true;\n  }\n\n  OnDestroy() : void\n  {\n    \n  }\n\n  Update() : void\n  {\n\n  }\n\n  //By default all moves complete instantly.\n  IsCompleted() : boolean\n  {\n    return true;\n  }\n\n  GetReturnValue () : any\n  {\n    return null;\n  }\n}\n\n// ===============================================\n\n\n\nclass WaitUntilGetColorObj extends Sensor{\n  private expectedColor: BABYLON.Color3\n  constructor(moveList: RobotMoveList, color: BABYLON.Color3){\n    super(moveList);\n    this.expectedColor = color;\n  }\n\n  IsCompleted(){\n    return Utility.CompareColor(this.expectedColor, this.moveList.robot.colorSensor.GetColor());\n  }\n}\n\n// =================== Get Color =====================\n\n\n\nclass GetColorRedObj extends Sensor{\n  constructor(moveList: RobotMoveList){\n    super(moveList);\n  }\n\n  GetReturnValue(){\n    return this.moveList.robot.colorSensor.GetColor().r;\n  }\n}\n\n\n// =================== Get Color =====================\n\n\n\nclass GetColorGreenObj extends Sensor{\n  constructor(moveList: RobotMoveList){\n    super(moveList);\n  }\n\n  GetReturnValue(){\n    return this.moveList.robot.colorSensor.GetColor().g;\n  }\n}\n\n\n// =================== Get Color =====================\n\nclass GetColorBlueObj extends Sensor{\n  constructor(moveList: RobotMoveList){\n    super(moveList);\n  }\n\n  GetReturnValue(){\n    return this.moveList.robot.colorSensor.GetColor().b;\n  }\n}\n\n// ====================== Convert color ====================\nfunction RgbToColor(r: number, g: number, b: number){\n  return Utility.ConvertRgbToHsv(r, g, b)\n}\n\nfunction GetPropertyNumberHue(col: BABYLON.Color3): number{\n  return col.r;\n}\n\nfunction GetPropertyNumberSaturation(col: BABYLON.Color3): number{\n  return col.g;\n}\n\nfunction GetPropertyNumberValue(col: BABYLON.Color3): number{\n  return col.b;\n}\n\n\n\n",
            "Levels": "class BaseLevel extends MonoBehaviour\n{\n  public robot : Robot[] = [];\n\n  Awake ()\n  {    \n  }\n  \n}\n\n\nclass Level_CrossNumbers extends BaseLevel {\n\n  Start() {\n    super.Start();\n    //this.renderer.isVisible = false;\n    Instantiate(LevelTwo);\n    \n    //Real position\n    \n    //Easy victory position\n   // BoardFactory.CreateFlag(-11.5,6.5,0);\n  }\n\n  CreateRobot(): Robot{\n    let robot = Instantiate(Robot, new Vector3(-11, 1, 11))\n    this.robot.push(robot)\n    return robot\n  }\n\n  GetAllRobots(): Robot[]{\n    return this.robot;\n  }\n\n  GetOneRobot(robotName: string): Robot{\n    let returnRobot = null; \n    this.robot.forEach(r=> {\n      if(r.robotName === robotName){\n          returnRobot = r;\n          return\n      }\n    })\n    \n    return returnRobot\n    \n  }\n\n  CreateMaze1(){\n\n  //  BoardFactory.CreateCoin(3,3);\n  //  BoardFactory.CreateCoin(6,6);\n //   BoardFactory.CreateCoin(-8,-5);\n\n    BoardFactory.CreateWall2(-10, 9, -10, 12)\n    BoardFactory.CreateWall2(-6, 9, -10, 9)\n    BoardFactory.CreateWall2(-6, 5, -6, 9)\n    BoardFactory.CreateWall2(-2, 5, -6, 5)\n    BoardFactory.CreateWall2(-2, -7, -2, 5)\n    BoardFactory.CreateWall2(1, 1, -2, 1)\n    BoardFactory.CreateWall2(1, 1, 1, 8)\n    BoardFactory.CreateWall2(8, 8, 1, 8)\n    BoardFactory.CreateWall2(8, -6, 8, 8)\n    BoardFactory.CreateWall2(8, -6, 4, -6)\n    BoardFactory.CreateWall2(4, -7, 4, -6)\n    BoardFactory.CreateWall2(12, -7, 4, -7)\n    BoardFactory.CreateWall2(-9, 6, -12, 6)\n    BoardFactory.CreateWall2(-9, 2, -9, 6)\n    BoardFactory.CreateWall2(-4, 2, -9, 2)\n    BoardFactory.CreateWall2(-4, 1, -4, 2)\n    BoardFactory.CreateWall2(-4, 1, -8, 1)\n    BoardFactory.CreateWall2(-8, -3, -8, 1)\n    BoardFactory.CreateWall2(-8, -3, -12, -3)\n    BoardFactory.CreateWall2(9, -12, 9, -10)\n    BoardFactory.CreateWall2(9, -10, -12, -10)\n    BoardFactory.CreateWall2(0, -10, 0, -2)\n    BoardFactory.CreateWall2(5, -3, 0, -3)\n    BoardFactory.CreateWall2(5, -2, 0, -2)\n    BoardFactory.CreateWall2(5, -3, 5, 5)\n    BoardFactory.CreateWall2(4, -2, 4, 5)\n    BoardFactory.CreateWall2(5, 5, 4, 5)\n    BoardFactory.CreateWall2(-2, -7, -9, -7)\n    BoardFactory.CreateWall2(-9, -7, -9, -6)\n    BoardFactory.CreateWall2(-5, -6, -9, -6)\n    BoardFactory.CreateWall2(-5, -6, -5, -2)\n    BoardFactory.CreateWall2(-2, -2, -5, -2)\n    BoardFactory.CreateFlag(10.5,-10.5,0);\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.localEulerAngles.y = 180;\n    })\n    \n  }\n\n  CreateMaze2(){\n    BoardFactory.CreateWall2(-10, 9, -10, 12)\n    BoardFactory.CreateWall2(-4, 9, -10, 9)\n    BoardFactory.CreateWall2(-4, 9, -8, 5)\n    BoardFactory.CreateWall2(-1, -2, -8, 5)\n    BoardFactory.CreateWall2(-1, -2, -6, -2)\n    BoardFactory.CreateWall2(-6, -5, -6, -2)\n    BoardFactory.CreateWall2(-6, -5, -10, -5)\n    BoardFactory.CreateWall2(-1, -4, -6, -4)\n    BoardFactory.CreateWall2(-1 ,-7, -1, -4)\n    BoardFactory.CreateWall2(0, -7, -1, -7)\n    BoardFactory.CreateWall2(0, -7, 0, -4)\n    BoardFactory.CreateWall2(4, -4, 0, -4)\n    BoardFactory.CreateWall2(4, -4, 4, -2)\n    BoardFactory.CreateWall2(4, -2, 0, -2)\n    BoardFactory.CreateWall2(0, -2, 0, 7)\n    BoardFactory.CreateWall2(0 ,7 ,6 ,10)\n    BoardFactory.CreateWall2(8, 10, 6, 10)\n    BoardFactory.CreateWall2(8, 6, 8, 10)\n    BoardFactory.CreateWall2(12, 2, 8, 6)\n    BoardFactory.CreateWall2(12, -4, 9, -4)\n    BoardFactory.CreateWall2(12, -7, 9, -4)\n    BoardFactory.CreateWall2(9, -12, 9, -8)\n    BoardFactory.CreateWall2(9, -8, 6, -5)\n    BoardFactory.CreateWall2(6, -6, 6, 0)\n    BoardFactory.CreateWall2(9, -2, 6, -2)\n    BoardFactory.CreateWall2(9, -2, 9, 0)\n    BoardFactory.CreateWall2(9, 0, 3, 0)\n    BoardFactory.CreateWall2(3, 0, 3, 6)\n    BoardFactory.CreateWall2(3, 6, 5, 7)\n    BoardFactory.CreateWall2(5, 4, 5, 7)\n    BoardFactory.CreateWall2(9, 0, 5, 4)\n    BoardFactory.CreateWall2(6, -6, 2, -6)\n    BoardFactory.CreateWall2(2, -9, 2, -6)\n    BoardFactory.CreateWall2(2, -9, -3, -9)\n    BoardFactory.CreateWall2(-3, -9, -3, -6)\n    BoardFactory.CreateWall2(-3, -7, -12, -7)\n    BoardFactory.CreateWall2(-8, -3, -12, -3)\n    BoardFactory.CreateWall2(-8, -3, -8, 0)\n    BoardFactory.CreateWall2(-6, 0, -8, 0)\n    BoardFactory.CreateWall2(-8, 0, -12, 4)\n    BoardFactory.CreateWall2(-12, 4, -9, 7)\n    BoardFactory.CreateWall2(-9, 7, -12, 7)\n    BoardFactory.CreateFlag(11.5,-11.5,0);\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.localEulerAngles.y = 180;\n    })\n  }\n\n  CreateMaze1_1(){\n    BoardFactory.CreateWall2(4, -12, 4, 12);\n    BoardFactory.CreateWall2(-4, -12, -4, 12);\n\n    BoardFactory.CreateFlag(0, 0, 0);\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(0, 0.5, 6);\n      robot.transform.localEulerAngles.y = 180;\n    })\n  }\n\n  CreateMaze1_2(){\n    BoardFactory.CreateWall2(6, -6, 6, 12);\n    BoardFactory.CreateWall2(6, -6, -12, -6);\n    BoardFactory.CreateWall2(0, 0, -12, 0);\n    BoardFactory.CreateWall2(0, 0, 0, 12);\n\n    BoardFactory.CreateFlag(-3, -3, -3);\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(3, 0.5, 5);\n      robot.transform.localEulerAngles.y = 180;\n    })\n\n  }\n\n  CreateMaze1_3(){\n    BoardFactory.CreateWall2(6, -6, 6, 12);\n    BoardFactory.CreateWall2(12, -6, -4, -6);\n    BoardFactory.CreateWall2(0, 0, -12, 0);\n    BoardFactory.CreateWall2(0, 0, 0, 12);\n\n    BoardFactory.CreateFlag(9, -9, -3);\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(3, 0.5, 5);\n      robot.transform.localEulerAngles.y = 180;\n    })\n\n  }\n\n  CreateMaze3(){\n    BoardFactory.CreateWall2(1, 9, 1, 12);\n    BoardFactory.CreateWall2(3, 9, 1, 9);\n    BoardFactory.CreateWall2(3, 5, 3, 9);\n    BoardFactory.CreateWall2(6, 5, 3, 5);\n    BoardFactory.CreateWall2(6, 5, 6, 9);\n    BoardFactory.CreateWall2(12, 9, 6, 9);\n    BoardFactory.CreateWall2(-2, 9, -2, 12);\n    BoardFactory.CreateWall2(-2, 9, -4, 9);\n    BoardFactory.CreateWall2(-4, 5, -4, 9);\n    BoardFactory.CreateWall2(-4, 5, -6, 5);\n    BoardFactory.CreateWall2(-6, 5, -6, 9);\n    BoardFactory.CreateWall2(-6, 9, -12, 9);\n    BoardFactory.CreateWall2(12, -8, 8, -4);\n    BoardFactory.CreateWall2(12, -4, 6, -4);\n    BoardFactory.CreateWall2(10, -2, 6, -2);\n    BoardFactory.CreateWall2(10, -2, 10, 6);\n    BoardFactory.CreateWall2(10, 6, 8, 6);\n    BoardFactory.CreateWall2(8, -2, 8, 6);\n    BoardFactory.CreateWall2(-5, -2, -10, -2);\n    BoardFactory.CreateWall2(-10, -2, -10, 6);\n    BoardFactory.CreateWall2(-8, 6, -10, 6);\n    BoardFactory.CreateWall2(-8, -2, -8, 6);\n    BoardFactory.CreateWall2(0.5, -10, 0.5, -4);\n    BoardFactory.CreateWall2(3, -4, -2, -4);\n    BoardFactory.CreateWall2(3, -4, 3, 1);\n    BoardFactory.CreateWall2(6, 1, 3, 1);\n    BoardFactory.CreateWall2(6, 1, 6, 3);\n    BoardFactory.CreateWall2(6, 3, 1, 3);\n    BoardFactory.CreateWall2(1, 3, 1, 6);\n    BoardFactory.CreateWall2(1, 6, -2, 6);\n    BoardFactory.CreateWall2(-2, 3, -2, 6);\n    BoardFactory.CreateWall2(-2, 3, -6, 3);\n    BoardFactory.CreateWall2(-6, 1, -6, 3);\n    BoardFactory.CreateWall2(-2, 1, -6, 1);\n    BoardFactory.CreateWall2(-2, -4, -2, 1);\n    BoardFactory.CreateWall2(-7, -12, -11, -8);\n    BoardFactory.CreateWall2(-7, -4, -11, -8);\n    BoardFactory.CreateWall2(-5, -4, -12, -4);\n    BoardFactory.CreateWall2(9, -10, 3, -10);\n    BoardFactory.CreateWall2(3, -10, 3, -6);\n    BoardFactory.CreateWall2(6, -6, 3, -6);\n    BoardFactory.CreateWall2(9, -10, 9, -9);\n    BoardFactory.CreateWall2(9, -9, 6, -6);\n    BoardFactory.CreateWall2(-2, -10, -5, -10);\n    BoardFactory.CreateWall2(-5, -10, -7, -8);\n    BoardFactory.CreateWall2(-5, -6, -7, -8);\n    BoardFactory.CreateWall2(-2, -6, -5, -6);\n    BoardFactory.CreateWall2(-2, -10, -2, -6);\n\n    // Create random switches with random doors\n    if(BoardFactory.CreateRandomSwitch(new Vector3(0, 0, 7.5))){\n      BoardFactory.CreateWall2(-2, 6, -2, 9);\n    }else{\n      BoardFactory.CreateWall2(1, 6, 1, 9);\n    }\n\n    if(BoardFactory.CreateRandomSwitch(new Vector3(6.5, 0, 4))){\n      BoardFactory.CreateWall2(8, 3, 6, 3);\n    }else{\n      BoardFactory.CreateWall2(8, 5, 6, 5);\n    }\n\n    if(BoardFactory.CreateRandomSwitch(new Vector3(-6.5, 0, 4))){\n      BoardFactory.CreateWall2(-6, 5, -8, 5);\n    }else{\n      BoardFactory.CreateWall2(-6, 3, -8, 3);\n    }\n\n    if(BoardFactory.CreateRandomSwitch(new Vector3(4.5, 0, -5))){\n      BoardFactory.CreateWall2(3, -6, 3, -4);\n    }else{\n      BoardFactory.CreateWall2(6, -6, 6, -4);\n    }\n\n    if(BoardFactory.CreateRandomSwitch(new Vector3(-3.5, 0, -5))){\n      BoardFactory.CreateWall2(-5, -6, -5, -4);\n    }else{\n      BoardFactory.CreateWall2(-2, -6, -2, -4);\n    }\n    BoardFactory.CreateFlag(11,-11,0);\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(0, 0.5, 11.5);\n      robot.transform.localEulerAngles.y = 180;\n    })\n  }\n\n  CreateMaze4(){\n    BoardFactory.CreateWall2(1, 9, 1, 12);\n    BoardFactory.CreateWall2(3, 9, 1, 9);\n    BoardFactory.CreateWall2(3, 5, 3, 9);\n    BoardFactory.CreateWall2(6, 5, 3, 5);\n    BoardFactory.CreateWall2(6, 5, 6, 9);\n    BoardFactory.CreateWall2(12, 9, 6, 9);\n    BoardFactory.CreateWall2(-2, 9, -2, 12);\n    BoardFactory.CreateWall2(-2, 9, -4, 9);\n    BoardFactory.CreateWall2(-4, 5, -4, 9);\n    BoardFactory.CreateWall2(-4, 5, -6, 5);\n    BoardFactory.CreateWall2(-6, 5, -6, 9);\n    BoardFactory.CreateWall2(-6, 9, -12, 9);\n    BoardFactory.CreateWall2(12, -8, 8, -4);\n    BoardFactory.CreateWall2(12, -4, 6, -4);\n    BoardFactory.CreateWall2(10, -2, 6, -2);\n    BoardFactory.CreateWall2(10, -2, 10, 6);\n    BoardFactory.CreateWall2(10, 6, 8, 6);\n    BoardFactory.CreateWall2(8, -2, 8, 6);\n    BoardFactory.CreateWall2(-5, -2, -10, -2);\n    BoardFactory.CreateWall2(-10, -2, -10, 6); \n    BoardFactory.CreateWall2(-8, 6, -10, 6);\n    BoardFactory.CreateWall2(-8, -2, -8, 6);\n    BoardFactory.CreateWall2(0.5, -10, 0.5, -4);\n    BoardFactory.CreateWall2(3, -4, -2, -4);\n    BoardFactory.CreateWall2(3, -4, 3, 1);\n    BoardFactory.CreateWall2(6, 1, 3, 1);\n    BoardFactory.CreateWall2(6, 1, 6, 3);\n    BoardFactory.CreateWall2(6, 3, 1, 3);\n    BoardFactory.CreateWall2(1, 3, 1, 6);\n    BoardFactory.CreateWall2(1, 6, -2, 6);\n    BoardFactory.CreateWall2(-2, 3, -2, 6);\n    BoardFactory.CreateWall2(-2, 3, -6, 3);\n    BoardFactory.CreateWall2(-6, 1, -6, 3);\n    BoardFactory.CreateWall2(-2, 1, -6, 1);\n    BoardFactory.CreateWall2(-2, -4, -2, 1);\n    BoardFactory.CreateWall2(-7, -12, -11, -8);\n    BoardFactory.CreateWall2(-7, -4, -11, -8);\n    BoardFactory.CreateWall2(-5, -4, -12, -4);\n    BoardFactory.CreateWall2(9, -10, 3, -10);\n    BoardFactory.CreateWall2(3, -10, 3, -6);\n    BoardFactory.CreateWall2(6, -6, 3, -6);\n    BoardFactory.CreateWall2(9, -10, 9, -9);\n    BoardFactory.CreateWall2(9, -9, 6, -6);\n    BoardFactory.CreateWall2(-2, -10, -5, -10);\n    BoardFactory.CreateWall2(-5, -10, -7, -8);\n    BoardFactory.CreateWall2(-5, -6, -7, -8);\n    BoardFactory.CreateWall2(-2, -6, -5, -6);\n    BoardFactory.CreateWall2(-2, -10, -2, -6);\n    \n    // Create random switches with random doors\n    if(BoardFactory.CreateSwitch(new Vector3(0, 0, 7.5), new BABYLON.Color3(0,1,0))){\n      BoardFactory.CreateWall2(-2, 6, -2, 9);\n    }else{\n      BoardFactory.CreateWall2(1, 6, 1, 9);\n    }\n\n    if(BoardFactory.CreateSwitch(new Vector3(6.5, 0, 4), new BABYLON.Color3(0,1,0))){\n      BoardFactory.CreateWall2(8, 3, 6, 3);\n    }else{\n      BoardFactory.CreateWall2(8, 5, 6, 5);\n    }\n\n    if(BoardFactory.CreateSwitch(new Vector3(-6.5, 0, 4), new BABYLON.Color3(0,1,0))){\n      BoardFactory.CreateWall2(-6, 5, -8, 5);\n    }else{\n      BoardFactory.CreateWall2(-6, 3, -8, 3);\n    }\n\n    if(BoardFactory.CreateSwitch(new Vector3(4.5, 0, -5), new BABYLON.Color3(0,1,0))){\n      BoardFactory.CreateWall2(3, -6, 3, -4);\n    }else{\n      BoardFactory.CreateWall2(6, -6, 6, -4);\n    }\n\n    if(BoardFactory.CreateSwitch(new Vector3(-3.5, 0, -5), new BABYLON.Color3(0,1,0))){\n      BoardFactory.CreateWall2(-5, -6, -5, -4);\n    }else{\n      BoardFactory.CreateWall2(-2, -6, -2, -4);\n    }\n\n    BoardFactory.CreateFlag(11,-11,0);\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(0, 0.5, 11.5);\n      robot.transform.localEulerAngles.y = 180;\n    })\n\n  }\n\n    CreateMaze5(){\n\n    BoardFactory.CreateWall2(1, 9, 1 ,12)\n    BoardFactory.CreateWall2(8, 1, 1, 9)\n    BoardFactory.CreateWall2(8, 1, 5, -2)\n    BoardFactory.CreateWall2(5, -4, 5, -2)\n    BoardFactory.CreateWall2(9, -4, 5, -4)\n    BoardFactory.CreateWall2(10, -7, 9, -4)\n    BoardFactory.CreateWall2(10, -12, 10, -7)\n    BoardFactory.CreateWall2(-2, 9, -2, 12)\n    BoardFactory.CreateWall2(-2, 9, -9, 2)\n    BoardFactory.CreateWall2(-6, -1, -9, 2)\n    BoardFactory.CreateWall2(-6, -3, -6, -1)\n    BoardFactory.CreateWall2(-6, -3, -10, -3)\n    BoardFactory.CreateWall2(-10, -3, -11, -7)\n    BoardFactory.CreateWall2(-11, -12, -11, -7)\n    BoardFactory.CreateWall2(7, -7, 7, -12)\n    BoardFactory.CreateWall2(7, -7, 2, -7)\n    BoardFactory.CreateWall2(2, -7, 2, -2)\n    BoardFactory.CreateWall2(2, -2, 5, 1)\n    BoardFactory.CreateWall2(5, 1, -0.5, 7)\n    BoardFactory.CreateWall2(-6, 2, -0.5, 7)\n    BoardFactory.CreateWall2(-3, -1, -6, 2)\n    BoardFactory.CreateWall2(-3, -6, -3, -1)\n    BoardFactory.CreateWall2(-3, -6, -8, -6)\n    BoardFactory.CreateWall2(-8, -12, -8, -6)\n\n    let col1: BABYLON.Color3, col2: BABYLON.Color3;\n    let x = Random.Range(0,10);\n    if(x >= 5){\n      col1 = new BABYLON.Color3(0, 1, 1);\n      col2 = new BABYLON.Color3(1, 0, 0);\n    }else{\n      col2 = new BABYLON.Color3(0, 1, 1);\n      col1 = new BABYLON.Color3(1, 0, 0);\n    }\n\n\n    BoardFactory.CreateLine(-0.5, 8.5, 6.5, 1, col1)\n    BoardFactory.CreateLine(6.5, 1, 3.5, -2, col1)\n    BoardFactory.CreateLine(3.5, -5.5, 3.5, -2, col1)\n    BoardFactory.CreateLine(3.5, -5.5, 8, -5.5, col1)\n    BoardFactory.CreateLine(8.5, -7, 8, -5.5, col1)\n    BoardFactory.CreateLine(8.5, -12, 8.5, -7, col1)\n\n    BoardFactory.CreateLine(-0.5, 8.5, -7.5, 2, col2)\n    BoardFactory.CreateLine(-7.5, 2, -4.5, -1, col2)\n    BoardFactory.CreateLine(-4.5, -4.5, -4.5, -1, col2)\n    BoardFactory.CreateLine(-4.5, -4.5, -9.5, -4.5, col2)\n    BoardFactory.CreateLine(-9.5, -4.5, -9.5, -12, col2)\n    BoardFactory.CreateFlag(8.5,-11.5,0);\n    BoardFactory.CreateFlag(-9.5,-11.5,0);\n\n    BoardFactory.CreateRandomSwitch(new Vector3(-0.5, 0, 8.5))\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(-0.5, 0.5, 11.5);\n      robot.transform.localEulerAngles.y = 180;\n    })\n  }\n\n  CreateMaze7(){\n\n    for(let i = 0; i < 24; i++){\n      let col = i % 2 == 0 ? \n        new BABYLON.Color3(1, 165/265, 0) :\n        new BABYLON.Color3(0, 1, 1);\n      let x = Random.Range(-10, 10);\n      if(9 - (i * 0.8) < -3){\n        x = i % 2 == 0 ?\n          Random.Range(-10, -5):\n          Random.Range(5, 10)\n      }\n      BoardFactory.CreateBox(x, 9 - (i * 0.8), col)\n    }\n\n    let mat = Instantiate(ColorTag, new Vector3(0, 0.1, -7.5))\n    mat.SetColor(new BABYLON.Color3(1,0,0));\n    mat.SetSize(7, 7)\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(-0.5, 0.5, 11.5);\n      robot.transform.localEulerAngles.y = 180;\n    })\n\n  }\n\n  CreateMaze6(){\n    BoardFactory.CreateWall2(12, 9, 10, 9)\n    BoardFactory.CreateWall2(10, -12, 10, 9)\n    BoardFactory.CreateWall2(10, 0, 2, 0)\n    BoardFactory.CreateWall2(3, 0, 3, 5)\n    BoardFactory.CreateWall2(2, 0, 2, 5)\n    BoardFactory.CreateWall2(3, 5, -5, 5)\n    BoardFactory.CreateWall2(-5, 4, -5, 5)\n    BoardFactory.CreateWall2(2, 4, -5, 4)\n    BoardFactory.CreateWall2(7, 4, 7, 12)\n    BoardFactory.CreateWall2(7, 4, 6, 4)\n    BoardFactory.CreateWall2(6, 4, 6, 9)\n    BoardFactory.CreateWall2(6, 9, -8, 9)\n    BoardFactory.CreateWall2(-8, 1, -8, 9)\n    BoardFactory.CreateWall2(-1 ,1, -8, 1)\n    BoardFactory.CreateWall2(-1, -2, -1, 1)\n    BoardFactory.CreateWall2(7, -2, -5 ,-2)\n    BoardFactory.CreateWall2(7, -9, 7, -2)\n    BoardFactory.CreateWall2(7, -9, 6, -9)\n    BoardFactory.CreateWall2(6, -9, 6, -5)\n    BoardFactory.CreateWall2(6, -5, 2, -5)\n    BoardFactory.CreateWall2(2, -5, 2, -2)\n    BoardFactory.CreateWall2(-5, -6, -5, -2)\n    BoardFactory.CreateWall2(-5, -6, -9, -6)\n    BoardFactory.CreateWall2(-9, -9, -9, -6)\n    BoardFactory.CreateWall2(-9, -9, -12, -9)\n    BoardFactory.CreateWall2(3, -12, 3, -8)\n    BoardFactory.CreateWall2(3, -8, -1, -8)\n    BoardFactory.CreateWall2(-1, -8, -1, -4)\n    BoardFactory.CreateWall2(-1, -4, -2, -4)\n    BoardFactory.CreateWall2(-2, -9, -2, -4)\n    BoardFactory.CreateWall2(-2, -9, -6, -9)\n    BoardFactory.CreateWall2(-6, -12, -6, -9)\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(11, 0.5, 10.5);\n      robot.transform.localEulerAngles.y = -90;\n    })\n\n    let start_patch = Instantiate(ColorTag, new Vector3(10.5, 0.1, 10.5))\n    start_patch.SetColor(new BABYLON.Color3(1,0,0));\n    start_patch.SetSize(3, 3)\n\n    let goal_patch = Instantiate(ColorTag, new Vector3(-10.5, 0.1, -10.5))\n    goal_patch.SetColor(new BABYLON.Color3(0,0,1));\n    goal_patch.SetSize(3, 3)\n  }\n\n  CreateMaze8(){\n    BoardFactory.CreateWall2(12, 9, 10, 9)\n    BoardFactory.CreateWall2(10, 3, 10 ,9)\n    BoardFactory.CreateWall2(10, -3, 10, 1)\n    BoardFactory.CreateWall2(10, 0, 1, 0)\n    BoardFactory.CreateWall2(3, 0, 3, 5)\n    BoardFactory.CreateWall2(3, 5, -5, 5)\n    BoardFactory.CreateWall2(-5, 2, -5, 5)\n    BoardFactory.CreateWall2(-3, 2, -5, 2)\n    BoardFactory.CreateWall2(1, 0, 1, 2)\n    BoardFactory.CreateWall2(1, 2, -1, 2)\n    BoardFactory.CreateWall2(10, -12, 10, -5)\n    BoardFactory.CreateWall2(7, 9, 7, 12)\n    BoardFactory.CreateWall2(7, 9, -8, 9)\n    BoardFactory.CreateWall2(-8, -2, -8, 9)\n    BoardFactory.CreateWall2(2, -2, -8, -2)\n    BoardFactory.CreateWall2(2, -5, 2, -2)\n    BoardFactory.CreateWall2(6, -5, 2, -5)\n    BoardFactory.CreateWall2(6, -7, 6, -5)\n    BoardFactory.CreateWall2(7, -7, 6, -7)\n    BoardFactory.CreateWall2(7, -7, 7, -2)\n    BoardFactory.CreateWall2(7, -2, 4, -2)\n    BoardFactory.CreateWall2(-5, -3, -5, -2)\n    BoardFactory.CreateWall2(4, -7, -1, -7)\n    BoardFactory.CreateWall2(-1, -7, -1, -4)\n    BoardFactory.CreateWall2(-1, -4, -2, -4)\n    BoardFactory.CreateWall2(-2, -8, -2, -4)\n    BoardFactory.CreateWall2(-2, -8, -6, -8)\n    BoardFactory.CreateWall2(-6, -8, -6, -6)\n    BoardFactory.CreateWall2(-6, -6, -5, -6)\n    BoardFactory.CreateWall2(-5, -6, -5, -5)\n    BoardFactory.CreateWall2(3, -12, 3, -10)\n    BoardFactory.CreateWall2(3, -10, -6, -10)\n    BoardFactory.CreateWall2(-6, -12, -6, -10)\n    BoardFactory.CreateWall2(-8, -6, -9, -6)\n    BoardFactory.CreateWall2(-9, -9, -9, -6)\n    BoardFactory.CreateWall2(-9 ,-9, -12, -9)\n    BoardFactory.CreateWall2(-10, -5, -12, -5)\n    BoardFactory.CreateWall2(-10, -5, -10, -2)\n    BoardFactory.CreateWall2(-10, -2, -12, -2)\n\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \n      robot.transform.position = new Vector3(11, 0.5, 10.5);\n      robot.transform.localEulerAngles.y = -90;\n    })\n\n    let start_patch = Instantiate(ColorTag, new Vector3(10.5, 0.1, 10.5))\n    start_patch.SetColor(new BABYLON.Color3(1,0,0));\n    start_patch.SetSize(3, 3)\n\n    let goal_patch = Instantiate(ColorTag, new Vector3(-10.5, 0.1, -10.5))\n    goal_patch.SetColor(new BABYLON.Color3(0,0,1));\n    goal_patch.SetSize(3, 3)\n  }\n\n  CreatePlayground(){\n    BoardFactory.CreateWall2(-12, -12, -12, -1.5);\n    BoardFactory.CreateWall2(-12, 12, -12, 1.5);\n    BoardFactory.CreateWall2(12, -12, 12, -1.5);\n    BoardFactory.CreateWall2(12, 12, 12, 1.5);\n    BoardFactory.CreateWall2(-12, -12, -1.5, -12);\n    BoardFactory.CreateWall2(12, -12, 1.5, -12);\n    BoardFactory.CreateWall2(-12, 12, -1.5, 12);\n    BoardFactory.CreateWall2(12, 12, 1.5, 12);\n    this.robot.forEach(robot=>{\n      robot.SetRobotMesh(\"robot_1.obj\")\n      robot.SetRobotColor(171/256, 64/256, 81/256) \n      robot.transform.position = new Vector3(-0, 0.5, 6); \n      robot.transform.localEulerAngles.y = 180;\n    })\n  }\n\n}\n\nclass LevelTwo extends DefaultObjectMaterialTexture {\n\n  Start() {\n    this.SetupFloor();\n  }\n\n  SetupFloor(){\n    // this.renderer.SetMesh(BABYLON.Mesh.CreatePlane(\"Floor\", 24, Engine.scene));\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\"LevelFloor\", {depth: 1, width: 1, height: 1}));\n    // this.transform.eulerAngles = new Vector3(90,0,0);\n    \n    var texture : BABYLON.Texture = TextureSystem.GetSprite(\"rubber_board.jpg\")\n    texture.uScale = 6.0;\n    texture.vScale = 6.0;\n\n    var normal : BABYLON.Texture = TextureSystem.GetSprite(\"rubber_board_normal.jpg\")\n    normal.uScale = 6.0;\n    normal.vScale = 6.0; \n    \n    var material  = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n    material.diffuseTexture = texture;\n    material.bumpTexture = normal;\n\n    this.renderer.GetMesh().material = material;\n    this.transform.localScale.x = 24;\n    this.transform.localScale.z = 24;\n    var coll = this.gameObject.AddComponent(BoxCollider)\n    //Collide with all robots!\n    coll.layerMask = ROBOT_LAYER_MASK;\n    this.transform.position.y = -0.5\n    // this.gameObject.AddComponent(Rigidbody)\n    // this.gameObject.GetComponent(Rigidbody).isKinematic = true\n    // this.GetComponent(Rigidbody).friction = 1000;\n    \n    this.renderer.GetMesh().receiveShadows = true;\n  }\n\n}\n\nclass LevelTwoBorders extends MonoBehaviour {\n\n  Start() {\n    // this.renderer.SetMesh(BABYLON.MeshBuilder.CreatePlane(\"LevelTwoBorder\", { sideOrientation: BABYLON.Mesh.DOUBLESIDE }));\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\"LevelTwoWall\", {depth: 1}));\n    \n    var texture : BABYLON.Texture = TextureSystem.GetSprite(\"bricks_texture.jpg\")\n    texture.uScale = this.transform.localScale.x;\n\n    var normal : BABYLON.Texture = TextureSystem.GetSprite(\"bricks_normal.jpg\")\n    normal.uScale = this.transform.localScale.x;\n  \n    var material  = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n    material.diffuseTexture = texture;\n    material.bumpTexture = normal;\n\n    this.renderer.GetMesh().material = material;\n\n    CustomShadows.generator.addShadowCaster(this.renderer.GetMesh(), true);\n  \n    var coll = this.gameObject.AddComponent(BoxCollider)\n    coll.layerMask = ROBOT_LAYER_MASK;\n   // super.Setup(1, 0, 0, 1);\n    // this.gameObject.AddComponent(BoxCollider)\n  }\n}\n\nclass LevelTwoCoins extends DefaultObjectMaterialColor{\n  Start(){\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateCylinder(\"LevelTwoCoin\", {height: 0.1, diameter: 0.5}))\n    super.Setup(1,1,0,1);\n    this.transform.localEulerAngles.x = 90;\n    CustomShadows.generator.addShadowCaster(this.renderer.GetMesh(), true);\n  }\n\n  Update(){\n    this.transform.localEulerAngles.z += 2;\n  }\n}\n\nclass LevelTwoFlag extends DefaultObjectMaterialColor{\n\n  setTexture : boolean = false;\n  scaleFactor = 0.07;\n\n  Start(){\n    \n    this.renderer.LoadMesh(\"flagpole.obj\", this.scaleFactor, null, false);\n    Instantiate(FlagTrigger, this.transform.position);\n  }\n\n  Update ()\n  {\n    if (this.renderer.GetMesh() != null && !this.setTexture) \n    {\n      this.setTexture = true;\n\n      let mat = new BABYLON.StandardMaterial(\"mat1\", Engine.scene)\n      var texture = TextureSystem.GetSprite(\"FirstCanada_Logo_Border.jpg\"); \n      texture.uScale = 0.7;\n      texture.vScale = 0.7;\n\n      texture.uOffset = 0.85;\n      texture.vOffset = 0.1;\n      mat.diffuseTexture = texture;\n\n      this.renderer.GetMeshes().forEach(mesh => {   \n        mesh.scaling = new BABYLON.Vector3(this.scaleFactor,this.scaleFactor,this.scaleFactor);\n\n        if(mesh.id.includes(\"Flag\")){\n          mesh.material = mat;\n        }\n\n        //Why does this break shadows?\n        //Shadows.generator.addShadowCaster(mesh, true);\n\n      });\n     \n    }\n  }\n}\n\nclass FlagTrigger extends MonoBehaviour\n{\n  triggerSize : number = 5;\n  inVictoryArea: boolean = false;\n  isVictory: boolean = false;\n  Start ()\n  {\n    this.transform.localScale = new Vector3(this.triggerSize,this.triggerSize,this.triggerSize);\n    //To visualize \n    //this.renderer.LoadMesh(\"sphere\");\n\n    this.gameObject.AddComponent(SphereCollider).isTrigger = true;\n  }\n\n  Update(){\n    if(this.inVictoryArea){\n      if(!this.isVictory){\n        if(!Robot.main.IsMoving()){\n          MainGame.instance.OnVictory();\n          this.isVictory = true;\n        }\n        \n      }\n    }\n  }\n\n  OnTriggerEnter(other : Collider)\n  {\n    if (other.GetComponent(Robot))\n    {\n        this.inVictoryArea = true;\n    }\n    \n  }\n\n  OnTriggerExit(other : Collider)\n  {\n    if (other.GetComponent(Robot))\n    {\n      this.inVictoryArea = false;\n    }\n  }\n}\n\nclass BoardFactory extends MonoBehaviour{\n  public static CreateWall(posX: number, posY: number, width: number, angle: number){\n    let wall = Instantiate(LevelTwoBorders, new Vector3(posX, 0.5, posY));\n    wall.transform.localEulerAngles.y = angle;\n    wall.transform.localScale = new Vector3(width, 1, 0.1);\n    \n  }\n\n  public static CreateWall2(x1: number, y1: number, x2: number, y2: number){\n    let center = new Vector3(\n      (x1 + x2) / 2,\n      0.5,\n      (y1 + y2) / 2\n    )\n    let start = new Vector3(x1 , 0, y1);\n    let end = new Vector3(x2, 0, y2);    \n    let wall = Instantiate(LevelTwoBorders, center)\n    wall.transform.position.y = 0.5;\n    let angle = Utility.GetAngle(start, end);\n    let distance = Utility.GetDistance(start,end) * 0.1;\n    wall.transform.localScale = new Vector3(distance, 1, 0.1)\n    wall.transform.localEulerAngles.y = angle\n  }\n\n  public static CreateLine(x1: number, y1: number, x2: number, y2: number, col: BABYLON.Color3){\n     let center = new Vector3(\n      (x1 + x2) / 2,\n      -0.01,\n      (y1 + y2) / 2\n    )\n    let start = new Vector3(x1 , 0, y1);\n    let end = new Vector3(x2, 0, y2);\n    \n    let colTag1 = Instantiate(ColorTag, center)\n    let angle = Utility.GetAngle(start, end);\n    let distance = Utility.GetDistance(start,end) * 0.1;\n    colTag1.SetColor(col);\n    colTag1.transform.localScale = new Vector3(distance, 0.1, 0.1)\n    colTag1.transform.localEulerAngles.y = angle\n  }\n\n  public static CreateCoin(posX: number, posY: number){\n    let coin = Instantiate(LevelTwoCoins, new Vector3(posX, 0.5, posY));\n  }\n\n  public static CreateFlag(posX: number, posY: number, angle: number){\n    let flag = Instantiate(LevelTwoFlag, new Vector3(posX, 0, posY));\n    \n    flag.transform.localEulerAngles.y = angle\n  }\n\n  public static CreateRandomSwitch(pos: Vector3): boolean{\n    let tagCol = this.RandomColor();\n    let bIsRed = tagCol.r == 1;\n    let colTag1 = Instantiate(ColorTag, pos)\n    colTag1.SetColor(tagCol);\n    return bIsRed;\n  }\n\n  public static CreateSwitch(pos: Vector3, col: BABYLON.Color3){\n    let bIsRed = this.RandomColor().r == 1;\n    let colTag1 = Instantiate(ColorTag, pos)\n    colTag1.SetColor(col);\n    return bIsRed;\n  }\n\n  public static CreateBox(posX: number, posY: number, col: BABYLON.Color3){\n    let box = Instantiate(ColorBox, new Vector3(posX, 1, posY));\n    box.SetColor(col);\n  }\n\n  public static RandomColor(){\n    if(Random.Range(0.0, 1.0)>= 0.5){\n      return new BABYLON.Color3(1,0,0)\n    }else{\n      return new BABYLON.Color3(0,0,1)\n    }\n  }\n}\n\n\n",
            "OpModeIsActiveMove": "//RunOpMode returns true, but it waits one frame before it does so\n//This way, it can be used in a while loop to make it into a 'tick'\nclass OpModeIsActiveObj extends Move {\n\n  private framesPassed : number = 0;\n\n  Update ()\n  {\n    this.framesPassed++;\n  }\n\n  IsCompleted ()\n  {\n    //We check the second frame because Update is actually called once when the move is created\n    return this.framesPassed >= 2;\n  }\n\n  //Currrently it's always true - should be only for 30 seconds?\n  GetReturnValue ()\n  {\n    \n    return true;\n  }\n}\n\nasync function OpModeIsActive (robot)\n{\n  return new OpModeIsActiveObj(robot).Run();\n}\n",
            "Helpers": "\nfunction GetPHPVariable (name : string) : string\n{\n  var parts = window.location.search.substr(1).split(\"&\");\n  var $_GET = {};\n  for (var i = 0; i < parts.length; i++) {\n      var temp = parts[i].split(\"=\");\n      $_GET[decodeURIComponent(temp[0])] = decodeURIComponent(temp[1]);\n  }\n  return ($_GET[name]);\n}\n\nfunction GetIsChallenge() : boolean \n{  \n  if(window.location.href.includes(\"challenge\")){\n    return true;\n  }\n  return false;\n}\n\nfunction ConvertJsonCode(text: string): object{\n  return JSON.parse(text)\n}",
            "CameraFadeInFadeOut": "class CameraFadeInFadeOut extends MonoBehaviour {\n\n  //Tweakables\n  logoDuration : number = 0.5;\n  nFramesToFade : number = 155;\n\n  private static firstLoad : boolean = true;\n  public light: BABYLON.DirectionalLight;\n  public static instance : CameraFadeInFadeOut;\n\n  public isLightUp: boolean = false;\n  private timer: number = 0;\n  private isCamSet: boolean = false;\n  private cam: BABYLON.ArcRotateCamera;\n  private pos: BABYLON.Vector3;\n\n  private logo : CustomImage;\n  private nCurrentFrames = 0;\n\n  Awake(){\n\n    //Only when refreshing should the logo be shown\n    if (CameraFadeInFadeOut.firstLoad)\n    {\n      CameraFadeInFadeOut.instance = this;      \n      this.logo = Instantiate(CustomImage).Init(\"FirstRoboticsCanada.jpg\", 327, 255);\n      CameraFadeInFadeOut.firstLoad = false;\n    }\n    else\n    {\n      //No logo\n      this.timer = this.logoDuration;\n    }\n  }\n\n\n  Update(){\n\n    //Wait with showing until robot is loaded.\n    let robot = Robot.main;\n    if(this.timer >= this.logoDuration){\n      if(Robot.main && !Robot.main.renderer.isLoadingMesh){\n        this.DestroyLogo();\n      }else{\n        this.DestroyLogo();\n      }\n      \n      \n      \n\n      //Fade in\n      // if(this.nCurrentFrames < this.nFramesToFade){\n      //   //Main (HemiSpheric) light gives general light\n      //   this.light.intensity = this.nCurrentFrames * 0.005;\n      //   //Directional light is for shadows\n      //   CustomShadows.light.intensity = this.nCurrentFrames * 0.01;\n      //   this.nCurrentFrames++;\n      // }else{\n      //   this.isLightUp = true\n      // }      \n    }else{\n      this.timer += Time.deltaTime;\n    }\n\n\n    if(this.cam !== undefined){\n      // handle the zooming in too much\n      this.cam.radius = this.cam.radius < 4.5 ? 4.5 : this.cam.radius;\n      // handle the zooming out too much\n      this.cam.radius = this.cam.radius > 50 ? 50 : this.cam.radius;\n    }\n\n\n\n  }\n\n  DestroyLogo(){\n    if (this.logo)\n      {\n        Destroy(this.logo.gameObject);\n        this.logo = null;        \n      }\n  }\n\n}\n\n",
            "Shadows": "class CustomShadows extends MonoBehaviour {\n\n  public static generator : BABYLON.ShadowGenerator;\n  public static light : BABYLON.DirectionalLight;\n\n  //Start is called before the first frame update\n  Awake() {\n      \n      \t// light1\n    if(!CustomShadows.light)\n    CustomShadows.light = new BABYLON.DirectionalLight(\"dir01\", new BABYLON.Vector3(-1, -1, -1), Engine.scene);\n    CustomShadows.light.position = new BABYLON.Vector3(20, 40, 20);\n    CustomShadows.light.intensity = 0;\n      \n    CustomShadows.generator = new BABYLON.ShadowGenerator(1024, CustomShadows.light);\n    CustomShadows.generator.useExponentialShadowMap = true;\n  }\n  \n  //Update is called once per frame\n  Update() {\n  \n  }\n\n  OnDestroy()\n  {\n    CustomShadows.generator.dispose();\n    CustomShadows.light.dispose();\n  }\n}\n",
            "FPSCounterGUI": "class FPSCounterGUI extends MonoBehaviour\n{\n    \n    nFrameUpdateInterval : number = 10;\n\n    text : BABYLON.GUI.TextBlock;\n    average : number = 0;\n    nFramesSinceUpdate : number = 0;\n\n    Start()\n    {\n      this.text = new BABYLON.GUI.TextBlock(\"FPS\", \"\");\n      this.text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n      this.text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n      this.text.color = \"white\";\n      Canvas.main.addControl(this.text);\n    }\n\n    Update ()\n    {\n        this.nFramesSinceUpdate++;\n        this.average += Time.deltaTime;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval)\n        {\n            this.text.text = \"FPS: \" + (1 / (this.average/ this.nFrameUpdateInterval)).toFixed(0);\n            this.average = 0;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n}",
            "PlayButton": "class PlayButton extends MonoBehaviour\n{\n    button : BABYLON.GUI.Button;\n\n    Start()\n    {\n      this.button = BABYLON.GUI.Button.CreateSimpleButton(\"PlayButton\", \"Init\")\n      this.button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n      this.button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n      this.button.color = \"white\";\n      this.button.widthInPixels = 100;\n      this.button.heightInPixels = 30;\n      this.button.topInPixels = 20;\n      this.button.onPointerClickObservable.add(e => {\n        this.button.textBlock.text = \"Stop\";\n        if (MainGame.instance.isRunning)\n        {\n          //Stop the async moves\n          // Move.current = null;\n          SceneManager.ReloadCurrentScene();\n        }\n        else \n        {\n          runRobotCode ();\n\n        }\n        MainGame.instance.isRunning = !MainGame.instance.isRunning;\n      });\n      Canvas.main.addControl(this.button);\n    }  \n    \n\n    \n}",
            "ColorRobot": "class ColorRobot extends MonoBehaviour {\n  public static SetColor(meshName: string, robot: Robot){\n    switch(meshName){\n\n      case \"robot_1.obj\":\n        \n          robot.renderer.GetMeshes().forEach((e,i) => {\n            e.position.y -= 0.5,\n            e.isPickable = false\n            let mat = new BABYLON.StandardMaterial(\"mat1\", Engine.scene)\n            mat.roughness = 0.2 \n            mat.diffuseColor = new BABYLON.Color3(0.2,0.2,0.2)\n            if(e.id.includes(\"Cube\")){\n              mat.diffuseColor = new BABYLON.Color3(1,0,0)\n            }\n            if(e.id.includes(\"bubbles\") ||\n              e.id.includes(\"Cube.001\") ||\n              e.id.includes(\"Cube.002\") ){\n              mat.diffuseColor = new BABYLON.Color3(0.4,0.2,0.2)\n\n            }\n\n            if(\n              e.id.includes(\"Cylinder.010\") ||\n              e.id.includes(\"Cylinder.012\") ||\n              e.id.includes(\"Cylinder.016\") ||\n              e.id.includes(\"Cylinder.017\")){\n              mat.diffuseColor = new BABYLON.Color3(0.7,0.7,0.7)\n            }\n\n            if(e.id.includes(\"Cylinder.020\") ||\n              e.id.includes(\"Gear\")\n              ){\n              mat.diffuseColor = new BABYLON.Color3(0,0.7,0)\n\n            }\n\n            if(e.id.includes(\"Cube.018\") ||\n              e.id.includes(\"Plaque\")){\n              mat.diffuseColor = new BABYLON.Color3(0.7,0.7,0)\n            }\n\n            if(e.id.includes(\"Cube_Cube.004\")){\n              mat.diffuseColor = new BABYLON.Color3(0,0,0.5)\n            }\n\n            if(\n              e.id.includes(\"Cylinder.002\") ||\n              e.id.includes(\"Cylinder.009\") ||\n              e.id.includes(\"Cylinder.008\")\n            ){\n              mat.diffuseColor = new BABYLON.Color3(1,0.6,0)\n            }\n            \n            e.material = mat\n          })\n        \n        break;\n        default:\n          let mat = new BABYLON.StandardMaterial(\"mat1\", Engine.scene);\n          mat.roughness = 0.2;\n          mat.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.2)\n          Robot.main.renderer.GetMeshes().forEach(e => {\n            e.material = mat; \n          })\n    }\n    \n  }\n  \n}\n",
            "CamTarget": "class CamTarget extends MonoBehaviour {\n\n  moveSpeed : number = .1;\n\n\n  firstFrame : boolean = true;\n  offset: Vector3 = new Vector3(0,0,0);\n  origin: Vector3 = new Vector3(0,0,0);\n  robotOffset: Vector3 = new Vector3(0,0,0);\n  robotOrigin: Vector3 = new Vector3(0,0,0);\n\n  cameraSpeed: number = 0.3\n\n  //Start is called before the first frame update\n  Start() {\n    this.transform.localEulerAngles = new Vector3(0,0,0);\n    //this.renderer.LoadMesh(\"sphere\", 0.1);\n    this.origin = this.transform.position.clone();\n    this.robotOrigin = Robot.main.transform.position.clone();\n    // cam.setTarget(Robot.main.renderer.GetMesh(), false, true)\n    \n  }\n  \n  //Update is called once per frame\n  Update() {\n    if (this.firstFrame)\n    {\n      this.firstFrame = false;\n      return;\n    }\n\n    this.robotOffset = new Vector3(\n      Robot.main.transform.position.x - this.robotOrigin.x,\n      Robot.main.transform.position.y - this.robotOrigin.y,\n      Robot.main.transform.position.z - this.robotOrigin.z,\n    );\n    \n    \n    \n    this.Panning();\n    \n\n     \n  }\n\n  Panning ()\n  {\n    this.transform.radians.y = Camera.main.bCam.absoluteRotation.toEulerAngles().y;\n\n    var translation = BABYLON.Vector3.Zero();\n\n    if (Input.GetKey(KeyCode.W))\n    {\n      translation.z = 1;\n    }\n\n    if (Input.GetKey(KeyCode.S))\n    {\n      translation.z = -1;\n    }\n\n    if (Input.GetKey(KeyCode.A))\n    {\n      translation.x = -1;\n    }\n\n    if (Input.GetKey(KeyCode.D))\n    {\n      translation.x = 1;\n    }\n\n    this.transform.transformNode.translate(translation, this.moveSpeed, BABYLON.Space.LOCAL);\n\n  }\n\n  UnrealMovement(){\n    var cam =  Camera.main.bCam as BABYLON.ArcRotateCamera;\n    this.transform.radians.y = cam.absoluteRotation.toEulerAngles().y;\n\n    // cam.setTarget(Robot.main.renderer.GetMesh(), false, true)\n    let movingAngle = this.transform.eulerAngles.y;\n    let rot = cam.absoluteRotation.toEulerAngles();\n    // Debug.Log(\"x: \" + rot.x * Mathf.Rad2Deg + \", y: \" + rot.y * Mathf.Rad2Deg + \", z: \" + rot.z * Mathf.Rad2Deg);\n  \n    if (Input.GetKey(KeyCode.W))\n    {\n      this.offset.z += Math.cos(rot.y) * this.cameraSpeed;\n      this.offset.x += Math.sin(rot.y) * this.cameraSpeed;\n      this.offset.y -= Math.sin(rot.x) * this.cameraSpeed;\n    }\n    if (Input.GetKey(KeyCode.A))\n    {\n      this.offset.x -= Math.cos(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\n      this.offset.z += Math.sin(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\n     // this.renderer.isVisible = true;\n    }\n    if (Input.GetKey(KeyCode.S))\n    {\n      this.offset.z -= Math.cos(rot.y) * this.cameraSpeed;\n      this.offset.x -= Math.sin(rot.y) * this.cameraSpeed;\n      this.offset.y += Math.sin(rot.x) * this.cameraSpeed;\n    }\n    if (Input.GetKey(KeyCode.D))\n    {\n      this.offset.x += Math.cos(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\n      this.offset.z -= Math.sin(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\n     // this.renderer.isVisible = true;\n    }\n\n    if (Input.GetKey(KeyCode.Space)){\n      this.offset = new Vector3(0,0,0);\n    }\n    this.transform.position = new Vector3(\n      this.origin.x + this.offset.x + this.robotOffset.x,\n      this.origin.y + this.offset.y + this.robotOffset.y,\n      this.origin.z + this.offset.z + this.robotOffset.z\n    );\n  }\n  \n}\n",
            "HDREnvironment": "class HDREnvironment extends MonoBehaviour {\n\n  Start() {\n    var skybox = BABYLON.MeshBuilder.CreateBox(\"skyBox\", {size:100.0}, Engine.scene);\n    var skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", Engine.scene);\n    skyboxMaterial.backFaceCulling = false;\n    skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture(getTexture(\"machineShop.hdr\"), Engine.scene, 256);\n    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\n    skybox.material = skyboxMaterial;\n  }\n}\n",
            "Utility": "class Utility {\n  public static CalculateMotorMovement(motor: RobotMotor){\n    if(!motor.enabled){\n      return {direction: 0, rotation: 0};\n    }\n    // create result object to return \n    let pow = Math.abs(motor.GetPower()) >= 1 ? Math.sign(motor.GetPower()) : motor.GetPower();\n    const result = {\n      direction: 0.03 * pow,\n      rotation: 1 * pow\n      };\n    // if running in RUN_TO_POSITION mode, tickPosition is required\n    \n    if(motor.GetMode() == MotorModeEnum.RUN_TO_POSITION){\n      result.direction = 0.02;\n      result.rotation = 1;\n      // move forward if the tick position hasn't reached the tick destination yet\n      // (keep the same direction and rotation as the same)\n      if(motor.GetTickPosition() < motor.GetTickDestination()){\n        motor.AddTickPosition();\n      // move backward if the tick position goes over the destination\n      } else if(motor.GetTickPosition() > motor.GetTickDestination()){\n        motor.AddTickPosition(-1);\n        result.direction *= -1;\n        result.rotation *= -1;\n      // stop if the motor tick is at the tick destination\n      } else{\n        result.direction = 0;\n        result.rotation = 0\n      }\n    }\n    // reverse both direction and rotation if the motor is in reverse mode\n    if(motor.GetDirection() == MotorDirectionEnum.REVERSE){\n      result.direction *= -1;\n      result.rotation *= -1;\n    }\n    // if the motor is left side, reverse the direction & rotation\n    if(motor.GetName().toLowerCase().includes(\"left\")){\n       result.direction *= -1;\n    }\n    // Debug.Log(\"result = \" + result.direction)\n    if(motor.GetMode()==MotorModeEnum.RUN_TO_POSITION){\n      result.rotation = result.rotation;\n    }\n    \n    return result;\n  }\n\n  public static GetServoRotation(servo: RobotServo){\n    if(servo.enabled){\n      return servo.GetRotation();\n    }\n    if(servo.GetPosition() < servo.GetTarget()){\n      servo.AddPosition(servo.speed);\n    }else if(servo.GetPosition() > servo.GetTarget()){\n      servo.AddPosition(-servo.speed);\n    }\n    return servo.GetRotation();\n  }\n\n  public static CompareColor(col1: BABYLON.Color3, col2: BABYLON.Color3): boolean{\n    return col1.r == col2.r && col1.g == col2.g && col1.b == col2.b;\n  }\n\n   public static ConvertRgbToHsv(r: number, g: number, b: number): BABYLON.Color3 {\n    var targetColorHSV = new BABYLON.Color3(r, g, b);\n    targetColorHSV = targetColorHSV.toHSV();\n    return targetColorHSV;\n  }\n\n  public static GetAngle(pos1: Vector3, pos2: Vector3){\n    let deltaX = pos2.x - pos1.x;\n    let deltaZ = pos2.z - pos1.z;\n    let theta = -Math.atan2(deltaZ, deltaX) * Mathf.Rad2Deg;\n    return theta;\n  }\n\n  public static GetDistance(pos1: Vector3, pos2: Vector3){\n    let deltaX = pos2.x - pos1.x;\n    let deltaZ = pos2.z - pos1.z;\n    let distance = Math.sqrt(Math.abs(Math.pow(deltaX, 2) + Math.pow(deltaZ, 2)));\n    //Multiplied by 10 to be centimeters\n    return distance * 10;\n  }\n\n  public static GetEulerAngleFromTwoVectors(pos1: Vector3, pos2: Vector3){\n    let result = new Vector3(0,0,0);\n    let dif = new Vector3(pos2.x - pos1.x, pos2.y - pos1.y, pos2.z - pos1.z);\n    result.x = Math.atan2(dif.z, dif.x) * Mathf.Rad2Deg;\n    result.y = Math.atan2(dif.y, Math.sqrt(Math.pow(dif.z, 2) + Math.pow(dif.x, 2))) * Mathf.Rad2Deg;\n    return result;\n  }\n\n  /** Use to get the direction from start to end */\n  public static VectorDifference(start: Vector3, end: Vector3): Vector3 {\n    return new Vector3(end.x - start.x, end.y - start.y, end.z - start.z);\n  }\n\n  /** Use to get distance from 2 vectors */\n  public static VectorDistance(start: Vector3, end: Vector3): number {\n    const _v = this.VectorDifference(start, end);\n    return Math.sqrt(Math.pow(_v.x, 2) + Math.pow(_v.y, 2) + Math.pow(_v.z, 2));\n  }\n\n}",
            "FollowCamera": "class FollowCamera extends MonoBehaviour {\n  @SerializeField\n  target: GameObject; \n  direction: Vector3;\n  //Start is called before the first frame update\n  Start() {\n    \n  }\n  \n  //Update is called once per frame\n  Update() {\n    if(this.target){\n      this.transform.transformNode.lookAt(this.target.transform.transformNode.position);\n    }else{\n      this.target = Robot.main.gameObject;\n    }\n  }\n\n}\n"
        },
        "model": {
            "ball.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.ball.obj"
            },
            "robot_3.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.robot_3.obj"
            },
            "robot_2.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.robot_2.obj"
            },
            "robot_1.obj": {
                "uri": "https://s3-us-west-1.amazonaws.com/test.pixelpad.io/eplusbase.obj"
            },
            "flagpole.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.flagpole.obj"
            }
        },
        "texture": {
            "GameBoard_LevelTwo.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.GameBoard_LevelTwo.png"
            },
            "MaroonTexture.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.MaroonTexture.png"
            },
            "YellowTexture.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.YellowTexture.png"
            },
            "robot.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.robot.png"
            },
            "gridTile.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210760.gridTile.png"
            },
            "asphaltTile.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.asphaltTile.jpg"
            },
            "asphaltNormal.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.asphaltNormal.jpg"
            },
            "bricks_texture.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.bricks_texture.jpg"
            },
            "bricks_normal.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.bricks_normal.jpg"
            },
            "FirstRobotics.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.FirstRobotics.png"
            },
            "YouWinPopup.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.YouWinPopup.png"
            },
            "ContinueButton.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.ContinueButton.png"
            },
            "FirstRoboticsCanada.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.FirstRoboticsCanada.jpg"
            },
            "FirstCanada_Logo_Border.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.FirstCanada_Logo_Border.jpg"
            },
            "hdrEnv.hdr": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.hdrEnv.hdr"
            },
            "testHdri.hdr": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.testHdri.hdr"
            },
            "rubber_pad.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.rubber_pad.jpg"
            },
            "rubber_board.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.rubber_board.jpg"
            },
            "rubber_board_normal.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.rubber_board_normal.jpg"
            },
            "machineShop.hdr": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.machineShop.hdr"
            }
        },
        "sound": {},
        "library": {},
        "scene": {
            "MainScene.scn": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"MainGame\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-5.393712090331874,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":7979,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"MainGame\"\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"LevelManager\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-5.393712043762207,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":7980,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"LevelManager\"\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Camera\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-5.393712043762207,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":7981,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Camera\"\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}",
            "Level_0.scn": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Floor\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":10,\n                  \"y\":0.2,\n                  \"z\":10\n               },\n               \"uniqueId\":9030,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":false,\n               \"receiveShadows\":true\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":true\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0.5278700590133667,\n                  \"z\":-1.9541322871034261\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":6.688668376711601,\n                  \"y\":1,\n                  \"z\":0.08149530132484559\n               },\n               \"uniqueId\":9038,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"Wall.mat\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":true\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0.5278700590133667,\n                  \"z\":2.178962910932912\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":6.688668376711601,\n                  \"y\":1,\n                  \"z\":0.08149530132484559\n               },\n               \"uniqueId\":9046,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"Wall.mat\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":true\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-3.2984964317658836,\n                  \"y\":0.5278700590133667,\n                  \"z\":0.10124391989436034\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":89.99999999999999,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":4.251978852934279,\n                  \"y\":1,\n                  \"z\":0.08149530132484559\n               },\n               \"uniqueId\":9054,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"Wall.mat\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":true\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"MainGame\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9062,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"MainGame\"\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Camera\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-0.030000000000000325,\n                  \"y\":7.759999999999994,\n                  \"z\":-7.729999999999993\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":90,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":0.9999999679829527,\n                  \"z\":0.9999999679829527\n               },\n               \"uniqueId\":9063,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"FollowCamera\",\n               \"target\":\"\"\n            },\n            {\n               \"t\":\"Camera\"\n            },\n            {\n               \"t\":\"CameraFadeInFadeOut\"\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Light\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":16.862238333821264,\n                  \"y\":46.490000009536764,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":3.989999999998979,\n                  \"y\":-5.080000000000061,\n                  \"z\":-8.369241323378613e-15\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9065,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Light\",\n               \"intensity\":0.7\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"robot_1 (Clone)\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":3,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9068,\n               \"ser_children\":[\n                  null\n               ]\n            }\n         ],\n         \"prefabName\":\"robot_1.prefab\"\n      }\n   ]\n}"
        },
        "material": {
            "Wall.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"bricks_texture.jpg\",\"normalTexture\":\"bricks_normal.jpg\"}"
        },
        "prefab": {
            "Wall.prefab": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"WallBase\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":0.1\n               },\n               \"uniqueId\":8480,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"Wall.mat\",\n               \"scale\":1\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}",
            "robot_1.prefab": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Robot\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0.02,\n                  \"y\":0.02,\n                  \"z\":0.02\n               },\n               \"uniqueId\":315863,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"robot_1\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":false,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"Robot\"\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":30,\n                  \"y\":20,\n                  \"z\":45\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":10,\n                  \"z\":6.160000000000006\n               }\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}"
        }
    }
}