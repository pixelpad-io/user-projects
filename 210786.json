{\"assets\":{\"code\":{\"main\":\" ENABLE_EDITOR = true;\\n\\n@RegisterAsComponent\\nclass MainGame extends MonoBehaviour {\\n\\n  public static instance : MainGame;\\n  public static level: Level_CrossNumbers;\\n\\n  public nRobotsCreated = 0;\\n\\n  isRunning : boolean = false;\\n\\n  finished : boolean = false;\\n\\n  levelIndex : number = 0;\\n  playButton : PlayButton;\\n  resetTimer : number = 0;\\n\\n  winScreen: CustomImage;\\n\\n  Start() {\\n    \\n    MainGame.instance = this;\\n    \\n    this.resetTimer = 60;\\n    // MainGame.level = Instantiate(Level_CrossNumbers);    \\n    \\n    // Instantiate(FPSCounterGUI);\\n    //This makes the engine runs 10 times as fast.\\n    //Great way to check memory leaks\\n    // Engine.nFramesPerRenderLoop = 10;\\n    //Remove slash if it\'s in there\\n    var phpQuery = GetPHPVariable(\\\"l\\\");\\n    var phpVar = phpQuery === undefined ? undefined : phpQuery.split(\'/\')[0]; \\n    this.levelIndex = phpVar === undefined ? 0 : +phpVar; \\n    var isChallenge = GetIsChallenge();\\n    \\n    //Instantiate(CameraFadeInFadeOut);\\n  return\\n    MainGame.level = Instantiate(Level_CrossNumbers);\\n    \\n    if(isChallenge){\\n      let scriptArea = document.getElementById(\\\"script-area\\\"); \\n      if (scriptArea) \\n      {\\n        \\n        let obj = ConvertJsonCode(scriptArea.innerText)\\n        Object.keys(obj).forEach(robotName =>{\\n          let robot = MainGame.level.CreateRobot();\\n          \\n          robot.robotName = robotName\\n          robot.imgUrl = obj[robotName].flag\\n        })\\n        \\n      } \\n      MainGame.level.CreateMaze3()\\n      Instantiate(HDREnvironment);\\n      return;\\n    }\\n    Instantiate(HDREnvironment);\\n\\n    switch (this.levelIndex)\\n    {\\n      case 0:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze1_1() \\n      break;\\n      case 1:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze1_2()\\n      break;\\n      case 2:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze1_3()\\n      break;\\n      case 3:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze1()\\n      break;\\n      case 4:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze2()\\n      break;\\n      case 5:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze3() \\n      break;\\n      case 6:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze4()\\n      break;\\n      case 7:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze5()\\n      break;\\n      case 8:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreatePlayground()\\n      break;\\n      case 9:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreatePlayground()\\n      default:\\n          MainGame.level.CreateRobot()\\n          MainGame.level.CreateMaze6()\\n      break;\\n    }\\n    this.InitWinScreen();\\n\\n  \\n      \\n  } \\n\\n  Update()\\n  {\\n    return\\n    if (CameraFadeInFadeOut.instance.isLightUp && !this.playButton)   \\n    {\\n      this.playButton = Instantiate(PlayButton);\\n    }\\n\\n    //We reset the scene after a while, since memory leaks slow down the game if it\'s been on for too long\\n    if (!this.isRunning)\\n    {\\n      //Disabled the resetTime, since the memory leak seems to be fixed.\\n      //this.resetTimer -= Time.deltaTime;\\n      if (this.resetTimer <= 0)\\n      {\\n        SceneManager.ReloadCurrentScene();\\n      }\\n    }\\n  }\\n\\n  public InitWinScreen(){\\n      this.winScreen =  Instantiate(CustomImage).Init(\\\"YouWinPopup.png\\\", 185, 212);\\n      this.winScreen.RemoveFromControl();\\n  }\\n\\n  public OnVictory ()\\n  {\\n    if (this.finished)\\n    {\\n      return;\\n    }\\n\\n    this.finished = true;\\n    // Instantiate(CustomImage).Init(\\\"YouWinPopup.png\\\", 185, 212);\\n    this.winScreen.AddToControl();\\n    var url = Engine.getUrl() + Engine.getFullName(\\\"ContinueButton.png\\\", FileType.Texture);\\n    var continueButton = BABYLON.GUI.Button.CreateImageOnlyButton(\\\"ContinueButton\\\",url);\\n    continueButton.widthInPixels = 48;\\n    continueButton.heightInPixels = 48;\\n    continueButton.topInPixels = 60;\\n    continueButton.onPointerClickObservable.add( e => {    \\n      \\n      var baseUrl = window.location.href.split(\'?\')[0];\\n      //If it\'s the Test Project....\\n      if (baseUrl.includes(\\\"ohvmotqqgzv\\\"))\\n      {\\n        Debug.Log(\\\"This would get you to the next level!\\\");\\n      }else{\\n        window.location.href = baseUrl + \\\"?l=\\\" + ++this.levelIndex;\\n      }\\n    });\\n    Canvas.main.addControl(continueButton);\\n  }\\n\\n}\\n\\nasync function runRobotCode ()\\n{\\n  let scriptArea = document.getElementById(\\\"script-area\\\"); \\n  if (scriptArea) \\n  {\\n    if(GetIsChallenge()){\\n      let obj = ConvertJsonCode(scriptArea.innerText)\\n      Object.keys(obj).forEach(key=>{\\n        let code = obj[key].code;\\n        let index = code.indexOf(\\\"runOpMode\\\")\\n        code = code.slice(0, index + 9) + \'_\' + key + code.slice(index + 9)\\n        eval(code)\\n        eval(\'(async () => {await runOpMode_\' + key + \'(GetRobot(\\\"\'+ key + \'\\\"));})();\'); \\n\\n      })\\n    }else{\\n      eval(\'(async () => {await runOpMode(GetRobot());})();\' + scriptArea.innerText);\\n    }\\n  } \\n  else\\n  {\\n    await runOpModeDebug();\\n  }  \\n}\\n\\n\\n// The \'//BLOCKLY_REPLACE\' will be replaced with an empty string\\n// This auto comments the testing code below, and places in the blockly code\\n// This way you don\'t have to remove your testing code every time you save to live.\\n\\n//DO NOT REMOVE THIS COMMENT BELOW\\n//BLOCKLY_REPLACE//*\\n\\n\\n//All code below is for testing only and will be auto-commented when in the live engine\\n//Note: Don\'t use multiline commenting in the testing code since this will break the system\\n\\nfunction GetRobot(name: string = \\\"testRobot\\\"){\\n  let robotList : RobotMoveList = new RobotMoveList();\\n  \\n  robotList.robot = MainGame.level.GetOneRobot(name)\\n\\n  return robotList\\n}\\n\\nvar x;\\n\\n// Describe this function...\\nasync function ChangeModeToPosition(robot) {\\n  await robot.SetMode(MotorModeEnum.RUN_TO_POSITION, \\\"motorLeft\\\");\\n  await robot.SetMode(MotorModeEnum.RUN_TO_POSITION, \\\"motorRight\\\");\\n}\\n\\n// Describe this function...\\nasync function StopMotor(robot) {\\n  await robot.SetPower(0, \\\"motorLeft\\\");\\n  await robot.SetPower(0, \\\"motorRight\\\");\\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \\\"motorLeft\\\");\\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \\\"motorRight\\\");\\n  await robot.SetTargetPosition(0, \\\"motorLeft\\\");\\n  await robot.SetTargetPosition(0, \\\"motorRight\\\");\\n}\\n\\n// Describe this function...\\nasync function ChangeModeToPower(robot) {\\n  await robot.SetMode(MotorModeEnum.RUN_USING_ENCODER, \\\"motorLeft\\\");\\n  await robot.SetMode(MotorModeEnum.RUN_USING_ENCODER, \\\"motorRight\\\");\\n}\\n\\n// Describe this function...\\nasync function ChangeDirection(robot) {\\n  await robot.SetDirection(MotorDirectionEnum.REVERSE,\\\"motorLeft\\\");\\n  await robot.SetDirection(MotorDirectionEnum.REVERSE,\\\"motorRight\\\");\\n}\\n\\n// Describe this function...\\nasync function CheckStop(robot) {\\n  while (await OpModeIsActive(robot)) {\\n    if (!await robot.IsBusy(\\\"motorLeft\\\") && !await robot.IsBusy(\\\"motorRight\\\")) {\\n      break;\\n    }\\n  }\\n}\\n\\n// Describe this function...\\nasync function TestTargetPosition(robot, x) {\\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \\\"motorLeft\\\");\\n  await robot.SetMode(MotorModeEnum.STOP_AND_RESET_ENCODER, \\\"motorRight\\\");\\n  await robot.SetTargetPosition((-1 * x), \\\"motorLeft\\\");\\n  await robot.SetTargetPosition(x, \\\"motorRight\\\");\\n}\\n\\n// Describe this function...\\nasync function TestSetPower(robot, x) {\\n  await robot.SetPower(x, \\\"motorLeft\\\");\\n  await robot.SetPower((-1 * x), \\\"motorRight\\\");\\n}\\n\\n\\nasync function\\t runOpModeDebug(robot: RobotMoveList = GetRobot()) {\\n  Debug.Log(\\\"start\\\")\\n  // while (await OpModeIsActive(robot)) {\\n    await ChangeModeToPosition(robot);\\n    await robot.SetTargetPosition(2000, \\\"motorLeft\\\")\\n   \\n  // }\\n}\\n\\n\\n\\n\\n/* End Testing Code */\\n\\n\",\"Consts\":\"//511 = bitmask of 111111111 = up to 9 robots.\\nconst ROBOT_LAYER_MASK = 511;\\n\",\"DefaultObjects\":\"class DefaultObjectMaterialTexture extends MonoBehaviour {\\n  Setup(texture: string) {\\n    var mat = new BABYLON.StandardMaterial(\\\"Mat\\\", Engine.scene);\\n    mat.diffuseTexture = TextureSystem.GetSprite(texture);\\n\\n    mat.diffuseTexture.hasAlpha = true;\\n    mat.emissiveTexture = mat.diffuseTexture;\\n    mat.backFaceCulling = true;\\n\\n    this.renderer.GetMesh().material = mat;\\n    this.gameObject.AddComponent(BoxCollider);\\n    this.transform.eulerAngles.x = 90;\\n  }\\n}\\n\\nclass DefaultObjectMaterialColor extends MonoBehaviour {\\n  Setup(red: number, green: number, blue: number, alpha: number) {\\n    var mat = new BABYLON.StandardMaterial(red.toString() + \\\".\\\" + green.toString() + \\\".\\\" + blue.toString(), Engine.scene);\\n    mat.diffuseColor = new BABYLON.Color3(red, green, blue);\\n    mat.roughness = 0.2\\n    mat.alpha = alpha;\\n    this.renderer.GetMesh().material = mat;\\n  }\\n}\\n\\nclass PickableObject extends DefaultObjectMaterialColor {\\n  public isPickedUp: boolean = false;\\n\\n  Update() {\\n    if (this.isPickedUp == true) {\\n      // this.transform.position.x = MainGame.level.robot.transform.position.x;\\n      // this.transform.position.y = 3;\\n      // this.transform.position.z = MainGame.level.robot.transform.position.z;\\n    }\\n  }\\n}\\n\\n// TODO: Rework the Pickup Object\\nclass PickupBox extends PickableObject {\\n  public velocityY: number = 0;\\n\\n  Awake() {\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\\\"Box\\\", {}));\\n    super.Setup(1, 0, 1, 1);\\n    this.transform.scale = new Vector3(0.5, 0.5, 0.5);\\n    this.gameObject.AddComponent(BoxCollider);\\n    this.gameObject.AddComponent(Rigidbody).isKinematic = true;\\n  }\\n\\n}\\n\\nclass UltraSoundBox extends DefaultObjectMaterialColor {\\n\\n  Awake() {\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\\\"Box\\\", {}));\\n    super.Setup(0, 0.5, 1, 1);\\n    this.gameObject.AddComponent(BoxCollider).isTrigger = true;\\n    this.transform.scale = new Vector3(2, 1, 1);\\n  }\\n\\n  OnTriggerEnter(otherCollider: Collider) {\\n    if (otherCollider.GetComponent(PickableObject) != null) {\\n      return true;\\n    }\\n  }\\n}\\n\\nclass CustomImage extends MonoBehaviour\\n{\\n  image : BABYLON.GUI.Image;\\n\\n  public Init(name : string, width : number, height : number) : CustomImage\\n  {\\n    var url = Engine.getUrl() + Engine.getFullName(name, FileType.Texture);\\n    this.image = new BABYLON.GUI.Image(\\\"\\\", url);\\n    this.image.widthInPixels = width;\\n    this.image.heightInPixels = height;\\n    Canvas.main.addControl(this.image);\\n    return this;\\n  }\\n\\n  public RemoveFromControl(){\\n    Canvas.main.removeControl(this.image);\\n  }\\n\\n  public AddToControl(){\\n    Canvas.main.addControl(this.image);\\n  }\\n\\n  OnDestroy ()\\n  {\\n    this.image?.dispose();\\n  }\\n}\",\"ColorBox\":\"class ColorBox extends MonoBehaviour {\\n\\n  public color: BABYLON.Color3;\\n\\n  Awake(){\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\\\"ColorTag\\\", { size: 1, height: 1}))\\n    this.gameObject.AddComponent(BoxCollider);\\n    this.gameObject.AddComponent(Rigidbody);\\n    // this.gameObject.AddComponent(Rigidbody);\\n    // this.GetComponent(Rigidbody).isKinematic = true;\\n  }\\n\\n  public SetColor(color: BABYLON.Color3){\\n    this.color = color;\\n    var material = new BABYLON.StandardMaterial(\\\"mat\\\",Engine.scene)\\n    material.diffuseColor = this.color;\\n    material.roughness = 0.1\\n    this.renderer.GetMesh().material = material;\\n  }\\n\\n  public GetColor(){\\n    return this.color;\\n  }  \\n}\\n\",\"ColorTag\":\"class ColorTag extends MonoBehaviour {\\n  public color: BABYLON.Color3;\\n\\n  Awake(){\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\\\"ColorTag\\\", { size: 1, height: 1}))\\n    this.transform.scale.y = 0.1;\\n    this.gameObject.AddComponent(BoxCollider).isTrigger = true;\\n    this.renderer.GetMesh().receiveShadows = true\\n\\n  }\\n\\n  public SetColor(color: BABYLON.Color3){\\n    this.color = color;\\n    var material = new BABYLON.StandardMaterial(\\\"mat\\\",Engine.scene)\\n    material.diffuseColor = this.color;\\n    this.renderer.GetMesh().material = material;\\n  }\\n\\n  public GetColor(){\\n    return this.color;\\n  }\\n\\n  public SetSize(x: number, y: number){\\n    this.transform.scale.x = x\\n    this.transform.scale.z = y\\n  }\\n\\n  OnTriggerEnter(col: Collider){\\n    if(col.GetComponent(Robot) != null){\\n      col.GetComponent(Robot).TriggerColorSensorEvent(this.color);\\n    }\\n  }\\n\\n  OnTriggerExit(col: Collider){\\n    if(col.GetComponent(Robot) != null){\\n      col.GetComponent(Robot).TriggerColorSensorEvent(new BABYLON.Color3(1,1,1));\\n    }\\n  }\\n\\n  \\n}\\n\",\"RobotSensor\":\"class RobotSensor {\\n  private sensorPosition: Vector3;\\n  private robot: Robot;\\n  public enabled: boolean = true;\\n  public name: string;\\n\\n  constructor(name: string, robot: Robot){\\n    this.name = name;\\n    this.robot = robot;\\n  }\\n  // public AttachTo(robot: Robot, pos: Vector3 = new Vector3(0,1,0)){\\n  //   this.sensorPosition = pos;\\n  //   this.robot = robot;\\n  // }\\n\\n}\\n\",\"RobotMotor\":\"class RobotMotor {\\n  private direction: MotorDirectionEnum;\\n  private name: string;\\n  private mode: MotorModeEnum;\\n  public enabled: boolean = true;\\n  // Use only in RUNT_USING_ENCODER mode\\n  private power: number;\\n  // Use only in TO_POSITION mode\\n  private tickPosition: number;\\n  private tickDestination: number;\\n  // Use Modern robotics encoder as the reference (vid24 at 2.39)\\n  private tickPerRev: number = 1440;\\n\\n  \\n  \\n\\n  constructor(name: string, direction: MotorDirectionEnum = MotorDirectionEnum.FORWARD, \\n    power: number = 0, mode: MotorModeEnum = MotorModeEnum.RUN_USING_ENCODER) {\\n    this.name = name;\\n    this.direction = direction;\\n    this.power = power;\\n    this.tickPosition = 0;\\n    this.tickDestination = 0;\\n  }\\n\\n  public SetPower(power: number){\\n    this.power = power;\\n  }\\n\\n  public GetPower(){\\n    return this.power;\\n  }\\n\\n  public SetDirection(direction: MotorDirectionEnum){\\n    this.direction = direction;\\n  }\\n\\n  public GetDirection(){\\n    return this.direction;\\n  }\\n\\n  public SetName(name: string){\\n    this.name = name;\\n  }\\n\\n  public GetName(){\\n    return this.name;\\n  }\\n\\n  public ResetEncoder(){\\n    this.tickPosition = 0;\\n  }\\n\\n  public SetMode(mode: MotorModeEnum){\\n    if(mode == MotorModeEnum.STOP_AND_RESET_ENCODER){\\n      this.tickPosition = 0;\\n      return;\\n    }\\n    this.mode = mode;\\n  }\\n\\n  public GetMode(){\\n    return this.mode;\\n  }\\n\\n  public AddTickPosition(tick: number = 1){\\n    this.tickPosition += tick;\\n  }\\n\\n  public GetTickPosition(){\\n    return this.tickPosition;\\n  }\\n\\n  public SetTickDestination(tickDestination: number){\\n    this.tickDestination = tickDestination;\\n  }\\n\\n  public GetTickDestination(){\\n    return this.tickDestination;\\n  }\\n\\n  public IsWorking(): boolean {\\n    if(this.mode == MotorModeEnum.RUN_TO_POSITION){\\n      // return true meaning when tickPosition != tickDestination,\\n      // meaning motor is working\\n      return !(this.tickPosition == this.tickDestination);\\n    }else{\\n      // return true when the power is not equal 0, meaning motor is \\n      // working\\n      return this.power !== 0;\\n    }\\n  }\\n}\\n\\nenum MotorDirectionEnum{\\n  FORWARD,\\n  REVERSE\\n}\\n\\nenum MotorModeEnum{\\n  RUN_USING_ENCODER,\\n  RUN_TO_POSITION,\\n  STOP_AND_RESET_ENCODER \\n}\",\"RobotServo\":\"class RobotServo {\\n  private name: string;\\n  private position: number;\\n  private target: number;\\n  private direction: MotorDirectionEnum;\\n  public enabled: boolean = true;\\n  // the speed of changing position\\n  speed: number = 0.01;\\n\\n  constructor(name: string, position: number = 0, target: number = 0, direction: MotorDirectionEnum = MotorDirectionEnum.FORWARD){\\n    this.name = name;\\n    this.position = position;\\n    this.target = target;\\n    this.direction = direction;\\n  }\\n\\n  public SetName(name: string){\\n    this.name = name;\\n  }\\n\\n  public GetName(){\\n    return this.name;\\n  }\\n\\n  public SetPosition(position: number){\\n    this.position = position;\\n  }\\n\\n  public GetPosition(){\\n    return this.position;\\n  }\\n\\n  public SetTarget(target: number){\\n    this.target = target;\\n  }\\n\\n  public GetTarget(){\\n    return this.target;\\n  }\\n\\n  public SetDirection(direction: MotorDirectionEnum){\\n    this.direction = direction\\n  }\\n\\n  public GetDirection(){\\n    return this.direction;\\n  }\\n\\n  public AddPosition(pos: number){\\n    this.position += pos;\\n  }\\n  // Use to calculate the final eulerangles\\n  public GetRotation(){\\n    return this.position * 180;\\n  }\\n}\\n\",\"RobotTouchSensor\":\"class RobotTouchSensor extends RobotSensor{\\n  private isPressed: boolean;\\n\\n  // TODO: Implement functions for the touchSensor\\n}\\n\",\"RobotColorDistanceSensor\":\"class RobotColorDistanceSensor extends RobotSensor{\\n  private reflectionValue: number;\\n  private distance: number = 500;\\n\\n  public GetLightDetected(){\\n    if(!this.enabled)\\n      return 0;\\n    return this.reflectionValue;\\n  }\\n\\n  public GetDistance(){\\n    return this.distance;\\n  }\\n\\n  public SetDistance(distance: number){\\n    if(distance > 0){\\n      this.distance = distance;\\n    }else{\\n      this.distance = 500;\\n    }\\n\\n  }\\n\\n}\\n\",\"RobotColorSensor\":\"class RobotColorSensor extends RobotSensor{\\n  private color: BABYLON.Color3 = new BABYLON.Color3(1,1,1);\\n  \\n  public GetColor(){\\n    if(!this.enabled){\\n      return new BABYLON.Color3(0,0,0);\\n    }\\n    return this.color;\\n    \\n  }\\n\\n  public SetColor(color: BABYLON.Color3){\\n    if(this.enabled){\\n      this.color = color\\n    }\\n  }\\n\\n\\n}\\n\",\"Utility\":\"class Utility {\\n  public static CalculateMotorMovement(motor: RobotMotor){\\n    if(!motor.enabled){\\n      return {direction: 0, rotation: 0};\\n    }\\n    // create result object to return \\n    let pow = Math.abs(motor.GetPower()) >= 1 ? Math.sign(motor.GetPower()) : motor.GetPower();\\n    const result = {\\n      direction: 0.03 * pow,\\n      rotation: 1 * pow\\n      };\\n    // if running in RUN_TO_POSITION mode, tickPosition is required\\n    \\n    if(motor.GetMode() == MotorModeEnum.RUN_TO_POSITION){\\n      result.direction = 0.02;\\n      result.rotation = 1;\\n      // move forward if the tick position hasn\'t reached the tick destination yet\\n      // (keep the same direction and rotation as the same)\\n      if(motor.GetTickPosition() < motor.GetTickDestination()){\\n        motor.AddTickPosition();\\n      // move backward if the tick position goes over the destination\\n      } else if(motor.GetTickPosition() > motor.GetTickDestination()){\\n        motor.AddTickPosition(-1);\\n        result.direction *= -1;\\n        result.rotation *= -1;\\n      // stop if the motor tick is at the tick destination\\n      } else{\\n        result.direction = 0;\\n        result.rotation = 0\\n      }\\n    }\\n    // reverse both direction and rotation if the motor is in reverse mode\\n    if(motor.GetDirection() == MotorDirectionEnum.REVERSE){\\n      result.direction *= -1;\\n      result.rotation *= -1;\\n    }\\n    // if the motor is left side, reverse the direction & rotation\\n    if(motor.GetName().toLowerCase().includes(\\\"left\\\")){\\n       result.direction *= -1;\\n    }\\n    // Debug.Log(\\\"result = \\\" + result.direction)\\n    if(motor.GetMode()==MotorModeEnum.RUN_TO_POSITION){\\n      result.rotation = result.rotation;\\n    }\\n    \\n    return result;\\n  }\\n\\n  public static GetServoRotation(servo: RobotServo){\\n    if(servo.enabled){\\n      return servo.GetRotation();\\n    }\\n    if(servo.GetPosition() < servo.GetTarget()){\\n      servo.AddPosition(servo.speed);\\n    }else if(servo.GetPosition() > servo.GetTarget()){\\n      servo.AddPosition(-servo.speed);\\n    }\\n    return servo.GetRotation();\\n  }\\n\\n  public static CompareColor(col1: BABYLON.Color3, col2: BABYLON.Color3): boolean{\\n    return col1.r == col2.r && col1.g == col2.g && col1.b == col2.b;\\n  }\\n\\n   public static ConvertRgbToHsv(r: number, g: number, b: number): BABYLON.Color3 {\\n    var targetColorHSV = new BABYLON.Color3(r, g, b);\\n    targetColorHSV = targetColorHSV.toHSV();\\n    return targetColorHSV;\\n  }\\n\\n  public static GetAngle(pos1: Vector3, pos2: Vector3){\\n    let deltaX = pos2.x - pos1.x;\\n    let deltaZ = pos2.z - pos1.z;\\n    let theta = -Math.atan2(deltaZ, deltaX) * Mathf.Rad2Deg;\\n    return theta;\\n  }\\n\\n  public static GetDistance(pos1: Vector3, pos2: Vector3){\\n    let deltaX = pos2.x - pos1.x;\\n    let deltaZ = pos2.z - pos1.z;\\n    let distance = Math.sqrt(Math.abs(Math.pow(deltaX, 2) + Math.pow(deltaZ, 2)));\\n    //Multiplied by 10 to be centimeters\\n    return distance * 10;\\n  }\\n\\n  public static GetEulerAngleFromTwoVectors(pos1: Vector3, pos2: Vector3){\\n    let result = new Vector3(0,0,0);\\n    let dif = new Vector3(pos2.x - pos1.x, pos2.y - pos1.y, pos2.z - pos1.z);\\n    result.x = Math.atan2(dif.z, dif.x) * Mathf.Rad2Deg;\\n    result.y = Math.atan2(dif.y, Math.sqrt(Math.pow(dif.z, 2) + Math.pow(dif.x, 2))) * Mathf.Rad2Deg;\\n    return result;\\n  }\\n\\n}\",\"Robot\":\"class Robot extends MonoBehaviour {\\n\\n  public static main: Robot;\\n\\n  private velocityX: number = 0;\\n  private velocityZ: number = 0;\\n  public holdingItem: boolean = false;\\n  public motorLeft: RobotMotor = new RobotMotor(\\\"motorLeft\\\");\\n  public motorRight: RobotMotor = new RobotMotor(\\\"motorRight\\\");\\n  public colorSensor: RobotColorSensor = new RobotColorSensor(\\\"sensorColor\\\", this)\\n  public distanceSensor: RobotColorDistanceSensor = new RobotColorDistanceSensor(\\\"distanceSensor\\\", this)\\n  public isDrawing: boolean = true;\\n  public positions: Array<BABYLON.Vector3> = new Array();\\n  public lastPos: Vector3 = new Vector3(0, 0, 0);\\n  public velocity: Vector3 = new Vector3(0, 0, 0);\\n  public imgUrl: string;\\n  private txtName: BABYLON.GUI.Button3D;\\n  public robotName: string = \\\"testRobot\\\"\\n\\n  private frontWheels: Array<BABYLON.Mesh> = new Array();\\n\\n  private outterFrontWheelMeshName: string = \\\"Wheel_Mr._Grabby_v4.008\\\";\\n  private innerFrontWheelMeshName: string = \\\"Wheel.001_Mr._Grabby_v4.003\\\"; \\n\\n  // Robot looks\\n  public robotColor: BABYLON.Color3;\\n\\n  public robotGUI: RobotGUI;\\n  \\n\\n  // All components of the robot\\n  // Use arrays because we might have more than 2 motors in the future\\n  public robotMotors: Array<RobotMotor> = new Array();\\n  public robotColorSensors: Array<RobotColorSensor> = new Array();\\n  public robotServos: Array<RobotServo> = new Array();\\n  public robotTouchSensors: Array<RobotTouchSensor> = new Array();\\n  public robotColorDistanceSensors: Array<RobotColorDistanceSensor> = new Array();\\n\\n  // Raycast variable\\n  public bOrigin: BABYLON.Vector3 = new BABYLON.Vector3\\n  public downDirection: BABYLON.Vector3 = new BABYLON.Vector3(0,-1,0)\\n  public forwardDirection: BABYLON.Vector3\\n\\n  lines: BABYLON.LinesMesh;\\n\\n  private m : BABYLON.Mesh;\\n  private modelName : string;\\n\\n\\n  Awake() {\\n    Robot.main = this;\\n    this.InitializeRobot();\\n  }\\n\\n  Start()\\n  {\\n\\n    MainGame.instance.nRobotsCreated++;\\n    //Robot layers are 2,4,8,16 etc.\\n    var layer = Math.pow(2, MainGame.instance.nRobotsCreated);\\n    Debug.Log(\\\"Robot layer: \\\" + layer);\\n    this.GetComponent(Collider).layer = layer;\\n\\n    if(GetIsChallenge())\\n    {\\n      this.robotGUI = Instantiate(RobotGUI)\\n      this.robotGUI.robot = this;\\n    }\\n  }\\n\\n  /**Dont use anymore (use to manually load the mesh) */\\n  SetRobotMesh(meshName: string){\\n      this.renderer.LoadMesh(meshName, 0.034, null, false);\\n      Debug.Log(meshName);\\n      this.modelName = meshName;\\n      if(meshName == \\\"robot_1.obj\\\"){ \\n        this.GetComponent(BoxCollider).size = new Vector3(1.25, 1, 2);\\n      }\\n      if(meshName == \\\"robot_2.obj\\\"){\\n        this.GetComponent(BoxCollider).size = new Vector3(1.4, 0.1, 2.2);\\n        this.GetComponent(BoxCollider).center = new Vector3(0, -1, 0);\\n      }\\n      if(meshName == \\\"robot_3.obj\\\"){\\n        this.GetComponent(BoxCollider).size = new Vector3(1.4, 1, 2);\\n        this.GetComponent(BoxCollider).center = new Vector3(0, 0.5, 0);\\n      }\\n  }\\n\\n  SetRobotColor(r: number, g:number, b:number){\\n    this.robotColor = new BABYLON.Color3(r,g,b);\\n  }\\n\\n  SerRobotWheels(){\\n    this.renderer.GetMeshes().forEach((e,i) => {\\n      if(e.id.includes(this.outterFrontWheelMeshName) || e.id.includes(this.innerFrontWheelMeshName)){\\n        this.frontWheels.push(e);\\n      }\\n    })\\n    Debug.Log(`This robot has ${this.frontWheels.length} wheels`)\\n  }\\n\\n  Update() {\\n    \\n    //TEMP FIX to avoid shadows freaking out after the robot falls off the cliff\\n    if (this.transform.position.y <= -15)\\n    {\\n      this.GetComponent(Rigidbody).isKinematic = true;\\n      return;\\n    }\\n\\n    this.EngineMovement();\\n    this.EngineSensor();\\n     //This only happens once, when the mesh is loaded\\n    if (!this.m )\\n    {\\n      this.m = this.renderer.GetMesh();   \\n      if (this.m)\\n      {\\n        ColorRobot.SetColor(\\\"robot_1.obj\\\", this);\\n        this.SerRobotWheels();\\n      }\\n      \\n    }\\n\\n  }\\n\\n  InitializeRobot(){\\n    this.positions.push(new BABYLON.Vector3(this.transform.position.x,\\n    this.transform.position.y + 0.15,\\n    this.transform.position.z));\\n    this.robotMotors.push(this.motorLeft);\\n    this.robotMotors.push(this.motorRight);\\n    this.GetComponent(Rigidbody).friction = 0            \\n    this.GetComponent(Rigidbody).useGravity = true;    \\n  }\\n\\n// Handle all the motors and servos\\n  EngineMovement() { \\n    this.MotorMovement();\\n    this.ServoMovement();\\n  }\\n\\n  // Handle all the sensors\\n  EngineSensor(){\\n    // this.DetectColor();\\n    this.DetectDistance();\\n  }\\n\\n  DetectColor(){\\n    Vector3.VtoB(this.transform.position, this.bOrigin)\\n    let dir = this.downDirection.subtract(this.bOrigin)\\n    dir = BABYLON.Vector3.Normalize(dir);\\n    let ray = new BABYLON.Ray(this.bOrigin, dir, 2);\\n    let hit = Engine.scene.pickWithRay(ray)\\n    if(hit.pickedMesh){\\n          // Debug.Log(\\\"Debug = \\\" + hit.pickedMesh)\\n      let obj = Engine.meshToObject[hit.pickedMesh.uniqueId]\\n      if(obj){\\n        if(obj.GetComponent(ColorTag)){\\n          let colTag = obj.GetComponent(ColorTag)\\n          if(!Utility.CompareColor(colTag.GetColor(),this.colorSensor.GetColor())){\\n            let col = new BABYLON.Color3(colTag.GetColor().r,colTag.GetColor().g,colTag.GetColor().b)\\n            this.colorSensor.SetColor(new BABYLON.Color3(\\n              col.r,col.g,col.b)\\n              );\\n          }\\n        }else{\\n          this.colorSensor.SetColor(new BABYLON.Color3(1,1,1));\\n        }\\n      }\\n      \\n    }\\n\\n  }\\n\\n  DetectDistance(){\\n    if(this.renderer.GetMesh()){\\n      Vector3.VtoB(this.transform.position, this.bOrigin)\\n     this.forwardDirection = this.renderer.GetMesh().getDirection(new BABYLON.Vector3(0,0,1))\\n     this.forwardDirection.normalize()\\n     let ray = new BABYLON.Ray(this.bOrigin, this.forwardDirection, 100);\\n      let hit = Engine.scene.pickWithRay(ray)\\n      this.distanceSensor.SetDistance(hit.distance);\\n    }\\n     \\n    \\n  }\\n\\n  MotorMovement(){\\n    const motorLeftMove = Utility.CalculateMotorMovement(this.motorLeft)\\n    const motorRightMove = Utility.CalculateMotorMovement(this.motorRight)\\n    const rotationPower =  motorLeftMove.rotation + motorRightMove.rotation\\n    this.transform.localEulerAngles.y -= rotationPower;\\n    let wheelRotation = 0;\\n    let axis = new BABYLON.Vector3(1, 1, 1);\\n    let angle = 0;\\n    let quaternion = BABYLON.Quaternion.RotationAxis(axis, angle);\\n\\n    if(rotationPower > 0){\\n      angle = Math.PI / 8;\\n    }else if(rotationPower < 0){\\n      angle = -Math.PI / 8;\\n    }\\n    if(this.frontWheels){\\n      this.frontWheels.forEach(e=>{\\n      e.rotationQuaternion = quaternion;\\n    })\\n    }\\n    \\n    let movingSpeed = motorLeftMove.direction + motorRightMove.direction;\\n    \\n    let movingAngle = Math.floor(this.transform.localEulerAngles.y);\\n    let maxSpeed = 30;\\n    this.gameObject.GetComponent(Rigidbody).angularVelocity = new Vector3(0,0,0);\\n    //this.transform.transformNode.translate(BABYLON.Axis.Z, motorLeftMove.direction + motorRightMove.direction);\\n    let vel = this.gameObject.GetComponent(Rigidbody).velocity.clone();\\n    vel.x = Math.sin(movingAngle * Mathf.Deg2Rad) * movingSpeed * maxSpeed;\\n    vel.z = Math.cos(movingAngle * Mathf.Deg2Rad) * movingSpeed * maxSpeed;\\n    \\n    this.gameObject.GetComponent(Rigidbody).velocity = vel;\\n\\n    this.transform.localEulerAngles.x = 0;\\n    this.transform.localEulerAngles.z = 0;\\n\\n    // this.ManageGravity();\\n  }\\n\\n  ManageGravity(){\\n    Vector3.VtoB(this.transform.position, this.bOrigin)\\n    let dir = this.downDirection.subtract(this.bOrigin)\\n    dir = BABYLON.Vector3.Normalize(dir);\\n    let ray = new BABYLON.Ray(this.bOrigin, dir, 5);\\n    let hit = Engine.scene.pickWithRay(ray)\\n    if(hit.pickedMesh && hit.pickedMesh.name != this.name){\\n      this.GetComponent(Rigidbody).useGravity = false     \\n    }else{\\n      this.GetComponent(Rigidbody).useGravity = true  \\n    }\\n  }\\n\\n  ServoMovement(){\\n    this.robotServos.forEach(servo=>{\\n      const rot = Utility.GetServoRotation(servo);\\n      // TODO: Do something with the servo by using rot as the rotation (such as robot arms)\\n      \\n    })\\n  }\\n\\n  TouchSensorDetection(){\\n    this.robotTouchSensors.forEach(touchSensor=>{\\n      // TODO: Set the detection function\\n    })\\n  }\\n\\n  // All motor setup functions\\n  SetPowerInternal(power: number, engine: string){\\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\\n    if(motor){\\n      motor.SetPower(power);\\n    }else{\\n      Debug.Log(\\\"motor is not found\\\")\\n    }\\n  }\\n\\n  // To set motor mode by motor name\\n  SetMode(mode: MotorModeEnum, engine: string ){\\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\\n    if(motor){\\n      motor.SetMode(mode);\\n    }\\n  }\\n\\n  TriggerColorSensorEvent(color: BABYLON.Color3){\\n      this.colorSensor.SetColor(color);\\n  }\\n\\n  SetTargetPosition(pos: number, engine: string){\\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\\n    if(motor){\\n      motor.SetTickDestination(pos);\\n    }\\n  }\\n\\n  GetTargetPosition(engine: string){\\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\\n    if(motor){\\n     // Debug.Log(motor.GetTickPosition())\\n      return motor.GetTickPosition()\\n    }\\n    return undefined;\\n  } \\n\\n  SetDirection(direction: MotorDirectionEnum, engine: string){\\n    const motor = this.robotMotors.find(motor=>motor.GetName() === engine)\\n    if(motor){\\n      motor.SetDirection(direction);\\n    }\\n  }  \\n\\n  IsMoving(): boolean{\\n    return this.motorLeft.IsWorking() && this.motorRight.IsWorking();\\n  } \\n\\n  OnTriggerEnter(otherCollider: Collider) {\\n    if (otherCollider.GetComponent(PickableObject) != null) {\\n     // Debug.Log(\\\"GOT HERE\\\")\\n      return true;\\n    }\\n  }\\n\\n  // Helping Function for debuging th\\n  Drawing() {\\n    if (this.isDrawing == true) {\\n\\n      this.lines?.dispose();\\n\\n      this.lines = BABYLON.Mesh.CreateLines(\\\"lines\\\", this.positions, Engine.scene, true);\\n      this.lines.color = new BABYLON.Color3(1, 0, 0);\\n      if ((Math.sqrt((Math.pow(this.positions[this.positions.length - 1].x - this.transform.position.x, 2)) +\\n        (Math.pow(this.positions[this.positions.length - 1].z - this.transform.position.z, 2)))) > 0.2) {\\n        this.positions.push(new BABYLON.Vector3(this.transform.position.x,\\n          0.1,\\n          this.transform.position.z));\\n      }\\n    }\\n\\n    if (Input.GetKeyDown(KeyCode.R)) {\\n      if (this.isDrawing == false) {\\n        this.isDrawing = true;\\n      }\\n\\n      else if (this.isDrawing == true) {\\n        this.isDrawing = false;\\n        this.positions.length = 0;\\n        this.positions.push(new BABYLON.Vector3(this.transform.position.x,\\n          this.transform.position.y + 0.1,\\n          this.transform.position.z));\\n      }\\n    }\\n  }\\n}\\n\\n\\n\",\"RobotGUI\":\"class RobotGUI extends MonoBehaviour {\\n\\n  public robot: Robot;\\n  private button: BABYLON.GUI.Button3D\\n  private imgPlane: BABYLON.Mesh\\n  private initiate: boolean = false;\\n\\n  private manager : BABYLON.GUI.GUI3DManager;\\n\\n  Update(){\\n    // return right away if there is no robot\\n    if(this.robot == null){\\n      return;\\n    }\\n\\n    // create the tags if we never (it\'s here to make sure we have the robot)\\n    if(!this.initiate){\\n      this.InitiateButton ();\\n      this.initiate = true;\\n    }\\n\\n    // move the button along the robot\\n    this.MoveButton();\\n  }\\n\\n  \\n  InitiateButton(){\\n    //We store this as an instance variable so we can dispose of it after!\\n    this.manager = new BABYLON.GUI.GUI3DManager(Engine.scene);\\n    this.button = new BABYLON.GUI.Button3D(\\\"name\\\");\\n    this.manager.addControl(this.button);\\n    this.button.node.rotation = new BABYLON.Vector3(0, 180 * Mathf.Deg2Rad, 0)\\n    this.button.scaling = new BABYLON.Vector3(2,0.5,1);\\n    this.button.mesh.material.alpha = 0.5\\n        \\n    var text1 = new BABYLON.GUI.TextBlock();\\n    text1.text = this.robot.robotName;\\n    text1.color = \\\"white\\\";\\n    text1.alpha = 10\\n    text1.fontSize = 25;\\n    this.button.content = text1; \\n\\n    this.imgPlane = BABYLON.Mesh.CreatePlane(\\\"img\\\", 0.5, Engine.scene);\\n    this.imgPlane.scaling = new BABYLON.Vector3(1,0.7,1)\\n    this.imgPlane.rotation = new BABYLON.Vector3(0, 180 * Mathf.Deg2Rad, 0)\\n    let mat = new BABYLON.StandardMaterial(\\\"flagImg\\\", Engine.scene);\\n    mat.diffuseTexture = new BABYLON.Texture(this.robot.imgUrl, Engine.scene);\\n    this.imgPlane.material = mat;\\n  }\\n\\n   MoveButton(){\\n    let pos: BABYLON.Vector3 = new BABYLON.Vector3(0);\\n    Vector3.VtoB(this.robot.transform.position, pos);\\n    pos.y += 1\\n    if (this.button) {this.button.position = pos.clone()}\\n    pos.y += 0.6\\n    this.imgPlane.position = pos.clone()\\n  }\\n\\n  OnDestroy()\\n  {\\n    this.manager.dispose();\\n    this.imgPlane.dispose();\\n  }\\n}\\n\",\"RobotMoveList\":\"class RobotMoveList extends MonoBehaviour {\\n\\n  current : Move;\\n\\n  robot : Robot;\\n\\n  Start(){\\n    \\n  }\\n\\n  async SetPower (power, engine)\\n  {\\n    return new SetPowerObj(this, power, engine).Run();\\n  }\\n\\n  async Sleep (timeLeft){\\n    return new SleepObj(this, timeLeft).Run();\\n  }\\n\\n  async WaitForStart(){\\n\\n  }\\n\\n  async SetDirection(direction: MotorDirectionEnum, engine: string) {\\n    return new SetDirectionObj(this, direction, engine).Run();\\n  }\\n\\n  async SetMode(mode: MotorModeEnum, engine: string) {\\n    return new SetModeObj(this, mode, engine).Run();\\n  }\\n\\n  async SetTargetPosition(power: number, engine: string) {\\n    return new SetTargetPositionObj(this, power * 0.1, engine).Run();\\n  }\\n\\n  async GetTargetPosition(engine: string) {\\n    return this.robot.GetTargetPosition(engine)\\n  }\\n\\n  async WaitUntilAtPosition() {\\n    return new WaitUntilAtPositionObj(this).Run()\\n  }\\n\\n  async IsBusy(engine: string) {\\n    return new IsBusyObject(this, engine).Run();\\n  }\\n\\n  async WaitUntilGetColor(color: BABYLON.Color3){\\n    return new WaitUntilGetColorObj(this, color).Run();\\n  }\\n\\n  GetColorRed(){\\n    return this.robot.colorSensor.GetColor().r;\\n  }\\n\\n  GetColorGreen(){\\n    return this.robot.colorSensor.GetColor().g;\\n  }\\n\\n  GetColorBlue(){\\n    return this.robot.colorSensor.GetColor().b;\\n  }\\n\\n  GetDistance(){\\n    return this.robot.distanceSensor.GetDistance();\\n  }\\n}\\n\",\"Moves\":\"abstract class Move {\\n  // public static current: Move;\\n\\n  protected moveList : RobotMoveList;\\n\\n\\n  constructor (moveList : RobotMoveList)\\n  {\\n    this.moveList = moveList;\\n  }\\n\\n  // public get robot(): Robot {\\n  //   return Robot.main;\\n  // }\\n\\n  async Run() {\\n    this.moveList.current = this;\\n    return await new Promise(resolve => {\\n      var func = () => {\\n        //I\'m 99% sure this is a memory leak but let\'s just assume it\'s tiny\\n        //Since we can\'t cancel async methods, we have to pause old moves instead\\n        //When we reload the scene, we also set the Move.current to null\\n        if (this.moveList.current == this) {\\n          this.Update();\\n\\n          if (this.IsCompleted()) {\\n            this.OnDestroy();\\n            Engine.scene.onBeforePhysicsObservable.removeCallback(func);\\n            resolve(this.GetReturnValue());\\n          }\\n        }\\n        else {\\n          //Move event listener is removed and the move will never complete\\n          //The move is now destined to wonder our memory forever- never to be accessed. Poor move.\\n          Engine.scene.onBeforePhysicsObservable.removeCallback(func);\\n\\n        }\\n      }\\n      Engine.scene.onBeforePhysicsObservable.add(func);\\n      if (this.DoesRunInstant()) {\\n        func();\\n      }\\n    });\\n  }\\n\\n  DoesRunInstant(): boolean {\\n    return true;\\n  }\\n\\n  OnDestroy(): void {\\n\\n  }\\n\\n  Update(): void {\\n\\n  }\\n\\n  //By default all moves complete instantly.\\n  IsCompleted(): boolean {\\n    return true;\\n  }\\n\\n  GetReturnValue(): any {\\n    return null;\\n  }\\n}\\n\\n\\nclass MovementMove extends Move {\\n  public speed: number = 0.01;\\n  public distance: number;\\n\\n  constructor(moveList: RobotMoveList,distance: number = 1) {\\n    super(moveList);\\n    this.distance = distance;\\n  }\\n\\n  IsCompleted() {\\n    return this.distance <= 0;\\n  }\\n\\n  Update() {\\n\\n    this.distance -= this.speed;\\n  }\\n\\n  OnDestroy() {\\n    this.speed = 0;\\n  }\\n\\n\\n\\n}\\n\\nclass MoveRight extends MovementMove {\\n\\n  Update() {\\n    this.moveList.robot.transform.position.x += this.speed;\\n    super.Update();\\n  }\\n}\\n\\nclass MoveLeft extends MovementMove {\\n\\n  Update() {\\n    this.moveList.robot.transform.position.x -= this.speed;\\n    super.Update();\\n  }\\n}\\n\\nclass MoveForward extends MovementMove {\\n\\n  Update() {\\n    this.moveList.robot.transform.position.z += this.speed;\\n    super.Update();\\n  }\\n}\\n\\nclass MoveBackward extends MovementMove {\\n\\n  Update() {\\n    this.moveList.robot.transform.position.z -= this.speed;\\n    super.Update();\\n  }\\n}\\n\\n\\nclass PickupObj extends Move {\\n\\n  // constructor() {\\n    \\n    // MainGame.level.robot.gameObject.AddComponent(BoxCollider).isTrigger = true;\\n  // }\\n\\n  OnDestroy() {\\n    // Destroy(MainGame.level.robot.GetComponent(BoxCollider));\\n  }\\n}\\n\\n// class Drop extends Move {\\n//   constructor ()\\n//   {\\n//     super();\\n//     this.pickupObject.isPickedUp = false;\\n//   }\\n\\n// }\\n\\n\\nclass SleepObj extends Move {\\n  public timeLeft: number;\\n\\n  constructor(moveList: RobotMoveList,timeLeft: number) {\\n    super(moveList);\\n    this.timeLeft = timeLeft;\\n  }\\n\\n  Update() {\\n    //Multiply by 1000 to support milliseconds\\n    //No longer using Time.deltaTime since EVERYTHING is now frame-based\\n    //Assuming 0.017, which is 60 FPS\\n    this.timeLeft -= 0.017 * 1000;\\n  }\\n\\n  IsCompleted() {\\n    return this.timeLeft <= 0;\\n  }\\n\\n}\\n\\n// =================== Set Motor Direction =================\\n\\nclass SetDirectionObj extends Move {\\n\\n  constructor(moveList: RobotMoveList, direction: MotorDirectionEnum, engine: string) {\\n    super(moveList);\\n    //We only set the direction once. The robot keeps moving after it\'s been set, even after this move has completed.\\n    this.moveList.robot.SetDirection(direction, engine);\\n  }\\n}\\n\\n//=============== Set Motor Mode =================\\n\\n\\n\\nclass SetModeObj extends Move {\\n  constructor(moveList: RobotMoveList, mode: MotorModeEnum, engine: string) {\\n    super(moveList);\\n    this.moveList.robot.SetMode(mode, engine)\\n  }\\n}\\n\\n//================ Set Motor Power =====================\\n\\n/*\\nfunction SetPower(power: number, engine: string) {\\n  Robot.main.SetPower(power, engine);\\n}\\n*/\\n\\nclass SetPowerObj extends Move {\\n\\n  constructor(moveList : RobotMoveList, power: number, engine: string) {\\n    super(moveList);\\n    moveList.robot.SetPowerInternal(power, engine);\\n  }\\n}\\n\\n//================ Set Motor Target Position =====================\\n\\n\\n\\nclass SetTargetPositionObj extends Move {\\n\\n  constructor(moveList: RobotMoveList, power: number, engine: string) {\\n    super(moveList);\\n    moveList.robot.SetTargetPosition(power, engine);\\n\\n  }\\n}\\n\\nclass GetTargetPositionObj extends Move {\\n  engineName: string\\n  constructor(moveList: RobotMoveList, engine: string) {\\n    super(moveList);\\n    this.engineName = engine;\\n  }\\n\\n  GetReturnValue() {\\n    return this.moveList.robot.GetTargetPosition(this.engineName);\\n  }\\n}\\n\\n\\n// ================= Set stop when motor finish moving ========\\n\\n\\n\\nclass WaitUntilAtPositionObj extends Move {\\n\\n  constructor(moveList: RobotMoveList) {\\n    super(moveList);\\n  }\\n\\n  IsCompleted() {\\n    return this.moveList.robot.motorLeft.GetTickPosition() == this.moveList.robot.motorLeft.GetTickDestination()\\n      && this.moveList.robot.motorRight.GetTickPosition() == this.moveList.robot.motorRight.GetTickDestination();\\n  }\\n}\\n\\n// ================= Set only one motor ====================\\n\\n\\n\\nclass IsBusyObject extends Move {\\n  engine: string;\\n  constructor(moveList: RobotMoveList, engine: string) {\\n    super(moveList);\\n    this.engine = engine\\n\\n  }\\n\\n  IsCompleted() {\\n    return this.moveList.robot == Robot.main;\\n  }\\n\\n\\n  GetReturnValue() {\\n    const motor = Robot.main.robotMotors.find(motor => motor.GetName() === this.engine)\\n    // Debug.Log(motor.GetName())\\n    if (motor) {\\n      // Debug.Log(motor.GetTickDestination() + \\\" : \\\" + motor.GetTickPosition())\\n      return Math.floor(motor.GetTickPosition()) != Math.floor(motor.GetTickDestination())\\n    }\\n    return true;\\n  }\\n}\\n\\nclass TouchSensorCheck extends Move {\\n  public result: boolean = false;\\n\\n  Start() {\\n    //this.gameObject.AddComponent(BoxCollider).isTrigger = true;\\n  }\\n\\n  Update() {\\n    // this.transform.position.x = this.robot.transform.position.x;\\n    // this.transform.position.z = this.robot.transform.position.z;\\n  }\\n\\n  /*\\n  OnTriggerEnter(otherCollider: Collider) {\\n    if (otherCollider.GetComponent(PickupObject) != null) {\\n      Debug.Log(\\\"HOWDY\\\");\\n      this.result = true;\\n    }\\n  }\\n  */\\n\\n  TouchSensorResult(): boolean {\\n    return this.result;\\n  }\\n\\n}\\n\\n\\n\\n\",\"SensorDetect\":\"abstract class Sensor \\n{ \\n\\n  protected moveList: RobotMoveList\\n  // public get robot (): Robot\\n  // {\\n  //   return Robot.main;\\n  // }\\n\\n  constructor(moveList: RobotMoveList){\\n    this.moveList = moveList;\\n  }\\n\\n  async Run ()\\n  {\\n      return await new Promise(resolve => \\n      {\\n        var func = () => {\\n          this.Update();\\n          \\n          if (this.IsCompleted())\\n          {\\n            this.OnDestroy();\\n            Engine.scene.onBeforeRenderObservable.removeCallback(func);\\n            resolve(this.GetReturnValue());\\n          }\\n      }\\n      Engine.scene.onBeforeRenderObservable.add(func);\\n      if (this.DoesRunInstant())\\n      {\\n        func();\\n      }\\n    });\\n  }\\n\\n  DoesRunInstant () : boolean\\n  {\\n    return true;\\n  }\\n\\n  OnDestroy() : void\\n  {\\n    \\n  }\\n\\n  Update() : void\\n  {\\n\\n  }\\n\\n  //By default all moves complete instantly.\\n  IsCompleted() : boolean\\n  {\\n    return true;\\n  }\\n\\n  GetReturnValue () : any\\n  {\\n    return null;\\n  }\\n}\\n\\n// ===============================================\\n\\n\\n\\nclass WaitUntilGetColorObj extends Sensor{\\n  private expectedColor: BABYLON.Color3\\n  constructor(moveList: RobotMoveList, color: BABYLON.Color3){\\n    super(moveList);\\n    this.expectedColor = color;\\n  }\\n\\n  IsCompleted(){\\n    return Utility.CompareColor(this.expectedColor, this.moveList.robot.colorSensor.GetColor());\\n  }\\n}\\n\\n// =================== Get Color =====================\\n\\n\\n\\nclass GetColorRedObj extends Sensor{\\n  constructor(moveList: RobotMoveList){\\n    super(moveList);\\n  }\\n\\n  GetReturnValue(){\\n    return this.moveList.robot.colorSensor.GetColor().r;\\n  }\\n}\\n\\n\\n// =================== Get Color =====================\\n\\n\\n\\nclass GetColorGreenObj extends Sensor{\\n  constructor(moveList: RobotMoveList){\\n    super(moveList);\\n  }\\n\\n  GetReturnValue(){\\n    return this.moveList.robot.colorSensor.GetColor().g;\\n  }\\n}\\n\\n\\n// =================== Get Color =====================\\n\\nclass GetColorBlueObj extends Sensor{\\n  constructor(moveList: RobotMoveList){\\n    super(moveList);\\n  }\\n\\n  GetReturnValue(){\\n    return this.moveList.robot.colorSensor.GetColor().b;\\n  }\\n}\\n\\n// ====================== Convert color ====================\\nfunction RgbToColor(r: number, g: number, b: number){\\n  return Utility.ConvertRgbToHsv(r, g, b)\\n}\\n\\nfunction GetPropertyNumberHue(col: BABYLON.Color3): number{\\n  return col.r;\\n}\\n\\nfunction GetPropertyNumberSaturation(col: BABYLON.Color3): number{\\n  return col.g;\\n}\\n\\nfunction GetPropertyNumberValue(col: BABYLON.Color3): number{\\n  return col.b;\\n}\\n\\n\\n\\n\",\"Levels\":\"class BaseLevel extends MonoBehaviour\\n{\\n  public robot : Robot[] = [];\\n\\n  Awake ()\\n  {    \\n  }\\n  \\n}\\n\\n\\nclass Level_CrossNumbers extends BaseLevel {\\n\\n  Start() {\\n    super.Start();\\n    //this.renderer.isVisible = false;\\n    Instantiate(LevelTwo);\\n    \\n    //Real position\\n    \\n    //Easy victory position\\n   // BoardFactory.CreateFlag(-11.5,6.5,0);\\n  }\\n\\n  CreateRobot(): Robot{\\n    let robot = Instantiate(Robot, new Vector3(-11, 1, 11))\\n    this.robot.push(robot)\\n    return robot\\n  }\\n\\n  GetAllRobots(): Robot[]{\\n    return this.robot;\\n  }\\n\\n  GetOneRobot(robotName: string): Robot{\\n    let returnRobot = null; \\n    this.robot.forEach(r=> {\\n      if(r.robotName === robotName){\\n          returnRobot = r;\\n          return\\n      }\\n    })\\n    \\n    return returnRobot\\n    \\n  }\\n\\n  CreateMaze1(){\\n\\n  //  BoardFactory.CreateCoin(3,3);\\n  //  BoardFactory.CreateCoin(6,6);\\n //   BoardFactory.CreateCoin(-8,-5);\\n\\n    BoardFactory.CreateWall2(-10, 9, -10, 12)\\n    BoardFactory.CreateWall2(-6, 9, -10, 9)\\n    BoardFactory.CreateWall2(-6, 5, -6, 9)\\n    BoardFactory.CreateWall2(-2, 5, -6, 5)\\n    BoardFactory.CreateWall2(-2, -7, -2, 5)\\n    BoardFactory.CreateWall2(1, 1, -2, 1)\\n    BoardFactory.CreateWall2(1, 1, 1, 8)\\n    BoardFactory.CreateWall2(8, 8, 1, 8)\\n    BoardFactory.CreateWall2(8, -6, 8, 8)\\n    BoardFactory.CreateWall2(8, -6, 4, -6)\\n    BoardFactory.CreateWall2(4, -7, 4, -6)\\n    BoardFactory.CreateWall2(12, -7, 4, -7)\\n    BoardFactory.CreateWall2(-9, 6, -12, 6)\\n    BoardFactory.CreateWall2(-9, 2, -9, 6)\\n    BoardFactory.CreateWall2(-4, 2, -9, 2)\\n    BoardFactory.CreateWall2(-4, 1, -4, 2)\\n    BoardFactory.CreateWall2(-4, 1, -8, 1)\\n    BoardFactory.CreateWall2(-8, -3, -8, 1)\\n    BoardFactory.CreateWall2(-8, -3, -12, -3)\\n    BoardFactory.CreateWall2(9, -12, 9, -10)\\n    BoardFactory.CreateWall2(9, -10, -12, -10)\\n    BoardFactory.CreateWall2(0, -10, 0, -2)\\n    BoardFactory.CreateWall2(5, -3, 0, -3)\\n    BoardFactory.CreateWall2(5, -2, 0, -2)\\n    BoardFactory.CreateWall2(5, -3, 5, 5)\\n    BoardFactory.CreateWall2(4, -2, 4, 5)\\n    BoardFactory.CreateWall2(5, 5, 4, 5)\\n    BoardFactory.CreateWall2(-2, -7, -9, -7)\\n    BoardFactory.CreateWall2(-9, -7, -9, -6)\\n    BoardFactory.CreateWall2(-5, -6, -9, -6)\\n    BoardFactory.CreateWall2(-5, -6, -5, -2)\\n    BoardFactory.CreateWall2(-2, -2, -5, -2)\\n    BoardFactory.CreateFlag(10.5,-10.5,0);\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n    \\n  }\\n\\n  CreateMaze2(){\\n    BoardFactory.CreateWall2(-10, 9, -10, 12)\\n    BoardFactory.CreateWall2(-4, 9, -10, 9)\\n    BoardFactory.CreateWall2(-4, 9, -8, 5)\\n    BoardFactory.CreateWall2(-1, -2, -8, 5)\\n    BoardFactory.CreateWall2(-1, -2, -6, -2)\\n    BoardFactory.CreateWall2(-6, -5, -6, -2)\\n    BoardFactory.CreateWall2(-6, -5, -10, -5)\\n    BoardFactory.CreateWall2(-1, -4, -6, -4)\\n    BoardFactory.CreateWall2(-1 ,-7, -1, -4)\\n    BoardFactory.CreateWall2(0, -7, -1, -7)\\n    BoardFactory.CreateWall2(0, -7, 0, -4)\\n    BoardFactory.CreateWall2(4, -4, 0, -4)\\n    BoardFactory.CreateWall2(4, -4, 4, -2)\\n    BoardFactory.CreateWall2(4, -2, 0, -2)\\n    BoardFactory.CreateWall2(0, -2, 0, 7)\\n    BoardFactory.CreateWall2(0 ,7 ,6 ,10)\\n    BoardFactory.CreateWall2(8, 10, 6, 10)\\n    BoardFactory.CreateWall2(8, 6, 8, 10)\\n    BoardFactory.CreateWall2(12, 2, 8, 6)\\n    BoardFactory.CreateWall2(12, -4, 9, -4)\\n    BoardFactory.CreateWall2(12, -7, 9, -4)\\n    BoardFactory.CreateWall2(9, -12, 9, -8)\\n    BoardFactory.CreateWall2(9, -8, 6, -5)\\n    BoardFactory.CreateWall2(6, -6, 6, 0)\\n    BoardFactory.CreateWall2(9, -2, 6, -2)\\n    BoardFactory.CreateWall2(9, -2, 9, 0)\\n    BoardFactory.CreateWall2(9, 0, 3, 0)\\n    BoardFactory.CreateWall2(3, 0, 3, 6)\\n    BoardFactory.CreateWall2(3, 6, 5, 7)\\n    BoardFactory.CreateWall2(5, 4, 5, 7)\\n    BoardFactory.CreateWall2(9, 0, 5, 4)\\n    BoardFactory.CreateWall2(6, -6, 2, -6)\\n    BoardFactory.CreateWall2(2, -9, 2, -6)\\n    BoardFactory.CreateWall2(2, -9, -3, -9)\\n    BoardFactory.CreateWall2(-3, -9, -3, -6)\\n    BoardFactory.CreateWall2(-3, -7, -12, -7)\\n    BoardFactory.CreateWall2(-8, -3, -12, -3)\\n    BoardFactory.CreateWall2(-8, -3, -8, 0)\\n    BoardFactory.CreateWall2(-6, 0, -8, 0)\\n    BoardFactory.CreateWall2(-8, 0, -12, 4)\\n    BoardFactory.CreateWall2(-12, 4, -9, 7)\\n    BoardFactory.CreateWall2(-9, 7, -12, 7)\\n    BoardFactory.CreateFlag(11.5,-11.5,0);\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n  }\\n\\n  CreateMaze1_1(){\\n    BoardFactory.CreateWall2(4, -12, 4, 12);\\n    BoardFactory.CreateWall2(-4, -12, -4, 12);\\n\\n    BoardFactory.CreateFlag(0, 0, 0);\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(0, 0.5, 6);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n  }\\n\\n  CreateMaze1_2(){\\n    BoardFactory.CreateWall2(6, -6, 6, 12);\\n    BoardFactory.CreateWall2(6, -6, -12, -6);\\n    BoardFactory.CreateWall2(0, 0, -12, 0);\\n    BoardFactory.CreateWall2(0, 0, 0, 12);\\n\\n    BoardFactory.CreateFlag(-3, -3, -3);\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(3, 0.5, 5);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n\\n  }\\n\\n  CreateMaze1_3(){\\n    BoardFactory.CreateWall2(6, -6, 6, 12);\\n    BoardFactory.CreateWall2(12, -6, -4, -6);\\n    BoardFactory.CreateWall2(0, 0, -12, 0);\\n    BoardFactory.CreateWall2(0, 0, 0, 12);\\n\\n    BoardFactory.CreateFlag(9, -9, -3);\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(3, 0.5, 5);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n\\n  }\\n\\n  CreateMaze3(){\\n    BoardFactory.CreateWall2(1, 9, 1, 12);\\n    BoardFactory.CreateWall2(3, 9, 1, 9);\\n    BoardFactory.CreateWall2(3, 5, 3, 9);\\n    BoardFactory.CreateWall2(6, 5, 3, 5);\\n    BoardFactory.CreateWall2(6, 5, 6, 9);\\n    BoardFactory.CreateWall2(12, 9, 6, 9);\\n    BoardFactory.CreateWall2(-2, 9, -2, 12);\\n    BoardFactory.CreateWall2(-2, 9, -4, 9);\\n    BoardFactory.CreateWall2(-4, 5, -4, 9);\\n    BoardFactory.CreateWall2(-4, 5, -6, 5);\\n    BoardFactory.CreateWall2(-6, 5, -6, 9);\\n    BoardFactory.CreateWall2(-6, 9, -12, 9);\\n    BoardFactory.CreateWall2(12, -8, 8, -4);\\n    BoardFactory.CreateWall2(12, -4, 6, -4);\\n    BoardFactory.CreateWall2(10, -2, 6, -2);\\n    BoardFactory.CreateWall2(10, -2, 10, 6);\\n    BoardFactory.CreateWall2(10, 6, 8, 6);\\n    BoardFactory.CreateWall2(8, -2, 8, 6);\\n    BoardFactory.CreateWall2(-5, -2, -10, -2);\\n    BoardFactory.CreateWall2(-10, -2, -10, 6);\\n    BoardFactory.CreateWall2(-8, 6, -10, 6);\\n    BoardFactory.CreateWall2(-8, -2, -8, 6);\\n    BoardFactory.CreateWall2(0.5, -10, 0.5, -4);\\n    BoardFactory.CreateWall2(3, -4, -2, -4);\\n    BoardFactory.CreateWall2(3, -4, 3, 1);\\n    BoardFactory.CreateWall2(6, 1, 3, 1);\\n    BoardFactory.CreateWall2(6, 1, 6, 3);\\n    BoardFactory.CreateWall2(6, 3, 1, 3);\\n    BoardFactory.CreateWall2(1, 3, 1, 6);\\n    BoardFactory.CreateWall2(1, 6, -2, 6);\\n    BoardFactory.CreateWall2(-2, 3, -2, 6);\\n    BoardFactory.CreateWall2(-2, 3, -6, 3);\\n    BoardFactory.CreateWall2(-6, 1, -6, 3);\\n    BoardFactory.CreateWall2(-2, 1, -6, 1);\\n    BoardFactory.CreateWall2(-2, -4, -2, 1);\\n    BoardFactory.CreateWall2(-7, -12, -11, -8);\\n    BoardFactory.CreateWall2(-7, -4, -11, -8);\\n    BoardFactory.CreateWall2(-5, -4, -12, -4);\\n    BoardFactory.CreateWall2(9, -10, 3, -10);\\n    BoardFactory.CreateWall2(3, -10, 3, -6);\\n    BoardFactory.CreateWall2(6, -6, 3, -6);\\n    BoardFactory.CreateWall2(9, -10, 9, -9);\\n    BoardFactory.CreateWall2(9, -9, 6, -6);\\n    BoardFactory.CreateWall2(-2, -10, -5, -10);\\n    BoardFactory.CreateWall2(-5, -10, -7, -8);\\n    BoardFactory.CreateWall2(-5, -6, -7, -8);\\n    BoardFactory.CreateWall2(-2, -6, -5, -6);\\n    BoardFactory.CreateWall2(-2, -10, -2, -6);\\n\\n    // Create random switches with random doors\\n    if(BoardFactory.CreateRandomSwitch(new Vector3(0, 0, 7.5))){\\n      BoardFactory.CreateWall2(-2, 6, -2, 9);\\n    }else{\\n      BoardFactory.CreateWall2(1, 6, 1, 9);\\n    }\\n\\n    if(BoardFactory.CreateRandomSwitch(new Vector3(6.5, 0, 4))){\\n      BoardFactory.CreateWall2(8, 3, 6, 3);\\n    }else{\\n      BoardFactory.CreateWall2(8, 5, 6, 5);\\n    }\\n\\n    if(BoardFactory.CreateRandomSwitch(new Vector3(-6.5, 0, 4))){\\n      BoardFactory.CreateWall2(-6, 5, -8, 5);\\n    }else{\\n      BoardFactory.CreateWall2(-6, 3, -8, 3);\\n    }\\n\\n    if(BoardFactory.CreateRandomSwitch(new Vector3(4.5, 0, -5))){\\n      BoardFactory.CreateWall2(3, -6, 3, -4);\\n    }else{\\n      BoardFactory.CreateWall2(6, -6, 6, -4);\\n    }\\n\\n    if(BoardFactory.CreateRandomSwitch(new Vector3(-3.5, 0, -5))){\\n      BoardFactory.CreateWall2(-5, -6, -5, -4);\\n    }else{\\n      BoardFactory.CreateWall2(-2, -6, -2, -4);\\n    }\\n    BoardFactory.CreateFlag(11,-11,0);\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(0, 0.5, 11.5);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n  }\\n\\n  CreateMaze4(){\\n    BoardFactory.CreateWall2(1, 9, 1, 12);\\n    BoardFactory.CreateWall2(3, 9, 1, 9);\\n    BoardFactory.CreateWall2(3, 5, 3, 9);\\n    BoardFactory.CreateWall2(6, 5, 3, 5);\\n    BoardFactory.CreateWall2(6, 5, 6, 9);\\n    BoardFactory.CreateWall2(12, 9, 6, 9);\\n    BoardFactory.CreateWall2(-2, 9, -2, 12);\\n    BoardFactory.CreateWall2(-2, 9, -4, 9);\\n    BoardFactory.CreateWall2(-4, 5, -4, 9);\\n    BoardFactory.CreateWall2(-4, 5, -6, 5);\\n    BoardFactory.CreateWall2(-6, 5, -6, 9);\\n    BoardFactory.CreateWall2(-6, 9, -12, 9);\\n    BoardFactory.CreateWall2(12, -8, 8, -4);\\n    BoardFactory.CreateWall2(12, -4, 6, -4);\\n    BoardFactory.CreateWall2(10, -2, 6, -2);\\n    BoardFactory.CreateWall2(10, -2, 10, 6);\\n    BoardFactory.CreateWall2(10, 6, 8, 6);\\n    BoardFactory.CreateWall2(8, -2, 8, 6);\\n    BoardFactory.CreateWall2(-5, -2, -10, -2);\\n    BoardFactory.CreateWall2(-10, -2, -10, 6); \\n    BoardFactory.CreateWall2(-8, 6, -10, 6);\\n    BoardFactory.CreateWall2(-8, -2, -8, 6);\\n    BoardFactory.CreateWall2(0.5, -10, 0.5, -4);\\n    BoardFactory.CreateWall2(3, -4, -2, -4);\\n    BoardFactory.CreateWall2(3, -4, 3, 1);\\n    BoardFactory.CreateWall2(6, 1, 3, 1);\\n    BoardFactory.CreateWall2(6, 1, 6, 3);\\n    BoardFactory.CreateWall2(6, 3, 1, 3);\\n    BoardFactory.CreateWall2(1, 3, 1, 6);\\n    BoardFactory.CreateWall2(1, 6, -2, 6);\\n    BoardFactory.CreateWall2(-2, 3, -2, 6);\\n    BoardFactory.CreateWall2(-2, 3, -6, 3);\\n    BoardFactory.CreateWall2(-6, 1, -6, 3);\\n    BoardFactory.CreateWall2(-2, 1, -6, 1);\\n    BoardFactory.CreateWall2(-2, -4, -2, 1);\\n    BoardFactory.CreateWall2(-7, -12, -11, -8);\\n    BoardFactory.CreateWall2(-7, -4, -11, -8);\\n    BoardFactory.CreateWall2(-5, -4, -12, -4);\\n    BoardFactory.CreateWall2(9, -10, 3, -10);\\n    BoardFactory.CreateWall2(3, -10, 3, -6);\\n    BoardFactory.CreateWall2(6, -6, 3, -6);\\n    BoardFactory.CreateWall2(9, -10, 9, -9);\\n    BoardFactory.CreateWall2(9, -9, 6, -6);\\n    BoardFactory.CreateWall2(-2, -10, -5, -10);\\n    BoardFactory.CreateWall2(-5, -10, -7, -8);\\n    BoardFactory.CreateWall2(-5, -6, -7, -8);\\n    BoardFactory.CreateWall2(-2, -6, -5, -6);\\n    BoardFactory.CreateWall2(-2, -10, -2, -6);\\n    \\n    // Create random switches with random doors\\n    if(BoardFactory.CreateSwitch(new Vector3(0, 0, 7.5), new BABYLON.Color3(0,1,0))){\\n      BoardFactory.CreateWall2(-2, 6, -2, 9);\\n    }else{\\n      BoardFactory.CreateWall2(1, 6, 1, 9);\\n    }\\n\\n    if(BoardFactory.CreateSwitch(new Vector3(6.5, 0, 4), new BABYLON.Color3(0,1,0))){\\n      BoardFactory.CreateWall2(8, 3, 6, 3);\\n    }else{\\n      BoardFactory.CreateWall2(8, 5, 6, 5);\\n    }\\n\\n    if(BoardFactory.CreateSwitch(new Vector3(-6.5, 0, 4), new BABYLON.Color3(0,1,0))){\\n      BoardFactory.CreateWall2(-6, 5, -8, 5);\\n    }else{\\n      BoardFactory.CreateWall2(-6, 3, -8, 3);\\n    }\\n\\n    if(BoardFactory.CreateSwitch(new Vector3(4.5, 0, -5), new BABYLON.Color3(0,1,0))){\\n      BoardFactory.CreateWall2(3, -6, 3, -4);\\n    }else{\\n      BoardFactory.CreateWall2(6, -6, 6, -4);\\n    }\\n\\n    if(BoardFactory.CreateSwitch(new Vector3(-3.5, 0, -5), new BABYLON.Color3(0,1,0))){\\n      BoardFactory.CreateWall2(-5, -6, -5, -4);\\n    }else{\\n      BoardFactory.CreateWall2(-2, -6, -2, -4);\\n    }\\n\\n    BoardFactory.CreateFlag(11,-11,0);\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(0, 0.5, 11.5);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n\\n  }\\n\\n    CreateMaze5(){\\n\\n    BoardFactory.CreateWall2(1, 9, 1 ,12)\\n    BoardFactory.CreateWall2(8, 1, 1, 9)\\n    BoardFactory.CreateWall2(8, 1, 5, -2)\\n    BoardFactory.CreateWall2(5, -4, 5, -2)\\n    BoardFactory.CreateWall2(9, -4, 5, -4)\\n    BoardFactory.CreateWall2(10, -7, 9, -4)\\n    BoardFactory.CreateWall2(10, -12, 10, -7)\\n    BoardFactory.CreateWall2(-2, 9, -2, 12)\\n    BoardFactory.CreateWall2(-2, 9, -9, 2)\\n    BoardFactory.CreateWall2(-6, -1, -9, 2)\\n    BoardFactory.CreateWall2(-6, -3, -6, -1)\\n    BoardFactory.CreateWall2(-6, -3, -10, -3)\\n    BoardFactory.CreateWall2(-10, -3, -11, -7)\\n    BoardFactory.CreateWall2(-11, -12, -11, -7)\\n    BoardFactory.CreateWall2(7, -7, 7, -12)\\n    BoardFactory.CreateWall2(7, -7, 2, -7)\\n    BoardFactory.CreateWall2(2, -7, 2, -2)\\n    BoardFactory.CreateWall2(2, -2, 5, 1)\\n    BoardFactory.CreateWall2(5, 1, -0.5, 7)\\n    BoardFactory.CreateWall2(-6, 2, -0.5, 7)\\n    BoardFactory.CreateWall2(-3, -1, -6, 2)\\n    BoardFactory.CreateWall2(-3, -6, -3, -1)\\n    BoardFactory.CreateWall2(-3, -6, -8, -6)\\n    BoardFactory.CreateWall2(-8, -12, -8, -6)\\n\\n    let col1: BABYLON.Color3, col2: BABYLON.Color3;\\n    let x = Random.Range(0,10);\\n    if(x >= 5){\\n      col1 = new BABYLON.Color3(0, 1, 1);\\n      col2 = new BABYLON.Color3(1, 0, 0);\\n    }else{\\n      col2 = new BABYLON.Color3(0, 1, 1);\\n      col1 = new BABYLON.Color3(1, 0, 0);\\n    }\\n\\n\\n    BoardFactory.CreateLine(-0.5, 8.5, 6.5, 1, col1)\\n    BoardFactory.CreateLine(6.5, 1, 3.5, -2, col1)\\n    BoardFactory.CreateLine(3.5, -5.5, 3.5, -2, col1)\\n    BoardFactory.CreateLine(3.5, -5.5, 8, -5.5, col1)\\n    BoardFactory.CreateLine(8.5, -7, 8, -5.5, col1)\\n    BoardFactory.CreateLine(8.5, -12, 8.5, -7, col1)\\n\\n    BoardFactory.CreateLine(-0.5, 8.5, -7.5, 2, col2)\\n    BoardFactory.CreateLine(-7.5, 2, -4.5, -1, col2)\\n    BoardFactory.CreateLine(-4.5, -4.5, -4.5, -1, col2)\\n    BoardFactory.CreateLine(-4.5, -4.5, -9.5, -4.5, col2)\\n    BoardFactory.CreateLine(-9.5, -4.5, -9.5, -12, col2)\\n    BoardFactory.CreateFlag(8.5,-11.5,0);\\n    BoardFactory.CreateFlag(-9.5,-11.5,0);\\n\\n    BoardFactory.CreateRandomSwitch(new Vector3(-0.5, 0, 8.5))\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(-0.5, 0.5, 11.5);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n  }\\n\\n  CreateMaze7(){\\n\\n    for(let i = 0; i < 24; i++){\\n      let col = i % 2 == 0 ? \\n        new BABYLON.Color3(1, 165/265, 0) :\\n        new BABYLON.Color3(0, 1, 1);\\n      let x = Random.Range(-10, 10);\\n      if(9 - (i * 0.8) < -3){\\n        x = i % 2 == 0 ?\\n          Random.Range(-10, -5):\\n          Random.Range(5, 10)\\n      }\\n      BoardFactory.CreateBox(x, 9 - (i * 0.8), col)\\n    }\\n\\n    let mat = Instantiate(ColorTag, new Vector3(0, 0.1, -7.5))\\n    mat.SetColor(new BABYLON.Color3(1,0,0));\\n    mat.SetSize(7, 7)\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(-0.5, 0.5, 11.5);\\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n\\n  }\\n\\n  CreateMaze6(){\\n    BoardFactory.CreateWall2(12, 9, 10, 9)\\n    BoardFactory.CreateWall2(10, -12, 10, 9)\\n    BoardFactory.CreateWall2(10, 0, 2, 0)\\n    BoardFactory.CreateWall2(3, 0, 3, 5)\\n    BoardFactory.CreateWall2(2, 0, 2, 5)\\n    BoardFactory.CreateWall2(3, 5, -5, 5)\\n    BoardFactory.CreateWall2(-5, 4, -5, 5)\\n    BoardFactory.CreateWall2(2, 4, -5, 4)\\n    BoardFactory.CreateWall2(7, 4, 7, 12)\\n    BoardFactory.CreateWall2(7, 4, 6, 4)\\n    BoardFactory.CreateWall2(6, 4, 6, 9)\\n    BoardFactory.CreateWall2(6, 9, -8, 9)\\n    BoardFactory.CreateWall2(-8, 1, -8, 9)\\n    BoardFactory.CreateWall2(-1 ,1, -8, 1)\\n    BoardFactory.CreateWall2(-1, -2, -1, 1)\\n    BoardFactory.CreateWall2(7, -2, -5 ,-2)\\n    BoardFactory.CreateWall2(7, -9, 7, -2)\\n    BoardFactory.CreateWall2(7, -9, 6, -9)\\n    BoardFactory.CreateWall2(6, -9, 6, -5)\\n    BoardFactory.CreateWall2(6, -5, 2, -5)\\n    BoardFactory.CreateWall2(2, -5, 2, -2)\\n    BoardFactory.CreateWall2(-5, -6, -5, -2)\\n    BoardFactory.CreateWall2(-5, -6, -9, -6)\\n    BoardFactory.CreateWall2(-9, -9, -9, -6)\\n    BoardFactory.CreateWall2(-9, -9, -12, -9)\\n    BoardFactory.CreateWall2(3, -12, 3, -8)\\n    BoardFactory.CreateWall2(3, -8, -1, -8)\\n    BoardFactory.CreateWall2(-1, -8, -1, -4)\\n    BoardFactory.CreateWall2(-1, -4, -2, -4)\\n    BoardFactory.CreateWall2(-2, -9, -2, -4)\\n    BoardFactory.CreateWall2(-2, -9, -6, -9)\\n    BoardFactory.CreateWall2(-6, -12, -6, -9)\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(11, 0.5, 10.5);\\n      robot.transform.localEulerAngles.y = -90;\\n    })\\n\\n    let start_patch = Instantiate(ColorTag, new Vector3(10.5, 0.1, 10.5))\\n    start_patch.SetColor(new BABYLON.Color3(1,0,0));\\n    start_patch.SetSize(3, 3)\\n\\n    let goal_patch = Instantiate(ColorTag, new Vector3(-10.5, 0.1, -10.5))\\n    goal_patch.SetColor(new BABYLON.Color3(0,0,1));\\n    goal_patch.SetSize(3, 3)\\n  }\\n\\n  CreateMaze8(){\\n    BoardFactory.CreateWall2(12, 9, 10, 9)\\n    BoardFactory.CreateWall2(10, 3, 10 ,9)\\n    BoardFactory.CreateWall2(10, -3, 10, 1)\\n    BoardFactory.CreateWall2(10, 0, 1, 0)\\n    BoardFactory.CreateWall2(3, 0, 3, 5)\\n    BoardFactory.CreateWall2(3, 5, -5, 5)\\n    BoardFactory.CreateWall2(-5, 2, -5, 5)\\n    BoardFactory.CreateWall2(-3, 2, -5, 2)\\n    BoardFactory.CreateWall2(1, 0, 1, 2)\\n    BoardFactory.CreateWall2(1, 2, -1, 2)\\n    BoardFactory.CreateWall2(10, -12, 10, -5)\\n    BoardFactory.CreateWall2(7, 9, 7, 12)\\n    BoardFactory.CreateWall2(7, 9, -8, 9)\\n    BoardFactory.CreateWall2(-8, -2, -8, 9)\\n    BoardFactory.CreateWall2(2, -2, -8, -2)\\n    BoardFactory.CreateWall2(2, -5, 2, -2)\\n    BoardFactory.CreateWall2(6, -5, 2, -5)\\n    BoardFactory.CreateWall2(6, -7, 6, -5)\\n    BoardFactory.CreateWall2(7, -7, 6, -7)\\n    BoardFactory.CreateWall2(7, -7, 7, -2)\\n    BoardFactory.CreateWall2(7, -2, 4, -2)\\n    BoardFactory.CreateWall2(-5, -3, -5, -2)\\n    BoardFactory.CreateWall2(4, -7, -1, -7)\\n    BoardFactory.CreateWall2(-1, -7, -1, -4)\\n    BoardFactory.CreateWall2(-1, -4, -2, -4)\\n    BoardFactory.CreateWall2(-2, -8, -2, -4)\\n    BoardFactory.CreateWall2(-2, -8, -6, -8)\\n    BoardFactory.CreateWall2(-6, -8, -6, -6)\\n    BoardFactory.CreateWall2(-6, -6, -5, -6)\\n    BoardFactory.CreateWall2(-5, -6, -5, -5)\\n    BoardFactory.CreateWall2(3, -12, 3, -10)\\n    BoardFactory.CreateWall2(3, -10, -6, -10)\\n    BoardFactory.CreateWall2(-6, -12, -6, -10)\\n    BoardFactory.CreateWall2(-8, -6, -9, -6)\\n    BoardFactory.CreateWall2(-9, -9, -9, -6)\\n    BoardFactory.CreateWall2(-9 ,-9, -12, -9)\\n    BoardFactory.CreateWall2(-10, -5, -12, -5)\\n    BoardFactory.CreateWall2(-10, -5, -10, -2)\\n    BoardFactory.CreateWall2(-10, -2, -12, -2)\\n\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256)  \\n      robot.transform.position = new Vector3(11, 0.5, 10.5);\\n      robot.transform.localEulerAngles.y = -90;\\n    })\\n\\n    let start_patch = Instantiate(ColorTag, new Vector3(10.5, 0.1, 10.5))\\n    start_patch.SetColor(new BABYLON.Color3(1,0,0));\\n    start_patch.SetSize(3, 3)\\n\\n    let goal_patch = Instantiate(ColorTag, new Vector3(-10.5, 0.1, -10.5))\\n    goal_patch.SetColor(new BABYLON.Color3(0,0,1));\\n    goal_patch.SetSize(3, 3)\\n  }\\n\\n  CreatePlayground(){\\n    BoardFactory.CreateWall2(-12, -12, -12, -1.5);\\n    BoardFactory.CreateWall2(-12, 12, -12, 1.5);\\n    BoardFactory.CreateWall2(12, -12, 12, -1.5);\\n    BoardFactory.CreateWall2(12, 12, 12, 1.5);\\n    BoardFactory.CreateWall2(-12, -12, -1.5, -12);\\n    BoardFactory.CreateWall2(12, -12, 1.5, -12);\\n    BoardFactory.CreateWall2(-12, 12, -1.5, 12);\\n    BoardFactory.CreateWall2(12, 12, 1.5, 12);\\n    this.robot.forEach(robot=>{\\n      robot.SetRobotMesh(\\\"robot_1.obj\\\")\\n      robot.SetRobotColor(171/256, 64/256, 81/256) \\n      robot.transform.position = new Vector3(-0, 0.5, 6); \\n      robot.transform.localEulerAngles.y = 180;\\n    })\\n  }\\n\\n}\\n\\nclass LevelTwo extends DefaultObjectMaterialTexture {\\n\\n  Start() {\\n    this.SetupFloor();\\n  }\\n\\n  SetupFloor(){\\n    // this.renderer.SetMesh(BABYLON.Mesh.CreatePlane(\\\"Floor\\\", 24, Engine.scene));\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\\\"LevelFloor\\\", {depth: 1, width: 1, height: 1}));\\n    // this.transform.eulerAngles = new Vector3(90,0,0);\\n    \\n    var texture : BABYLON.Texture = TextureSystem.GetSprite(\\\"rubber_board.jpg\\\")\\n    texture.uScale = 6.0;\\n    texture.vScale = 6.0;\\n\\n    var normal : BABYLON.Texture = TextureSystem.GetSprite(\\\"rubber_board_normal.jpg\\\")\\n    normal.uScale = 6.0;\\n    normal.vScale = 6.0; \\n    \\n    var material  = new BABYLON.StandardMaterial(\\\"Mat\\\", Engine.scene);\\n    material.diffuseTexture = texture;\\n    material.bumpTexture = normal;\\n\\n    this.renderer.GetMesh().material = material;\\n    this.transform.localScale.x = 24;\\n    this.transform.localScale.z = 24;\\n    var coll = this.gameObject.AddComponent(BoxCollider)\\n    //Collide with all robots!\\n    coll.layerMask = ROBOT_LAYER_MASK;\\n    this.transform.position.y = -0.5\\n    // this.gameObject.AddComponent(Rigidbody)\\n    // this.gameObject.GetComponent(Rigidbody).isKinematic = true\\n    // this.GetComponent(Rigidbody).friction = 1000;\\n    \\n    this.renderer.GetMesh().receiveShadows = true;\\n  }\\n\\n}\\n\\nclass LevelTwoBorders extends MonoBehaviour {\\n\\n  Start() {\\n    // this.renderer.SetMesh(BABYLON.MeshBuilder.CreatePlane(\\\"LevelTwoBorder\\\", { sideOrientation: BABYLON.Mesh.DOUBLESIDE }));\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateBox(\\\"LevelTwoWall\\\", {depth: 1}));\\n    \\n    var texture : BABYLON.Texture = TextureSystem.GetSprite(\\\"bricks_texture.jpg\\\")\\n    texture.uScale = this.transform.localScale.x;\\n\\n    var normal : BABYLON.Texture = TextureSystem.GetSprite(\\\"bricks_normal.jpg\\\")\\n    normal.uScale = this.transform.localScale.x;\\n  \\n    var material  = new BABYLON.StandardMaterial(\\\"Mat\\\", Engine.scene);\\n    material.diffuseTexture = texture;\\n    material.bumpTexture = normal;\\n\\n    this.renderer.GetMesh().material = material;\\n\\n    CustomShadows.generator.addShadowCaster(this.renderer.GetMesh(), true);\\n  \\n    var coll = this.gameObject.AddComponent(BoxCollider)\\n    coll.layerMask = ROBOT_LAYER_MASK;\\n   // super.Setup(1, 0, 0, 1);\\n    // this.gameObject.AddComponent(BoxCollider)\\n  }\\n}\\n\\nclass LevelTwoCoins extends DefaultObjectMaterialColor{\\n  Start(){\\n    this.renderer.SetMesh(BABYLON.MeshBuilder.CreateCylinder(\\\"LevelTwoCoin\\\", {height: 0.1, diameter: 0.5}))\\n    super.Setup(1,1,0,1);\\n    this.transform.localEulerAngles.x = 90;\\n    CustomShadows.generator.addShadowCaster(this.renderer.GetMesh(), true);\\n  }\\n\\n  Update(){\\n    this.transform.localEulerAngles.z += 2;\\n  }\\n}\\n\\nclass LevelTwoFlag extends DefaultObjectMaterialColor{\\n\\n  setTexture : boolean = false;\\n  scaleFactor = 0.07;\\n\\n  Start(){\\n    \\n    this.renderer.LoadMesh(\\\"flagpole.obj\\\", this.scaleFactor, null, false);\\n    Instantiate(FlagTrigger, this.transform.position);\\n  }\\n\\n  Update ()\\n  {\\n    if (this.renderer.GetMesh() != null && !this.setTexture) \\n    {\\n      this.setTexture = true;\\n\\n      let mat = new BABYLON.StandardMaterial(\\\"mat1\\\", Engine.scene)\\n      var texture = TextureSystem.GetSprite(\\\"FirstCanada_Logo_Border.jpg\\\"); \\n      texture.uScale = 0.7;\\n      texture.vScale = 0.7;\\n\\n      texture.uOffset = 0.85;\\n      texture.vOffset = 0.1;\\n      mat.diffuseTexture = texture;\\n\\n      this.renderer.GetMeshes().forEach(mesh => {   \\n        mesh.scaling = new BABYLON.Vector3(this.scaleFactor,this.scaleFactor,this.scaleFactor);\\n\\n        if(mesh.id.includes(\\\"Flag\\\")){\\n          mesh.material = mat;\\n        }\\n\\n        //Why does this break shadows?\\n        //Shadows.generator.addShadowCaster(mesh, true);\\n\\n      });\\n     \\n    }\\n  }\\n}\\n\\nclass FlagTrigger extends MonoBehaviour\\n{\\n  triggerSize : number = 5;\\n  inVictoryArea: boolean = false;\\n  isVictory: boolean = false;\\n  Start ()\\n  {\\n    this.transform.localScale = new Vector3(this.triggerSize,this.triggerSize,this.triggerSize);\\n    //To visualize \\n    //this.renderer.LoadMesh(\\\"sphere\\\");\\n\\n    this.gameObject.AddComponent(SphereCollider).isTrigger = true;\\n  }\\n\\n  Update(){\\n    if(this.inVictoryArea){\\n      if(!this.isVictory){\\n        if(!Robot.main.IsMoving()){\\n          MainGame.instance.OnVictory();\\n          this.isVictory = true;\\n        }\\n        \\n      }\\n    }\\n  }\\n\\n  OnTriggerEnter(other : Collider)\\n  {\\n    if (other.GetComponent(Robot))\\n    {\\n        this.inVictoryArea = true;\\n    }\\n    \\n  }\\n\\n  OnTriggerExit(other : Collider)\\n  {\\n    if (other.GetComponent(Robot))\\n    {\\n      this.inVictoryArea = false;\\n    }\\n  }\\n}\\n\\nclass BoardFactory extends MonoBehaviour{\\n  public static CreateWall(posX: number, posY: number, width: number, angle: number){\\n    let wall = Instantiate(LevelTwoBorders, new Vector3(posX, 0.5, posY));\\n    wall.transform.localEulerAngles.y = angle;\\n    wall.transform.localScale = new Vector3(width, 1, 0.1);\\n    \\n  }\\n\\n  public static CreateWall2(x1: number, y1: number, x2: number, y2: number){\\n    let center = new Vector3(\\n      (x1 + x2) / 2,\\n      0.5,\\n      (y1 + y2) / 2\\n    )\\n    let start = new Vector3(x1 , 0, y1);\\n    let end = new Vector3(x2, 0, y2);    \\n    let wall = Instantiate(LevelTwoBorders, center)\\n    wall.transform.position.y = 0.5;\\n    let angle = Utility.GetAngle(start, end);\\n    let distance = Utility.GetDistance(start,end) * 0.1;\\n    wall.transform.localScale = new Vector3(distance, 1, 0.1)\\n    wall.transform.localEulerAngles.y = angle\\n  }\\n\\n  public static CreateLine(x1: number, y1: number, x2: number, y2: number, col: BABYLON.Color3){\\n     let center = new Vector3(\\n      (x1 + x2) / 2,\\n      -0.01,\\n      (y1 + y2) / 2\\n    )\\n    let start = new Vector3(x1 , 0, y1);\\n    let end = new Vector3(x2, 0, y2);\\n    \\n    let colTag1 = Instantiate(ColorTag, center)\\n    let angle = Utility.GetAngle(start, end);\\n    let distance = Utility.GetDistance(start,end) * 0.1;\\n    colTag1.SetColor(col);\\n    colTag1.transform.localScale = new Vector3(distance, 0.1, 0.1)\\n    colTag1.transform.localEulerAngles.y = angle\\n  }\\n\\n  public static CreateCoin(posX: number, posY: number){\\n    let coin = Instantiate(LevelTwoCoins, new Vector3(posX, 0.5, posY));\\n  }\\n\\n  public static CreateFlag(posX: number, posY: number, angle: number){\\n    let flag = Instantiate(LevelTwoFlag, new Vector3(posX, 0, posY));\\n    \\n    flag.transform.localEulerAngles.y = angle\\n  }\\n\\n  public static CreateRandomSwitch(pos: Vector3): boolean{\\n    let tagCol = this.RandomColor();\\n    let bIsRed = tagCol.r == 1;\\n    let colTag1 = Instantiate(ColorTag, pos)\\n    colTag1.SetColor(tagCol);\\n    return bIsRed;\\n  }\\n\\n  public static CreateSwitch(pos: Vector3, col: BABYLON.Color3){\\n    let bIsRed = this.RandomColor().r == 1;\\n    let colTag1 = Instantiate(ColorTag, pos)\\n    colTag1.SetColor(col);\\n    return bIsRed;\\n  }\\n\\n  public static CreateBox(posX: number, posY: number, col: BABYLON.Color3){\\n    let box = Instantiate(ColorBox, new Vector3(posX, 1, posY));\\n    box.SetColor(col);\\n  }\\n\\n  public static RandomColor(){\\n    if(Random.Range(0.0, 1.0)>= 0.5){\\n      return new BABYLON.Color3(1,0,0)\\n    }else{\\n      return new BABYLON.Color3(0,0,1)\\n    }\\n  }\\n}\\n\\n\\n\",\"OpModeIsActiveMove\":\"//RunOpMode returns true, but it waits one frame before it does so\\n//This way, it can be used in a while loop to make it into a \'tick\'\\nclass OpModeIsActiveObj extends Move {\\n\\n  private framesPassed : number = 0;\\n\\n  Update ()\\n  {\\n    this.framesPassed++;\\n  }\\n\\n  IsCompleted ()\\n  {\\n    //We check the second frame because Update is actually called once when the move is created\\n    return this.framesPassed >= 2;\\n  }\\n\\n  //Currrently it\'s always true - should be only for 30 seconds?\\n  GetReturnValue ()\\n  {\\n    \\n    return true;\\n  }\\n}\\n\\nasync function OpModeIsActive (robot)\\n{\\n  return new OpModeIsActiveObj(robot).Run();\\n}\\n\",\"Helpers\":\"\\nfunction GetPHPVariable (name : string) : string\\n{\\n  var parts = window.location.search.substr(1).split(\\\"&\\\");\\n  var $_GET = {};\\n  for (var i = 0; i < parts.length; i++) {\\n      var temp = parts[i].split(\\\"=\\\");\\n      $_GET[decodeURIComponent(temp[0])] = decodeURIComponent(temp[1]);\\n  }\\n  return ($_GET[name]);\\n}\\n\\nfunction GetIsChallenge() : boolean \\n{  \\n  if(window.location.href.includes(\\\"challenge\\\")){\\n    return true;\\n  }\\n  return false;\\n}\\n\\nfunction ConvertJsonCode(text: string): object{\\n  return JSON.parse(text)\\n}\",\"CameraFadeInFadeOut\":\"class CameraFadeInFadeOut extends MonoBehaviour {\\n\\n  //Tweakables\\n  logoDuration : number = 0.5;\\n  nFramesToFade : number = 85;\\n\\n  private static firstLoad : boolean = true;\\n  public light: BABYLON.DirectionalLight;\\n  public static instance : CameraFadeInFadeOut;\\n\\n  public isLightUp: boolean = false;\\n  private timer: number = 0;\\n  private isCamSet: boolean = false;\\n  private cam: BABYLON.ArcRotateCamera;\\n  private pos: BABYLON.Vector3;\\n\\n  private logo : CustomImage;\\n  private nCurrentFrames = 0;\\n\\n  Awake(){\\n\\n    this.light = Engine.scene.getLightByName(\\\"light\\\") as BABYLON.DirectionalLight;\\n    this.light.intensity = 0;\\n\\n    //Only when refreshing should the logo be shown\\n    if (CameraFadeInFadeOut.firstLoad)\\n    {\\n      CameraFadeInFadeOut.instance = this;      \\n      this.logo = Instantiate(CustomImage).Init(\\\"FirstRoboticsCanada.jpg\\\", 327, 255);\\n      CameraFadeInFadeOut.firstLoad = false;\\n    }\\n    else\\n    {\\n      //No logo\\n      this.timer = this.logoDuration;\\n    }\\n  }\\n\\n  SetCamToRobot ()\\n  {\\n      this.isCamSet = true;\\n      //Set Cam\\n      //this.cam = Camera.main.bCam as BABYLON.ArcRotateCamera\\n\\n      var camTarget = Instantiate(CamTarget);\\n      camTarget.transform.position = MainGame.level.robot[0].transform.position.clone();\\n      camTarget.transform.position.y = 0;\\n\\n     // this.cam.setTarget(camTarget.transform.transformNode);\\n     // this.cam.position = new BABYLON.Vector3(0,30,30);\\n      //this.cam.wheelPrecision = 15;\\n\\n  }\\n\\n\\n  Update(){\\n    Debug.Log(Robot.main.name)\\n\\n    //Wait with showing until robot is loaded.\\n    if(!this.isLightUp && this.timer >= this.logoDuration && Robot.main.renderer.GetMesh()){\\n      if (this.logo)\\n      {\\n        Destroy(this.logo.gameObject);\\n        this.logo = null;        \\n      }\\n      if (!this.isCamSet)\\n      {\\n        //this.SetCamToRobot();\\n      }\\n      \\n\\n      //Fade in\\n      if(this.nCurrentFrames < this.nFramesToFade){\\n        //Main (HemiSpheric) light gives general light\\n        this.light.intensity = this.nCurrentFrames * 0.005;\\n        //Directional light is for shadows\\n        CustomShadows.light.intensity = this.nCurrentFrames * 0.01;\\n        this.nCurrentFrames++;\\n      }else{\\n        this.isLightUp = true\\n      }      \\n    }else{\\n      this.timer += Time.deltaTime;\\n    }\\n\\n\\n    if(this.cam !== undefined){\\n      // handle the zooming in too much\\n      this.cam.radius = this.cam.radius < 4.5 ? 4.5 : this.cam.radius;\\n      // handle the zooming out too much\\n      this.cam.radius = this.cam.radius > 50 ? 50 : this.cam.radius;\\n    }\\n\\n\\n\\n  }\\n\\n}\\n\\n\",\"Shadows\":\"class CustomShadows extends MonoBehaviour {\\n\\n  public static generator : BABYLON.ShadowGenerator;\\n  public static light : BABYLON.DirectionalLight;\\n\\n  //Start is called before the first frame update\\n  Awake() {\\n      \\n      \\t// light1\\n    if(!CustomShadows.light)\\n    CustomShadows.light = new BABYLON.DirectionalLight(\\\"dir01\\\", new BABYLON.Vector3(-1, -1, -1), Engine.scene);\\n    CustomShadows.light.position = new BABYLON.Vector3(20, 40, 20);\\n    CustomShadows.light.intensity = 0;\\n      \\n    CustomShadows.generator = new BABYLON.ShadowGenerator(1024, CustomShadows.light);\\n    CustomShadows.generator.useExponentialShadowMap = true;\\n  }\\n  \\n  //Update is called once per frame\\n  Update() {\\n  \\n  }\\n\\n  OnDestroy()\\n  {\\n    CustomShadows.generator.dispose();\\n    CustomShadows.light.dispose();\\n  }\\n}\\n\",\"FPSCounterGUI\":\"class FPSCounterGUI extends MonoBehaviour\\n{\\n    \\n    nFrameUpdateInterval : number = 10;\\n\\n    text : BABYLON.GUI.TextBlock;\\n    average : number = 0;\\n    nFramesSinceUpdate : number = 0;\\n\\n    Start()\\n    {\\n      this.text = new BABYLON.GUI.TextBlock(\\\"FPS\\\", \\\"\\\");\\n      this.text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\\n      this.text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\\n      this.text.color = \\\"white\\\";\\n      Canvas.main.addControl(this.text);\\n    }\\n\\n    Update ()\\n    {\\n        this.nFramesSinceUpdate++;\\n        this.average += Time.deltaTime;\\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval)\\n        {\\n            this.text.text = \\\"FPS: \\\" + (1 / (this.average/ this.nFrameUpdateInterval)).toFixed(0);\\n            this.average = 0;\\n            this.nFramesSinceUpdate = 0;\\n        }\\n    }\\n}\",\"PlayButton\":\"class PlayButton extends MonoBehaviour\\n{\\n    button : BABYLON.GUI.Button;\\n\\n    Start()\\n    {\\n      this.button = BABYLON.GUI.Button.CreateSimpleButton(\\\"PlayButton\\\", \\\"Init\\\")\\n      this.button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\\n      this.button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\\n      this.button.color = \\\"white\\\";\\n      this.button.widthInPixels = 100;\\n      this.button.heightInPixels = 30;\\n      this.button.topInPixels = 20;\\n      this.button.onPointerClickObservable.add(e => {\\n        this.button.textBlock.text = \\\"Stop\\\";\\n        if (MainGame.instance.isRunning)\\n        {\\n          //Stop the async moves\\n          // Move.current = null;\\n          SceneManager.ReloadCurrentScene();\\n        }\\n        else \\n        {\\n          runRobotCode ();\\n        }\\n        MainGame.instance.isRunning = !MainGame.instance.isRunning;\\n      });\\n      Canvas.main.addControl(this.button);\\n    }  \\n    \\n\\n    \\n}\",\"ColorRobot\":\"class ColorRobot extends MonoBehaviour {\\n  public static SetColor(meshName: string, robot: Robot){\\n    switch(meshName){\\n\\n      case \\\"robot_1.obj\\\":\\n        \\n          robot.renderer.GetMeshes().forEach((e,i) => {\\n            e.position.y -= 0.5,\\n            e.isPickable = false\\n            let mat = new BABYLON.StandardMaterial(\\\"mat1\\\", Engine.scene)\\n            mat.roughness = 0.2 \\n            mat.diffuseColor = new BABYLON.Color3(0.2,0.2,0.2)\\n            if(e.id.includes(\\\"Cube\\\")){\\n              mat.diffuseColor = new BABYLON.Color3(1,0,0)\\n            }\\n            if(e.id.includes(\\\"bubbles\\\") ||\\n              e.id.includes(\\\"Cube.001\\\") ||\\n              e.id.includes(\\\"Cube.002\\\") ){\\n              mat.diffuseColor = new BABYLON.Color3(0.4,0.2,0.2)\\n\\n            }\\n\\n            if(\\n              e.id.includes(\\\"Cylinder.010\\\") ||\\n              e.id.includes(\\\"Cylinder.012\\\") ||\\n              e.id.includes(\\\"Cylinder.016\\\") ||\\n              e.id.includes(\\\"Cylinder.017\\\")){\\n              mat.diffuseColor = new BABYLON.Color3(0.7,0.7,0.7)\\n            }\\n\\n            if(e.id.includes(\\\"Cylinder.020\\\") ||\\n              e.id.includes(\\\"Gear\\\")\\n              ){\\n              mat.diffuseColor = new BABYLON.Color3(0,0.7,0)\\n\\n            }\\n\\n            if(e.id.includes(\\\"Cube.018\\\") ||\\n              e.id.includes(\\\"Plaque\\\")){\\n              mat.diffuseColor = new BABYLON.Color3(0.7,0.7,0)\\n            }\\n\\n            if(e.id.includes(\\\"Cube_Cube.004\\\")){\\n              mat.diffuseColor = new BABYLON.Color3(0,0,0.5)\\n            }\\n\\n            if(\\n              e.id.includes(\\\"Cylinder.002\\\") ||\\n              e.id.includes(\\\"Cylinder.009\\\") ||\\n              e.id.includes(\\\"Cylinder.008\\\")\\n            ){\\n              mat.diffuseColor = new BABYLON.Color3(1,0.6,0)\\n            }\\n            \\n            e.material = mat\\n          })\\n        \\n        break;\\n        default:\\n          let mat = new BABYLON.StandardMaterial(\\\"mat1\\\", Engine.scene);\\n          mat.roughness = 0.2;\\n          mat.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.2)\\n          Robot.main.renderer.GetMeshes().forEach(e => {\\n            e.material = mat; \\n          })\\n    }\\n    \\n  }\\n  \\n}\\n\",\"CamTarget\":\"class CamTarget extends MonoBehaviour {\\n\\n  moveSpeed : number = .1;\\n\\n\\n  firstFrame : boolean = true;\\n  offset: Vector3 = new Vector3(0,0,0);\\n  origin: Vector3 = new Vector3(0,0,0);\\n  robotOffset: Vector3 = new Vector3(0,0,0);\\n  robotOrigin: Vector3 = new Vector3(0,0,0);\\n\\n  cameraSpeed: number = 0.3\\n\\n  //Start is called before the first frame update\\n  Start() {\\n    this.transform.radians = new Vector3(0,0,0);\\n    //this.renderer.LoadMesh(\\\"sphere\\\", 0.1);\\n    this.origin = this.transform.position.clone();\\n    this.robotOrigin = Robot.main.transform.position.clone();\\n    // cam.setTarget(Robot.main.renderer.GetMesh(), false, true)\\n    \\n  }\\n  \\n  //Update is called once per frame\\n  Update() {\\n    if (this.firstFrame)\\n    {\\n      this.firstFrame = false;\\n      return;\\n    }\\n\\n    this.robotOffset = new Vector3(\\n      Robot.main.transform.position.x - this.robotOrigin.x,\\n      Robot.main.transform.position.y - this.robotOrigin.y,\\n      Robot.main.transform.position.z - this.robotOrigin.z,\\n    );\\n    \\n    \\n    \\n    this.Panning();\\n    \\n\\n     \\n  }\\n\\n  Panning ()\\n  {\\n    this.transform.radians.y = Camera.main.bCam.absoluteRotation.toEulerAngles().y;\\n\\n    var translation = BABYLON.Vector3.Zero();\\n\\n    if (Input.GetKey(KeyCode.W))\\n    {\\n      translation.z = 1;\\n    }\\n\\n    if (Input.GetKey(KeyCode.S))\\n    {\\n      translation.z = -1;\\n    }\\n\\n    if (Input.GetKey(KeyCode.A))\\n    {\\n      translation.x = -1;\\n    }\\n\\n    if (Input.GetKey(KeyCode.D))\\n    {\\n      translation.x = 1;\\n    }\\n\\n    this.transform.transformNode.translate(translation, this.moveSpeed, BABYLON.Space.LOCAL);\\n\\n  }\\n\\n  UnrealMovement(){\\n    var cam =  Camera.main.bCam as BABYLON.ArcRotateCamera;\\n    this.transform.radians.y = cam.absoluteRotation.toEulerAngles().y;\\n\\n    // cam.setTarget(Robot.main.renderer.GetMesh(), false, true)\\n    let movingAngle = this.transform.eulerAngles.y;\\n    let rot = cam.absoluteRotation.toEulerAngles();\\n    // Debug.Log(\\\"x: \\\" + rot.x * Mathf.Rad2Deg + \\\", y: \\\" + rot.y * Mathf.Rad2Deg + \\\", z: \\\" + rot.z * Mathf.Rad2Deg);\\n  \\n    if (Input.GetKey(KeyCode.W))\\n    {\\n      this.offset.z += Math.cos(rot.y) * this.cameraSpeed;\\n      this.offset.x += Math.sin(rot.y) * this.cameraSpeed;\\n      this.offset.y -= Math.sin(rot.x) * this.cameraSpeed;\\n    }\\n    if (Input.GetKey(KeyCode.A))\\n    {\\n      this.offset.x -= Math.cos(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\\n      this.offset.z += Math.sin(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\\n     // this.renderer.isVisible = true;\\n    }\\n    if (Input.GetKey(KeyCode.S))\\n    {\\n      this.offset.z -= Math.cos(rot.y) * this.cameraSpeed;\\n      this.offset.x -= Math.sin(rot.y) * this.cameraSpeed;\\n      this.offset.y += Math.sin(rot.x) * this.cameraSpeed;\\n    }\\n    if (Input.GetKey(KeyCode.D))\\n    {\\n      this.offset.x += Math.cos(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\\n      this.offset.z -= Math.sin(movingAngle * Mathf.Deg2Rad) * this.cameraSpeed;\\n     // this.renderer.isVisible = true;\\n    }\\n\\n    if (Input.GetKey(KeyCode.Space)){\\n      this.offset = new Vector3(0,0,0);\\n    }\\n    this.transform.position = new Vector3(\\n      this.origin.x + this.offset.x + this.robotOffset.x,\\n      this.origin.y + this.offset.y + this.robotOffset.y,\\n      this.origin.z + this.offset.z + this.robotOffset.z\\n    );\\n  }\\n  \\n}\\n\",\"HDREnvironment\":\"class HDREnvironment extends MonoBehaviour {\\n\\n  Start() {\\n    var skybox = BABYLON.MeshBuilder.CreateBox(\\\"skyBox\\\", {size:100.0}, Engine.scene);\\n    var skyboxMaterial = new BABYLON.StandardMaterial(\\\"skyBox\\\", Engine.scene);\\n    skyboxMaterial.backFaceCulling = false;\\n    skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture(getTexture(\\\"machineShop.hdr\\\"), Engine.scene, 256);\\n    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\\n    skybox.material = skyboxMaterial;\\n  }\\n}\\n\"},\"model\":{\"ball.obj\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.ball.obj\"},\"robot_3.obj\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.robot_3.obj\"},\"robot_2.obj\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.robot_2.obj\"},\"robot_1.obj\":{\"uri\":\"https://s3-us-west-1.amazonaws.com/test.pixelpad.io/eplusbase.obj\"},\"flagpole.obj\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.flagpole.obj\"}},\"texture\":{\"GameBoard_LevelTwo.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.GameBoard_LevelTwo.png\"},\"MaroonTexture.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.MaroonTexture.png\"},\"YellowTexture.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.YellowTexture.png\"},\"robot.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6396.210669.robot.png\"},\"gridTile.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210760.gridTile.png\"},\"asphaltTile.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.asphaltTile.jpg\"},\"asphaltNormal.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.asphaltNormal.jpg\"},\"bricks_texture.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.bricks_texture.jpg\"},\"bricks_normal.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.bricks_normal.jpg\"},\"FirstRobotics.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.FirstRobotics.png\"},\"YouWinPopup.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.YouWinPopup.png\"},\"ContinueButton.png\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.ContinueButton.png\"},\"FirstRoboticsCanada.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.FirstRoboticsCanada.jpg\"},\"FirstCanada_Logo_Border.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.FirstCanada_Logo_Border.jpg\"},\"hdrEnv.hdr\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.hdrEnv.hdr\"},\"testHdri.hdr\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.testHdri.hdr\"},\"rubber_pad.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.rubber_pad.jpg\"},\"rubber_board.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.rubber_board.jpg\"},\"rubber_board_normal.jpg\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.rubber_board_normal.jpg\"},\"machineShop.hdr\":{\"uri\":\"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.6400.210786.machineShop.hdr\"}},\"sound\":{},\"library\":{},\"scene\":{\"MainScene.scn\":\"{\\n   \\\"t\\\":\\\"Scene\\\",\\n   \\\"rootObjs\\\":[\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"Cam\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":100,\\n                  \\\"z\\\":-100\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":45.000000000000014,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"uniqueId\\\":36094,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Camera\\\"\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"MainGame\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":-5.393712090331874,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"uniqueId\\\":36096,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"MainGame\\\"\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"GameObject (CustomShadows)\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"uniqueId\\\":36097,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"CustomShadows\\\"\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      }\\n   ]\\n}\",\"Level_1.scn\":\"{\\n   \\\"t\\\":\\\"Scene\\\",\\n   \\\"rootObjs\\\":[\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"Floor\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":10,\\n                  \\\"y\\\":0.2,\\n                  \\\"z\\\":10\\n               },\\n               \\\"uniqueId\\\":45468,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Renderer\\\",\\n               \\\"meshName\\\":\\\"box\\\",\\n               \\\"materialName\\\":\\\"\\\",\\n               \\\"scale\\\":1,\\n               \\\"castShadows\\\":false,\\n               \\\"receiveShadows\\\":true\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               }\\n            },\\n            {\\n               \\\"t\\\":\\\"Rigidbody\\\",\\n               \\\"_mass\\\":10,\\n               \\\"_restitution\\\":0.5,\\n               \\\"_friction\\\":0.5,\\n               \\\"_isKinematic\\\":true\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"GameObject\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0.5278700590133667,\\n                  \\\"z\\\":-1.9541322871034261\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":6.688668376711601,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":0.08149530132484559\\n               },\\n               \\\"uniqueId\\\":45476,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Renderer\\\",\\n               \\\"meshName\\\":\\\"box\\\",\\n               \\\"materialName\\\":\\\"Wall.mat\\\",\\n               \\\"scale\\\":1,\\n               \\\"castShadows\\\":true,\\n               \\\"receiveShadows\\\":false\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               }\\n            },\\n            {\\n               \\\"t\\\":\\\"Rigidbody\\\",\\n               \\\"_mass\\\":10,\\n               \\\"_restitution\\\":0.5,\\n               \\\"_friction\\\":0.5,\\n               \\\"_isKinematic\\\":true\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"GameObject\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0.5278700590133667,\\n                  \\\"z\\\":2.178962910932912\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":6.688668376711601,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":0.08149530132484559\\n               },\\n               \\\"uniqueId\\\":45484,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Renderer\\\",\\n               \\\"meshName\\\":\\\"box\\\",\\n               \\\"materialName\\\":\\\"Wall.mat\\\",\\n               \\\"scale\\\":1,\\n               \\\"castShadows\\\":true,\\n               \\\"receiveShadows\\\":false\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               }\\n            },\\n            {\\n               \\\"t\\\":\\\"Rigidbody\\\",\\n               \\\"_mass\\\":10,\\n               \\\"_restitution\\\":0.5,\\n               \\\"_friction\\\":0.5,\\n               \\\"_isKinematic\\\":true\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"GameObject\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":-3.2984964317658836,\\n                  \\\"y\\\":0.5278700590133667,\\n                  \\\"z\\\":0.10124391989436034\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":89.99999999999999,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":4.251978852934279,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":0.08149530132484559\\n               },\\n               \\\"uniqueId\\\":45492,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Renderer\\\",\\n               \\\"meshName\\\":\\\"box\\\",\\n               \\\"materialName\\\":\\\"Wall.mat\\\",\\n               \\\"scale\\\":1,\\n               \\\"castShadows\\\":true,\\n               \\\"receiveShadows\\\":false\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               }\\n            },\\n            {\\n               \\\"t\\\":\\\"Rigidbody\\\",\\n               \\\"_mass\\\":10,\\n               \\\"_restitution\\\":0.5,\\n               \\\"_friction\\\":0.5,\\n               \\\"_isKinematic\\\":true\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"MainGame\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"uniqueId\\\":45500,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"MainGame\\\"\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"Camera\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0.14000000059604645,\\n                  \\\"y\\\":7.570000171661377,\\n                  \\\"z\\\":-7.949999809265137\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":39.749998867089374,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":0.9999999679829527,\\n                  \\\"z\\\":0.9999999679829527\\n               },\\n               \\\"uniqueId\\\":45501,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Camera\\\"\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"Light\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":16.862238333821264,\\n                  \\\"y\\\":46.490000009536764,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":3.989999999998979,\\n                  \\\"y\\\":-5.080000000000061,\\n                  \\\"z\\\":-8.369241323378613e-15\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"uniqueId\\\":45503,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Light\\\",\\n               \\\"intensity\\\":0.7\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      },\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"robot_1 (Clone)\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0.1422383338212967,\\n                  \\\"y\\\":5.0731963396072395,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"uniqueId\\\":45506,\\n               \\\"ser_children\\\":[\\n                  null\\n               ]\\n            }\\n         ],\\n         \\\"prefabName\\\":\\\"robot_1.prefab\\\"\\n      }\\n   ]\\n}\"},\"material\":{\"Wall.mat\":\"{\\\"t\\\":\\\"Material\\\",\\\"mainColor\\\":{\\\"t\\\":\\\"Color\\\",\\\"r\\\":1,\\\"g\\\":1,\\\"b\\\":1},\\\"mainTexture\\\":\\\"bricks_texture.jpg\\\",\\\"normalTexture\\\":\\\"bricks_normal.jpg\\\"}\"},\"prefab\":{\"Wall.prefab\":\"{\\n   \\\"t\\\":\\\"Scene\\\",\\n   \\\"rootObjs\\\":[\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"WallBase\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":0.1\\n               },\\n               \\\"uniqueId\\\":8480,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Renderer\\\",\\n               \\\"meshName\\\":\\\"box\\\",\\n               \\\"materialName\\\":\\\"Wall.mat\\\",\\n               \\\"scale\\\":1\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               }\\n            },\\n            {\\n               \\\"t\\\":\\\"Rigidbody\\\",\\n               \\\"_mass\\\":10,\\n               \\\"_isKinematic\\\":false\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      }\\n   ]\\n}\",\"robot_1.prefab\":\"{\\n   \\\"t\\\":\\\"Scene\\\",\\n   \\\"rootObjs\\\":[\\n      {\\n         \\\"t\\\":\\\"GameObject\\\",\\n         \\\"name\\\":\\\"Robot\\\",\\n         \\\"components\\\":[\\n            {\\n               \\\"t\\\":\\\"Transform\\\",\\n               \\\"_position\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_eulerAngles\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               },\\n               \\\"_scale\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0.05,\\n                  \\\"y\\\":0.05,\\n                  \\\"z\\\":0.05\\n               },\\n               \\\"uniqueId\\\":44472,\\n               \\\"ser_children\\\":[\\n                  \\n               ]\\n            },\\n            {\\n               \\\"t\\\":\\\"Renderer\\\",\\n               \\\"meshName\\\":\\\"robot_1\\\",\\n               \\\"materialName\\\":\\\"\\\",\\n               \\\"scale\\\":1,\\n               \\\"castShadows\\\":false,\\n               \\\"receiveShadows\\\":false\\n            },\\n            {\\n               \\\"t\\\":\\\"Robot\\\"\\n            },\\n            {\\n               \\\"t\\\":\\\"Rigidbody\\\",\\n               \\\"_mass\\\":10,\\n               \\\"_restitution\\\":0.5,\\n               \\\"_friction\\\":0.5,\\n               \\\"_isKinematic\\\":false\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":1,\\n                  \\\"y\\\":1,\\n                  \\\"z\\\":1\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":0,\\n                  \\\"z\\\":0\\n               }\\n            },\\n            {\\n               \\\"t\\\":\\\"BoxCollider\\\",\\n               \\\"_isTrigger\\\":false,\\n               \\\"_layer\\\":1,\\n               \\\"_layerMask\\\":1,\\n               \\\"_size\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":30,\\n                  \\\"y\\\":20,\\n                  \\\"z\\\":45\\n               },\\n               \\\"_center\\\":\\n               {\\n                  \\\"t\\\":\\\"Vector3\\\",\\n                  \\\"x\\\":0,\\n                  \\\"y\\\":10,\\n                  \\\"z\\\":6.160000000000006\\n               }\\n            }\\n         ],\\n         \\\"prefabName\\\":null\\n      }\\n   ]\\n}\"}}}