{
    "assets": {
        "code": [
            {
                "main": "/*\r\nReminders for PixelPAD Union\r\n\r\n- Instance variables need to be initialized! Even basic vars such as integers/strings\r\n- There are no structs. Basic objects such as Vectors pass by reference by default\r\n- Specific Vectors like position, rotation can be set by simply setting their individual variables.\r\n    e.g. transform.position.x = 4 works\r\n- Instantiate is used to create GameObjects with a specific Component or as a prefab\r\n\r\n*/\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n\r\n*/\r\n"
            },
            {
                "Engine": [
                    {
                        "Serializer.ts": "class Serializer {\n  public static isCreatingGameObject;\n  public static isSettingParent;\n  public static generatingNewGUIDs;\n\n  private static serializedProperties: Map<any, SerializedProperty[]> = new Map();\n  //Some properties are serialized but should not show in inspector\n  private static hiddenProperties: Map<any, string[]> = new Map();\n\n  public static enumTypeToValues: Map<any, string[]> = new Map();\n\n  private static isSerializingPrefab;\n\n\n  static RegisterSerialized(target: any, property: any, enumType: any = null): void {\n    let keys: SerializedProperty[] = this.serializedProperties.get(target);\n    if (!keys) {\n      keys = [];\n      this.serializedProperties.set(target, keys);\n    }\n    keys.push({ name: property, propType: enumType });\n  }\n\n  static RegisterHideInInspector(target: any, property: any): void {\n    let keys: string[] = this.hiddenProperties.get(target);\n    if (!keys) {\n      keys = [];\n      this.hiddenProperties.set(target, keys);\n    }\n    keys.push(property);\n  }\n\n  //Returns all serialized properties of an object, including it's base classes\n  static GetProperties(objType: any, includeHidden: boolean): SerializedProperty[] {\n    let keys: SerializedProperty[] = new Array();\n\n    let baseClass: any = Object.getPrototypeOf(objType);\n\n    if (baseClass) {\n      //Recursion to append to keys.\n      keys = keys.concat(this.GetProperties(baseClass, includeHidden));\n    }\n\n    //If it's serialized, but not hidden...\n    if (this.serializedProperties.has(objType)) {\n      //The props of only this class (not using inheritance)\n      let props = this.serializedProperties.get(objType);\n      //Copy over the array (is this the best approach?)\n      props.forEach((value: SerializedProperty) => {\n        //if includeHidden (means ignore HideInInspector refs) OR if it's not a hidden property\n        if (includeHidden || !(this.hiddenProperties.has(objType) && this.hiddenProperties.get(objType).indexOf(value.name) != -1)) {\n          keys.push(value)\n        }\n      }\n      );\n    }\n\n\n    return keys;\n  }\n\n  static GetPropValues(target: any, includeHidden: boolean): Map<SerializedProperty, any> {\n    //The map that we return\n    var propValues: Map<SerializedProperty, any> = new Map();\n\n    var targetObjectType = Object.getPrototypeOf(target);\n\n    let keys: SerializedProperty[] = this.GetProperties(targetObjectType, includeHidden);\n    //Fill up the map with those strings\n    for (const property of keys) {\n      propValues.set(property, target[property.name]);\n    }\n\n    return propValues;\n  }\n\n  static nl: NextLine;\n\n  static FromJSON(jsonData: string, reportErrors: boolean = true): any {\n    try {\n      //A cast is only a hint for static code analysis but doesn't have any effect at runtime.\n      var jsonObject: any = JSON.parse(jsonData);\n\n      var realObject: any = this.CreateFromJSObjNew(jsonObject);\n\n      return realObject;\n    } catch (e) {\n      if (reportErrors) {\n        Debug.Log(\"Error creating JSON Object: \" + e, true);\n      }\n      return null;\n    }\n\n    return realObject;\n  }\n\n  private static IsBasicType(value: any): boolean {\n    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n  }\n\n  private static gosToAwaken: GameObject[] = new Array();\n\n  //owner can be either a Transform (for children GameObjects) or a GameObject (for components)\n  static CreateFromJSObjNew(jsObj: any) {\n    let obj = this.CreateFromJSObjInternal(jsObj);\n\n    while (Serializer.gosToAwaken.length > 0) {\n      let go = Serializer.gosToAwaken.pop();\n\n        go.components.forEach(c => {\n          //Skip the transform component (already handled above)\n          //if (c.transform != c) {\n           c.InternalAwake(go);\n           \n          //}\n        });\n     \n\n    }\n    return obj;\n  }\n\n  //owner can be either a Transform (for children GameObjects) or a GameObject (for components)\n  private static CreateFromJSObjInternal(jsObj: any, propDesc: PropertyDescriptor = null, owner: BaseObject = null): any {\n    if (jsObj == null) {\n      return null;\n    }\n    var objType: string = jsObj.t;\n    let isGameObject: boolean = (objType === \"GameObject\");\n    var isCreatingPrefab = false;\n    var obj: any = null;\n\n    if (isGameObject) {\n      if (jsObj.prefabName) {\n        isCreatingPrefab = true;\n      }\n      //Used in the GameObject constructor to not create default components when Serializing.\n      this.isCreatingGameObject = true;\n      obj = new GameObject();\n      this.isCreatingGameObject = false;\n    } else {\n      //instance creation here. Instance might not exist so we just return null in that case\n      try {\n        obj = eval(\"new \" + objType + \"();\");\n      } catch (e) {\n        Debug.Log(e);\n        return null;\n      }\n    }\n\n    var props = this.GetProperties(obj, true);\n\n    var children: Transform[] = new Array;\n    props.forEach((prop: SerializedProperty) => {\n\n      var value = null;\n      try {\n        var p: PropertyDescriptor = Object.getOwnPropertyDescriptor(jsObj, prop.name);\n        value = p.value;\n      } catch (error) {\n        //No need to print. This means that the serialized field in the object, could not be found in the JSON\n        //This can simply mean that the JSON did not yet contain that serialized property (e.g. if it was just added)\n        return;\n      }\n      if (value === null) {\n        //Do nothing (variable can remain null)\n      } else if (this.IsBasicType(value)) {\n        Object.defineProperty(obj, prop.name, p);\n\n      } else if (value instanceof Array) {\n        var isc: boolean = isGameObject && prop.name == \"components\";\n\n        //If there are no components, we just add a single Transform.\n        if (isc && value.length === 0) {\n          Debug.Log(\"Object \" + obj.name + \" was corrupted. It has been reset.\");\n          obj.AddComponent(Transform);\n        }\n\n        for (var i: number = 0; i < value.length; i++) {\n          //Basic variables such as strings & bools are already good\n          if (this.IsBasicType(value[i])) {\n            continue;\n          }\n          value[i] = (this.CreateFromJSObjInternal(value[i], null, isc ? obj : null));\n        }\n\n        //We store the 'children' array for later.\n        if (obj instanceof Transform && prop.name == \"ser_children\") {\n          //Removes all null elements from the list.\n          //Due to the serialization process more and more null elements get added\n          children = value;\n          //We generate uniqueGUIDs when e.g. we're cloning an object \n          if (Serializer.generatingNewGUIDs) {\n            obj.uniqueId = uuidv4();\n          }\n        }\n\n        //If isComponent, we don't need to redefine the 'components' array since we already push the \n        //components through their Awake call.\n        if (!isc) {\n          Object.defineProperty(obj, prop.name, p);\n        }\n      } else {\n        //When we use defineProperty, it is ESSENTIAL we set a PropertyDescriptor\n        //If we only set the value, it will override access modifiers\n        //E.g. after setting, a read+write variable might just become read only 0_o\n        Object.defineProperty(obj, prop.name, this.CreateFromJSObjInternal(value, p));\n      }\n    });\n\n    if (owner) {\n      //PreAwake runs regardless of it being active etc etc\n      obj.InternalPreAwake(owner);\n      //Transform component needs it's awakening called beforehand.\n      if (objType == \"Transform\" || objType === \"RectTransform\") {\n        //AFTER the Transform has 'awoken' we can set the children to it.\n        //TODO can we do this inside the Transform component???\n\n        //The order here is:\n        //1) Start Transform Creation\n        //2) Create Children\n        //3) Finish Transform Creation\n        //4) Set Children to be parented to Transform\n        for (let i: number = 0; i < children.length; i++) {\n          this.isSettingParent = true;\n          if (children[i]?.transform) {\n            children[i].transform.SetParent(obj, false);\n          }\n          this.isSettingParent = false;\n        }\n      }\n\n    }\n\n    if (isCreatingPrefab) {\n      Prefab.Create(jsObj.prefabName, obj);\n    }\n\n    if (propDesc) {\n      propDesc.value = obj;\n      return propDesc;\n    }\n\n    //These get pushed so that after ALL GameObjects where created in the hierarchy, we can call Awake on their components\n    if (isGameObject) {\n      Serializer.gosToAwaken.push(obj);\n    }\n\n    return obj;\n  }\n\n  static ToJSON(target: any, prettyPrint: boolean = false): string {\n\n    this.nl = new NextLine(prettyPrint);\n    return this.GetPropertyJSON(target);\n  }\n\n  private static GetPropertyJSON(target: any): string {\n\n    var data: string = \"\";\n\n    if (!target) {\n      return \"null\";\n    }\n    var typeName = target.constructor.name;\n    var isParentPrefab = false;\n    if (typeName == \"GameObject\") {\n      if (target.prefabParent) {\n        if (target.prefabParent == target) {\n          isParentPrefab = true;\n        }\n        else {\n          //If it has a prefab Parent (and it's not the prefab parent itself)\n          //we return null since we will be loading this from the prefab.\n          return \"null\";\n        }\n      }\n    }\n\n    //Shortcut    \n    var nl = this.nl;\n\n    data += \"{\" + nl.Tab();\n\n\n    data += \"\\\"t\\\":\\\"\" + typeName + \"\\\"\";\n\n\n    var propValues: Map<SerializedProperty, any> = this.GetPropValues(target, true);\n\n    propValues.forEach((value: any, key: SerializedProperty) => {\n      //Too hacky?\n      if (this.isSerializingPrefab) {\n        //If it's the Prefab\n        if (isParentPrefab && key.name == \"name\") {\n          value = target.prefabName;\n        }\n      }\n      data += \",\" + nl;\n      data += \"\\\"\" + key.name + \"\\\"\" + \":\";\n      if (value === null || value === undefined) {\n        data += \"null\";\n      } else if (value instanceof Array) {\n        data += \"[\" + nl.Tab();\n        for (var j: number = 0; j < value.length; j++) {\n          //TODO This is WET!\n          if (typeof value[j] == 'number' || typeof value[j] == 'boolean') {\n            data += value[j];\n          }\n          else if (typeof value[j] == 'string') {\n            data += \"\\\"\" + value[j] + \"\\\"\";\n          } else {\n            data += this.GetPropertyJSON(value[j]);\n          }\n\n          if (j < value.length - 1) {\n            data += \",\" + nl;\n          }\n        }\n        data += (nl.ShiftTab() + \"]\");\n      }\n      else if (typeof value == 'number' || typeof value == 'boolean') {\n        data += value;\n      }\n      else if (typeof value == 'string') {\n        data += \"\\\"\" + value + \"\\\"\";\n      } else {\n        //Assuming everything can be processed.  \n        data += nl + this.GetPropertyJSON(value);\n      }\n    });\n\n    data += nl.ShiftTab() + \"}\";\n\n    return data;\n  }\n}\n\nclass NextLine {\n\n  private nl: string = \"\\n\";\n\n  private tab = \"   \";\n\n  constructor(_prettyPrint: boolean) {\n    this.prettyPrint = _prettyPrint;\n  }\n\n\n  prettyPrint: boolean = true;\n\n  ShiftTab(): string {\n    if (this.nl.endsWith(this.tab)) {\n      this.nl = this.nl.substring(0, this.nl.length - this.tab.length);\n    }\n    return this.toString();\n  }\n\n  Tab(): string {\n    this.nl += this.tab;\n    return this.toString();\n  }\n\n  toString(): string {\n    if (this.prettyPrint) {\n      return this.nl;\n    }\n\n    return \"\";\n  }\n}\n\nclass SerializedProperty {\n  name: string = \"\";\n  //Currently propType is only used for enums. It might have other use in the future?\n  propType: any;\n}\n\nfunction SerializeEnumField(enumType: any) {\n  function actualDecorator(target: Object, property: string | symbol): void {\n    Serializer.RegisterSerialized(target, property, enumType);\n  }\n  // return the decorator\n  return actualDecorator;\n}\n\nfunction SerializeConditionalField(condition: boolean) {\n\n  function actualDecorator(target: Object, property: string | symbol): void {\n    if (condition) {\n      Serializer.RegisterSerialized(target, property);\n    }\n  }\n  // return the decorator\n  return actualDecorator;\n}\n\n\nfunction SerializeField(target: Object, property: string | symbol) {\n  Serializer.RegisterSerialized(target, property);\n}\n\n\nfunction HideInInspector(target: any, propertyKey: string) {\n  Serializer.RegisterHideInInspector(target, propertyKey);\n\n}"
                    },
                    {
                        "Engine.ts": "//Default to false (e.g. inside simulator)\r\nvar ENABLE_EDITOR: boolean = false;\r\nvar checkbox = document.getElementById(\"enable_editor\");\r\nif (checkbox) {\r\n    //@ts-ignore\r\n    ENABLE_EDITOR = checkbox.checked;\r\n}\r\n\r\n\r\n// @ts-ignore\r\nBABYLON.OBJFileLoader.SKIP_MATERIALS = true;\r\n\r\nfunction uuidv4() {\r\n    //@ts-ignore\r\n    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\r\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\r\n    );\r\n}\r\n\r\nclass Engine {\r\n\r\n    public static current: BABYLON.Engine;\r\n    public static scene: BABYLON.Scene;\r\n    public static editorScene: BABYLON.Scene;\r\n    public static isPlaying: boolean = false;\r\n    public static isExitingPlayMode: boolean = false;\r\n\r\n    public static gizmoManager: BABYLON.GizmoManager;\r\n\r\n    public static targetFrameRate = 60;\r\n\r\n    //Can be adjusted for testing, specifically useful for testing memory leaks\r\n    public static get nFramesPerRenderLoop(): number {\r\n        return this._nFramesPerRenderLoop;\r\n    }\r\n\r\n    public static set nFramesPerRenderLoop(value: number) {\r\n        Debug.Log(\"WARNING: nFramesPerRenderLoop is set to \" + value + \". This should only happen during testing!\");\r\n        this._nFramesPerRenderLoop = value;\r\n    }\r\n\r\n    private static _nFramesPerRenderLoop: number = 1;\r\n\r\n    public static canvas: HTMLCanvasElement;\r\n\r\n    public static toBeDestroyed: SceneObject[];\r\n\r\n    public static meshToObject: Map<number, GameObject>;\r\n\r\n    public static editorTypes: string[] = new Array();\r\n\r\n    public static get cursor() {\r\n        return Engine.editorScene.defaultCursor;\r\n    };\r\n\r\n\r\n    public static set cursor(value: string) {\r\n        Engine.editorScene.defaultCursor = value;\r\n    };\r\n\r\n    public static onUpdate: BABYLON.Observable<number>;\r\n\r\n    public static scripts: string[] = new Array();\r\n\r\n    public static startScene: string;\r\n\r\n\r\n    public static IsEditorType(value: SceneObject): boolean {\r\n        var isEditorType: boolean = this.editorTypes.indexOf(value.constructor.name) > -1;\r\n        return isEditorType;\r\n    }\r\n\r\n    public static isSwitchingToPlayMode: boolean;\r\n\r\n    public static SwitchToPlayMode() {\r\n        Engine.startScene = SceneManager.GetActiveScene().name;\r\n        SceneManager.ReloadCurrentScene();\r\n        this.isSwitchingToPlayMode = true;\r\n    }\r\n\r\n    public static StopPlayMode() {\r\n        Cursor.lockState = CursorLockMode.None;\r\n        //Reloading the current scene, which should reset if not playing\r\n        SceneManager.LoadScene(Engine.startScene);\r\n\r\n        Engine.isExitingPlayMode = true;\r\n        Engine.isPlaying = false;\r\n    }\r\n\r\n    public static ShouldRun(obj: Component): boolean {\r\n        return Engine.isPlaying || Engine.IsEditorType(obj)\r\n    }\r\n\r\n    public static OnPlayButton(evt: CustomEvent) {\r\n        //When the recompile button is clicked, we first remove all the old listeners\r\n        PixelPADEvents.ClearAllListeners();\r\n        document.removeEventListener(\"playClicked\", Engine.OnPlayButton);\r\n    }\r\n\r\n}\r\n\r\nenum FileType {\r\n    Model = 1,\r\n    Texture,\r\n    Sound\r\n}\r\n\r\n\r\n\r\nclass Playground {\r\n\r\n    public static Init(canvas): BABYLON.Engine {\r\n\r\n        let engine = new BABYLON.Engine(canvas, true, {\r\n            deterministicLockstep: true,\r\n            lockstepMaxSteps: 4,\r\n            timeStep: Time.fixedTimeStep\r\n        });\r\n\r\n        let scene = Playground.CreateScene(engine, canvas);\r\n        // run the render loop\r\n        engine.runRenderLoop(function () {\r\n            try {\r\n                scene.render();\r\n            } catch (e) {\r\n                //@ts-ignore\r\n                ppConsoleLog(e.stack);\r\n                scene.dispose();\r\n            }\r\n        });\r\n\r\n        return engine;\r\n    }\r\n\r\n    public static Stop() {\r\n        Engine.scene?.dispose();\r\n    }\r\n\r\n    public static CreateScene(engine: BABYLON.Engine, canvas: HTMLCanvasElement): BABYLON.Scene {\r\n\r\n        Engine.current = engine;\r\n\r\n\r\n        PixelPADEvents.AddAllListeners();\r\n        document.addEventListener(\"playClicked\", Engine.OnPlayButton);\r\n\r\n\r\n        Engine.canvas = canvas;\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        Engine.scene = new BABYLON.Scene(engine);\r\n\r\n        if (ENABLE_EDITOR) {\r\n            //Since Babylon 4.2, the gizmoManager needs to be crerated BEFORE the editorScene is created \r\n            //Odd bug but this resolves it.\r\n            Engine.gizmoManager = new BABYLON.GizmoManager(Engine.scene)\r\n\r\n            Engine.editorScene = new BABYLON.Scene(engine);\r\n            Engine.editorScene.autoClear = false;\r\n            //Used for editor input - should not be \r\n            Engine.editorScene.actionManager = new BABYLON.ActionManager(Engine.editorScene);\r\n        }\r\n\r\n        Engine.scene.clearColor = BABYLON.Color4.FromColor3(new BABYLON.Color3(0, 0, 0));\r\n\r\n        //Physics are handled in the Physics class\r\n        var physEngine = new BABYLON.CannonJSPlugin(false, 10);\r\n        Engine.scene.enablePhysics(BABYLON.Vector3.Zero(), physEngine);\r\n        physEngine.setTimeStep(Time.fixedTimeStep);\r\n\r\n\r\n        Engine.meshToObject = new Map();\r\n        Engine.toBeDestroyed = new Array();\r\n\r\n        Engine.onUpdate = new BABYLON.Observable();\r\n\r\n        Engine.scripts = Engine.scripts.concat(getScripts());\r\n\r\n        Time.Init();\r\n        Random.Init();\r\n        Cursor.Init();\r\n        Material.Init();\r\n        MeshLoader.Init();\r\n        Physics.Init();\r\n        Input.Init();\r\n        Project.Init();\r\n\r\n        SceneManager.Init();\r\n        //Create Shadows and Main Directional Light \r\n        Lighting.Init();\r\n\r\n        if (ENABLE_EDITOR) {\r\n            UnionEditor.Init();\r\n            Gizmos.Init();\r\n        }\r\n        else {\r\n            Engine.isPlaying = true;\r\n        }\r\n\r\n        var sceneName = null;\r\n\r\n        //In editor mode, see if we can get our last loadedSceneOrPrefab\r\n        //Currently not working! Need option to save data outside of engine.\r\n        if (!Engine.isPlaying) {\r\n            sceneName = Project.data.loadedSceneOrPrefab;\r\n        }\r\n\r\n        if (!sceneName) {\r\n            sceneName = getFirstSceneName();\r\n        }\r\n\r\n        if (!sceneName) {\r\n            //In non-editor mode, we try to load a scene from the library\r\n            if (Engine.isPlaying) {\r\n                sceneName = getFirstLibrarySceneName();\r\n            }\r\n        }\r\n\r\n        //Babylon gets angry if we have no camera, so we create one before the real scene is loaded\r\n        var tempCam = new BABYLON.TargetCamera(\"TEMP\", BABYLON.Vector3.Zero(), Engine.scene);\r\n\r\n        setTimeout(() => {\r\n            Engine.current.stopRenderLoop();\r\n\r\n            //We load the scene after this first timeOut.\r\n            //This is essential for running in non-editor mode\r\n            //Some physics function (specifically collider offset) does not work otherwise\r\n            if (sceneName) {\r\n                SceneManager.LoadScene(sceneName);\r\n            } else {\r\n                Debug.Log(\"No scene was found! Without a scene in your game you will get unexpected errors!\")\r\n            }\r\n            tempCam.dispose();\r\n\r\n            Engine.current.runRenderLoop(() => {\r\n                Camera.main?.UpdateRender();\r\n                Engine.scene.render();\r\n                if (ENABLE_EDITOR) {\r\n                    Engine.editorScene.render();\r\n                }\r\n            });\r\n        });\r\n\r\n        Engine.scene.onBeforeStepObservable.add(() => {\r\n            var scene = SceneManager.GetActiveScene();\r\n            if (scene) {\r\n\r\n                for (var i = scene.objs.length - 1; i >= 0; i--) {\r\n                    var obj = scene.objs[i];\r\n                    obj.InternalFixedUpdate();\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n        });\r\n\r\n        // Game/Render loop\r\n        Engine.scene.onBeforeRenderObservable.add(() => {\r\n            \r\n            Time.Update();\r\n\r\n            for (var j = 0; j < Engine.nFramesPerRenderLoop; j++) {\r\n\r\n                if (ENABLE_EDITOR) {\r\n                    UnionEditor.Update();\r\n                }\r\n\r\n                if (Engine.isSwitchingToPlayMode) {\r\n                    Engine.isSwitchingToPlayMode = false;\r\n                    Engine.isPlaying = true;\r\n                    return;\r\n                }\r\n\r\n                var scene = SceneManager.GetActiveScene();\r\n                \r\n                if (scene) {\r\n                    //Start is not called directly after Awake\r\n                    //This should take care of any objects being created in the Start\r\n                    for (let i = scene.newObjs.length - 1; i >= 0; i--) {\r\n                        let newObj = scene.newObjs[i];\r\n                        //If it is not active, we skip. When it gets activated later, Start will still be called\r\n                        if (newObj.gameObject.activeInHierarchy) {\r\n                            if (!newObj.markedForDestroy) {\r\n                                newObj.InternalStart();\r\n                            }\r\n                            scene.newObjs.splice(i, 1);\r\n                        }\r\n\r\n                    }\r\n\r\n                    for (let i = scene.objs.length - 1; i >= 0; i--) {\r\n                        let obj = scene.objs[i];\r\n                        obj.InternalUpdate();\r\n                    }\r\n\r\n                    if (ENABLE_EDITOR) {\r\n                        Gizmos.color = new Color(1, 1, 1);\r\n                        for (let i = scene.objs.length - 1; i >= 0; i--) {\r\n                            let obj = scene.objs[i];\r\n                            obj.OnDrawGizmos();\r\n\r\n                            if (EditorSelection.IsSelected(obj, true)) {\r\n                                obj.OnDrawGizmosSelected();\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    Engine.onUpdate.notifyObservers(0);\r\n                }\r\n\r\n                Material.Update();\r\n\r\n                //Updates all 'just' pushed or released keys\r\n                Input.Update();\r\n\r\n                //Process detroyed objects\r\n                //Needs to be in this order so children are destroyed before parents\r\n                for (let i = 0; i < Engine.toBeDestroyed.length; i++) {\r\n\r\n                    let tbd = Engine.toBeDestroyed[i];\r\n                    tbd.InternalDestroy();\r\n                }\r\n\r\n                Engine.toBeDestroyed = new Array();\r\n\r\n                SceneManager.Update();\r\n\r\n\r\n                //Needed to check for destroying objects\r\n                if (Engine.isExitingPlayMode) {\r\n                    Engine.isExitingPlayMode = false;\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n        // Game/Render loop\r\n        Engine.scene.onAfterRenderObservable.add(() => {\r\n            let scene = SceneManager.GetActiveScene();\r\n\r\n            if (scene) {\r\n                for (let i = scene.objs.length - 1; i >= 0; i--) {\r\n\r\n                    let obj = scene.objs[i];\r\n                    obj.InternalLateUpdate();\r\n                }\r\n            }\r\n\r\n            Input.LateUpdate();\r\n\r\n            if (ENABLE_EDITOR) {\r\n                Undo.Update();\r\n            }\r\n        });\r\n\r\n        return Engine.scene;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n//Some helper methods - just like Unity\r\n\r\nfunction Instantiate<T extends MonoBehaviour>(objType: string | (new () => T), startPosition: Vector3 = Vector3.Zero()): T {\r\n\r\n    return GameObject.Instantiate<T>(objType, startPosition);\r\n}\r\n\r\nfunction Destroy(obj) {\r\n    GameObject.Destroy(obj);\r\n}\r\n\r\nfunction print(info: any) {\r\n    Debug.Log(info);\r\n}\r\n\r\n//Attribute\r\nfunction ExecuteInEditMode(target: Function) {\r\n    Engine.editorTypes.push(target.prototype.constructor.name);\r\n}\r\n\r\n/** A helper class to break up a URL in baseUrl and fileName */\r\nclass URLResult {\r\n\r\n    public static Create(name: string, fileType: FileType): URLResult {\r\n        var result: URLResult = new URLResult();\r\n        var fullUrl: string = \"\";\r\n        switch (fileType) {\r\n            case FileType.Model:\r\n                fullUrl = getModel(name);\r\n                break;\r\n            case FileType.Texture:\r\n                fullUrl = getTexture(name);\r\n                break;\r\n            case FileType.Sound:\r\n                fullUrl = getSound(name);\r\n                break;\r\n            default:\r\n                //statements; \r\n                break;\r\n        }\r\n        if (!fullUrl) {\r\n            return result;\r\n        }\r\n\r\n        var splits = fullUrl.split('/');\r\n        result.fullName = splits.pop();\r\n        result.baseUrl = splits.join('/') + \"/\";\r\n        return result;\r\n    }\r\n\r\n    baseUrl: string;\r\n    fullName: string;\r\n}"
                    },
                    {
                        "BaseObject.ts": "//script:BaseObject\nclass BaseObject extends Object\n{\n    public name : string;\n}"
                    }
                ]
            },
            {
                "Components": [
                    {
                        "SceneObject.ts": "class SceneObject extends BaseObject {\n    prefabParent: GameObject;\n\n    public get markedForDestroy(): boolean {\n        return this._markedForDestroy || this.gameObject._markedForDestroy;\n    };\n\n    public set markedForDestroy(value: boolean) {\n        this._markedForDestroy = value;\n    }\n\n    private _markedForDestroy: boolean = false;\n\n    public hasStarted: boolean = false;\n\n    public GetType(): string {\n        return this.constructor.name;\n    }\n\n    public get transform(): Transform {\n        return this.gameObject.transform;\n    }\n\n    public get renderer(): Renderer {\n        return this.gameObject.renderer;\n    }\n\n    public get gameObject(): GameObject {\n        if (!this._gameObject) {\n            Debug.Log(this.GetType(), true);\n        }\n        return this._gameObject;\n    }\n\n    private _gameObject: GameObject;\n\n    private preAwakened: boolean = false;\n    private awakened: boolean = false;\n\n    //This runs always! Even in edit mode, and if the object is inactive\n    InternalPreAwake(go: GameObject) {\n        if (this.preAwakened) {\n            Debug.Log(this.name + \" is PreAwakened twice! This is handled but should be looked into\");\n            return;\n        }\n        this.preAwakened = true;\n\n        SceneManager.MarkSceneAsDirty();\n        this._gameObject = go;\n        SceneManager.GetActiveScene().newObjs.push(this);\n\n        this.PreAwake();\n    }\n\n    PreAwake(){ }\n\n    //This should ONLY be called on active objects.\n    InternalAwake(go: GameObject) {\n        if (!go.activeInHierarchy || this.awakened) {\n            return;\n        }\n\n        if (!(Engine.isPlaying || Engine.IsEditorType(this))) {\n            return;\n        }\n\n        this.awakened = true;\n        //User implemented so needs a try-catch\n        try {\n            this.Awake();\n        } catch (e) {\n            Debug.Log(e, true);\n        }\n\n    }\n\n    Awake() { }\n\n    InternalStart() {\n        if ((Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            this.hasStarted = true\n            try {\n                this.Start();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    Start() { }\n\n    InternalUpdate() {\n        if (this.hasStarted && (Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.Update();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    Update() { }\n\n    InternalLateUpdate() {\n        if (this.hasStarted && (Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.LateUpdate();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    LateUpdate() { }\n\n    InternalFixedUpdate() {\n        if (this.hasStarted && (Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.FixedUpdate();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    FixedUpdate() {\n\n    }\n\n    InternalDestroy() {\n        if (!Engine.isPlaying) {\n            SceneManager.MarkSceneAsDirty();\n        }\n\n        if (Engine.isExitingPlayMode || Engine.isPlaying || Engine.IsEditorType(this)) {\n            //We should NOT check for awakening, since an object can be destroyed without ever being enabled\n            //if (this.awakened) {\n                try {                    \n                    //Debug.Log(\"Destroying \" + this.GetType())\n                    this.OnDestroy();\n                } catch (e) {\n                    Debug.Log(e, true);\n                }\n            //}\n\n        }\n    }\n\n    OnDrawGizmos ()\n    {\n\n    }\n\n    OnDrawGizmosSelected ()\n    {\n\n    }\n\n    OnCollisionEnter(other: Collision) { }\n\n    OnTriggerEnter(otherCollider: Collider) { }\n\n    OnTriggerStay(otherCollider: Collider) { }\n\n    OnTriggerExit(otherCollider: Collider) { }\n\n    OnDestroy() { }\n\n    GetComponent<T extends Component>(objType: new () => T): T {\n        for (var i: number = 0; i < this.gameObject.components.length; i++) {\n            if (this.CheckType(this.gameObject.components[i], objType)) {\n                var x: T = this.gameObject.components[i] as T;\n                //No need to check if it's about to be destroyed.\n                //if (!x.markedForDestroy)\n                {\n                    return x;\n                }\n            }\n        }\n        return null;\n    }\n\n    GetComponentInParent<T extends Component>(objType: new () => T): T {\n        var c = this.GetComponent(objType);\n        if (!c && this.transform?.parent) {\n            c = this.transform.parent.GetComponentInParent(objType);\n        }\n        return c;\n    }\n\n    GetComponentInChildren<T extends Component>(objType: new () => T): T {\n        var c = this.GetComponent(objType);\n        if (!c) {\n            for (var i = 0; i < this.transform.ser_children.length; i++) {\n                var child = this.transform.ser_children[i];\n                if (child)\n                    c = child.GetComponentInChildren(objType);\n                //Once found, stop looking\n                if (c)\n                    return c;\n            }\n        }\n        return c;\n    }\n\n    GetComponents<T extends Component>(objType: new () => T): T[] {\n        var arr = new Array();\n        for (var i: number = 0; i < this.gameObject.components.length; i++) {\n            if (this.CheckType(this.gameObject.components[i], objType)) {\n                var x: T = this.gameObject.components[i] as T;\n                //No need to check if it's about to be destroyed.\n                arr.push(x);\n            }\n        }\n        return arr;\n    }\n\n    GetComponentsInChildren<T extends Component>(objType: new () => T): T[] {\n        var arr = this.GetComponents(objType);\n        for (var i = 0; i < this.transform.ser_children.length; i++) {\n            var child = this.transform.ser_children[i];\n            if (child)\n                arr = arr.concat(child.GetComponentsInChildren(objType));\n        }\n\n        return arr;\n    }\n\n    GetComponentsInParent<T extends Component>(objType: new () => T): T[] {\n        var arr = this.GetComponents(objType);\n        if (this.transform.parent) {\n            arr = arr.concat(this.transform.parent.GetComponentsInParent(objType));\n        }\n\n        return arr;\n    }\n\n\n    //Recursive function to check for base-classes as well\n    CheckType(c: Component, objType: any): boolean {\n        if (c.GetType() === objType.name) {\n            return true;\n        }\n\n        //Stop looking after 'Component' \n        if (c.GetType() == \"Component\") {\n            return false;\n        }\n\n        return this.CheckType(Object.getPrototypeOf(c), objType);\n    }\n\n}"
                    },
                    {
                        "GameObject.ts": "class GameObject extends SceneObject {\n\n    public static FindObjectOfType<T extends Component>(objType: new () => T): T {\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            var comp = objs[i].GetComponent(objType);\n            if (comp) {\n                return comp;\n            }\n        }\n\n        return null;\n    }\n\n    public static FindObjectsOfType<T extends Component>(objType: new () => T): T[] {\n        var arr = new Array();\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            var comp = objs[i].GetComponent(objType);\n            if (comp) {\n                arr.push(comp);\n            }\n        }\n        return arr;\n    }\n\n    /**To find something*/\n    public static Find(name: string): GameObject {\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            if (objs[i].name == name) {\n                return objs[i];\n            }\n        }\n        return null;\n    }\n\n    @SerializeField\n    public isStatic: boolean = false;\n\n    @SerializeField\n    public name: string;\n\n    @SerializeField\n    components: Component[];\n\n    //TODO we should not refer to the prefab by name...\n    @SerializeField\n    prefabName: string;\n\n    //destroyOnLoad = true;\n\n    private get activeScene(): Scene {\n        return SceneManager.GetActiveScene();\n    }\n\n    //TODO Optimize\n    public get transform(): Transform {\n        return this.GetComponent(Transform);\n    }\n\n    public get activeSelf() {\n        return this._activeSelf;\n    }\n\n    public get activeInHierarchy() {\n        let curr = this.transform;\n        //If this object and all of it's parents are active...\n        while (curr?.gameObject?.activeSelf) {\n            if (!curr.transform.parent) {\n                return true;\n            }\n            curr = curr.transform.parent;\n        }\n        return false;\n    }\n\n    @SerializeField\n    private _activeSelf: boolean = true;\n\n    public SetActive(value: boolean) {\n        //Don't reactivate if already active\n        if (value === this._activeSelf) {\n            return;\n        }\n        this._activeSelf = value;\n        //Check if it has a parent, and if so, if the parent is activeInHierarchy\n        let activeParent = !this.transform.parent || this.transform.parent.gameObject.activeInHierarchy;\n\n        if (activeParent) {\n            this.InternalSetActive(value);\n        }\n\n        SceneManager.MarkSceneAsDirty();\n    }\n\n    /** Triggers OnEnable/OnDisable for children & components, but does not actually enable/disable an object */\n    private InternalSetActive(value: boolean) {\n\n        for (var i = 0; i < this.components.length; i++) {\n            this.components[i].InternalSetActive(value);\n        }\n\n        this.transform.ser_children.forEach(c => {\n            //Ignore inactive children (and their children)\n            if (c?.activeSelf) {\n                c.InternalSetActive(value);\n            }\n        });\n\n\n    }\n\n    /** The renderer component is used to display the mesh. If no Renderer component exists, it's automatically added */\n    public get renderer(): Renderer {\n        if (!this._renderer) {\n            this._renderer = this.GetComponent(Renderer);\n\n            if (!this._renderer) {\n                this._renderer = this.AddComponent(Renderer);\n            }\n        }\n        return this._renderer;\n    }\n\n    private _renderer: Renderer;\n\n    public get objectPhysics(): ObjectPhysics {\n        if (this._objectPhysics == null) {\n            this._objectPhysics = new ObjectPhysics();\n            this._objectPhysics.Init(this);\n        }\n        return this._objectPhysics;\n    }\n\n    private _objectPhysics: ObjectPhysics;\n\n    static Destroy(obj: SceneObject) {\n        //Destroy all children before destroying other objects\n        if (obj instanceof GameObject && obj.transform) {\n            obj.transform.ser_children.forEach(c => {\n                if (c)\n                    GameObject.Destroy(c);\n            });\n            obj.SetActive(false);\n        } else if (obj instanceof Component) {\n            obj.enabled = false;\n        }\n\n        obj.markedForDestroy = true;\n        Engine.toBeDestroyed.push(obj);\n    }\n\n    //** Editor only function. Should not be called in playmode ever! */\n    static DestroyImmediate(obj: SceneObject) {\n        if (Engine.isPlaying || Engine.isExitingPlayMode)\n        {\n            Debug.Log(\"Destroy Immediate should not be called in Playmode! Reverting to Destroy.\");\n            Destroy(obj);\n            return;\n        }\n        //Destroy all children before destroying other objects\n        if (obj instanceof GameObject && obj.transform) {\n            obj.transform.ser_children.forEach(c => {\n                if (c)\n                    GameObject.DestroyImmediate(c);\n            });\n            obj.SetActive(false);\n        } else if (obj instanceof Component) {\n            obj.enabled = false;            \n        }\n        \n        obj.InternalDestroy();\n    }\n\n    static Instantiate<T extends MonoBehaviour>(objType: string | (new () => T), startPosition: Vector3 = Vector3.Zero()) {\n        //We first create an empty GameObject\n        var gameObject = null;\n        if (typeof objType === \"string\") {\n            gameObject = Prefab.Create(objType + \".prefab\");\n            gameObject.transform.position = startPosition.clone();\n            return gameObject;\n        }\n        else {\n            gameObject = new GameObject();\n\n            //We add this Component as a default one\n            var defaultComponent = gameObject.AddComponent(objType);\n\n            gameObject.name = \"GameObject (\" + defaultComponent.GetType() + \")\";\n\n            gameObject.transform.position = startPosition.clone();\n\n            return defaultComponent;\n        }\n    }\n\n    constructor() {\n        super();\n        this.InternalPreAwake(this);\n        this.name = \"GameObject\";\n\n        //When creating from a SerializedObject, it does not add the Transform default component.\n        if (!Serializer.isCreatingGameObject) {\n            //Every GameObject has a Transform by default\n            this.AddComponent(Transform);\n        }\n\n        this.InternalAwake(this);\n    }\n\n    AddComponent<T extends Component>(objType: (new () => T) | string): T {\n        var newComponent: T = null;\n        if (typeof objType == \"string\") {\n            newComponent = eval(\"new \" + objType + \"()\");\n        } else {\n            newComponent = new objType();\n        }\n        newComponent.InternalPreAwake(this);\n        newComponent.InternalAwake(this);\n        return newComponent;\n    }\n\n    OnCollisionEnter(otherCollider: Collision) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnCollisionEnter(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerEnter(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerEnter(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerStay(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerStay(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerExit(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerExit(otherCollider);\n            }\n        }\n    }\n\n    InternalPreAwake(go: GameObject) {\n        this.components = new Array();\n        super.InternalPreAwake(go);\n        this.activeScene.objs.push(this);\n        this.activeScene.rootObjs.push(this);\n    }\n\n    InternalStart() {\n        if (this.activeInHierarchy) {\n            super.InternalStart();\n        }\n    }\n\n    InternalUpdate() {\n        if (this.activeInHierarchy) {\n            super.InternalUpdate();\n            for (var i = 0; i < this.components.length; i++) {\n                if (this.components[i].enabled) {\n                    this.components[i].InternalUpdate();\n                }\n            }\n        }\n    }\n\n    InternalLateUpdate() {\n        if (this.activeInHierarchy) {\n            super.InternalUpdate();\n            for (var i = 0; i < this.components.length; i++) {\n                if (this.components[i].enabled) {\n                    this.components[i].InternalLateUpdate();\n                }\n            }\n        }\n    }\n\n    OnDrawGizmos() {\n        if (this.activeInHierarchy) {\n            for (var i = 0; i < this.components.length; i++) {\n                if (this.components[i].enabled) {\n                    this.components[i].OnDrawGizmos();\n                }\n            }\n        }\n    }\n\n    OnDrawGizmosSelected() {\n        if (this.activeInHierarchy) {\n            for (var i = 0; i < this.components.length; i++) {\n                if (this.components[i].enabled) {\n                    this.components[i].OnDrawGizmosSelected();\n                }\n            }\n        }\n    }\n\n    InternalFixedUpdate() {\n        if (this.activeInHierarchy) {\n            super.InternalFixedUpdate();\n            for (var i = 0; i < this.components.length; i++) {\n                if (this.components[i].enabled) {\n                    this.components[i].InternalFixedUpdate();\n                }\n            }\n        }\n    }\n\n    InternalDestroy() {\n        for (var i = this.components.length - 1; i >= 0; i--) {\n            this.components[i].InternalDestroy();\n        }\n\n        if (this._objectPhysics) {\n            this._objectPhysics.OnDestroy();\n        }\n\n        //Remove from objects array\n        const index = this.activeScene.objs.indexOf(this);\n        if (index > -1) {\n            this.activeScene.objs.splice(index, 1);\n        }\n\n        const index2 = this.activeScene.rootObjs.indexOf(this);\n        if (index2 > -1) {\n            this.activeScene.rootObjs.splice(index2, 1);\n        }\n    }\n}\n\n/*\nfunction DontDestroyOnLoad (obj : SceneObject)\n{\n    obj.gameObject.destroyOnLoad = false;\n}\n*/"
                    },
                    {
                        "Component.ts": "class Component extends SceneObject {\n    public static isc: boolean = true;\n\n    get name() {\n        return this.gameObject.name;\n    }\n\n    set name(value: string) {\n        this.gameObject.name = value;\n    }\n\n    get isActiveAndEnabled(): boolean {\n        return this.gameObject.activeInHierarchy && this.enabled;\n    }\n\n    //FIXME inheriting classes using a boolean called 'enabled' break this.\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    set enabled(value: boolean) {\n        if (this._enabled === value) {\n            return;\n        }\n        this._enabled = value;\n        if (this.gameObject.activeInHierarchy) {\n            if (value) {\n                this.InternalOnEnable();\n            } else {\n                this.InternalOnDisable();\n            }\n        }\n    }\n\n    private _enabled: boolean = false;\n\n    //Was OnDisable or OnEnable last called?\n    private internalEnabled: boolean = false;\n\n    constructor() {\n        super();\n    }\n\n    InternalPreAwake(go: GameObject) {\n        super.InternalPreAwake(go);\n        go.components.push(this);\n    }\n\n    InternalAwake(go: GameObject) {\n        if (this.gameObject.activeInHierarchy) {              \n            super.InternalAwake(go);\n        }\n        this.enabled = true;\n    }\n\n    InternalSetActive(value: boolean) {\n        //Because this is triggered by SetActive, value represent the state of the GO\n        if (this.enabled) {\n            if (Engine.isPlaying || Engine.IsEditorType(this)) {\n                if (value) {\n                    //Calling this in case the object was disabled at the start (meaning awake was not called)\n                    this.InternalAwake(this.gameObject);\n                    this.InternalOnEnable();\n                } else {\n                    this.InternalOnDisable();\n                }\n            }\n        }\n    }\n\n    InternalDestroy() {\n\n        super.InternalDestroy()\n        //Remove from components array\n        const index = this.gameObject.components.indexOf(this);\n        if (index > -1) {\n            this.gameObject.components.splice(index, 1);\n        }\n    }\n\n    //We avoid OnEnable/OnDisable to be called without the other one being called first.\n    //Sometimes, when objects were destroyed, OnDisable was called before OnEnable was ever called.\n    InternalOnEnable() {\n        if ((Engine.isPlaying || Engine.IsEditorType(this)) && !this.internalEnabled) {\n            try {\n                this.internalEnabled = true;\n                this.OnEnable();\n            } catch (e) { Debug.Log(e, true) };\n        }\n    }\n\n    InternalOnDisable() {\n        if ((Engine.isPlaying || Engine.IsEditorType(this)) && this.internalEnabled) {\n            try {\n                this.internalEnabled = false;\n                this.OnDisable();\n            } catch (e) { Debug.Log(e, true) };\n        }\n    }\n\n    OnEnable() {\n\n    }\n\n    OnDisable() {\n\n    }\n\n    OnButtonClick ()\n    {\n        \n    }\n}\n\n//Attribute that is used to Register a Script as a component\n//This is used as an addition to all scripts that are already registered through the Script name\nfunction RegisterAsComponent(target: Function) {\n    Engine.scripts.push(target.prototype.constructor.name);\n}"
                    },
                    {
                        "MonoBehaviour.ts": "class MonoBehaviour extends Component \r\n{\r\n\r\n}\r\n"
                    },
                    {
                        "Renderer.ts": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Renderer extends Component {\n\n    public onChangedMesh: BABYLON.Observable<number>;\n\n    private meshes: BABYLON.Mesh[] = new Array();\n    @SerializeField\n    private meshName: string = \"\";\n\n    @SerializeField\n    public materialName: string = \"\";\n\n    @SerializeField\n    public scale: number = 1;\n\n    @SerializeField\n    public castShadows: boolean = true;\n\n    private prevCastShadows: boolean = true;\n\n    @SerializeField\n    public receiveShadows: boolean = false;\n\n    @SerializeField\n    public mergeMeshes: boolean = true;\n\n    public get instantiatedEntries () : BABYLON.InstantiatedEntries\n    {\n        return this._instantiatedEntries;\n    }\n\n    private _instantiatedEntries: BABYLON.InstantiatedEntries;\n\n    private prevReceiveShadows: boolean = false;\n\n    private _lastScale: number = 1;\n\n    public material: Material;\n\n    private _isVisible: boolean = true;\n\n    public get isVisible(): boolean {\n        return this._isVisible;\n    }\n\n    public set isVisible(value: boolean) {\n        this._isVisible = value;\n        this.meshes.forEach((mesh) => {\n            mesh.isVisible = value;\n        });\n    }\n\n    public isLoadingMesh: boolean = false;\n    public hasMesh: boolean = false;\n\n    public scaleFactor: BABYLON.Vector3 = BABYLON.Vector3.One();\n\n    private isSprite: boolean = false;\n    private spriteDisplayed: boolean = false;\n    private lastMeshName: string = \"\";\n    private lastMatName: string = \"\";\n\n    \n\n    InternalPreAwake(go) {\n        super.InternalPreAwake(go);\n        //We removed the array of meshes for optimization\n        this.onChangedMesh = new BABYLON.Observable();\n    }\n\n    Start() {\n        this.CheckForMeshUpdate();\n    }\n\n    OnDisable() {\n        this.meshes.forEach(m => {\n            m.setEnabled(false);\n        });\n    }\n\n    OnEnable() {\n        this.meshes.forEach(m => {\n            m.setEnabled(true);\n        });\n    }\n\n    //Check for inspector update.\n    CheckForMeshUpdate() {\n        //If it was deserialized the meshName is set but LoadMesh is never called.\n        if (this.meshName && this.meshName != this.lastMeshName) {\n            this.LoadMesh(this.meshName, this.scale);\n        }\n\n        if (this.materialName && this.materialName != this.lastMatName && this.meshes.length > 0) {\n            this.SetMaterial(Material.Get(this.materialName));\n        }\n    }\n\n    Update() {\n\n        if (this.prevCastShadows != this.castShadows) {\n            this.UpdateShadows();\n            this.prevCastShadows = this.castShadows;\n        }\n        if (this.prevReceiveShadows != this.receiveShadows) {\n            this.UpdateShadows();\n            this.prevReceiveShadows = this.receiveShadows;\n        }\n\n\n        this.CheckForMeshUpdate();\n        this.InternalUpdateMeshes();\n    }\n\n    SetSprite(textureName: string) {\n        this.SetMesh(BABYLON.Mesh.CreatePlane(\"sprite\", 1, Engine.scene));\n\n        //Sprites just have a unique material.\n        this.material = new Material(\"Sprite\");\n        var s = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n        s.diffuseTexture = TextureSystem.GetSprite(textureName);\n        s.diffuseTexture.hasAlpha = true;\n        s.emissiveTexture = s.diffuseTexture;\n        s.backFaceCulling = true;\n        this.material.shader = s;\n\n        //Sprite is always a Single Mesh\n        this.GetMesh().material = this.material.shader;\n\n        this.isSprite = true;\n        this.spriteDisplayed = false;\n    }\n\n    InternalUpdateMeshes() {\n        if (this.isSprite) {\n            if (!this.spriteDisplayed) {\n                var s = this.meshes[0].material as BABYLON.StandardMaterial;\n                this.material.shader = s;\n                var size = s.diffuseTexture.getSize();\n                //We need to check the width because the first time it is loaded this value might be 0\n                if (size.width != 0) {\n                    this.scaleFactor = new BABYLON.Vector3(size.width * 0.01, size.height * 0.01, 1);\n                    this.spriteDisplayed = true;\n                    this.UpdateScaling();\n                }\n            }\n        } else {\n            if (this.scale != this._lastScale) {\n                this.scaleFactor = new BABYLON.Vector3(this.scale, this.scale, this.scale);\n                this.UpdateScaling();\n                this._lastScale = this.scale;\n            }\n        }\n    }\n\n    UpdateScaling() {\n        this.meshes.forEach((mesh: BABYLON.Mesh) => {\n            mesh.scaling = this.scaleFactor;\n        });\n    }\n\n    RemoveMesh() {\n        if (this.meshes) {\n            this.hasMesh = false;\n            this.meshes.forEach((mesh: BABYLON.Mesh) => {\n                try {\n                    //print(\"Removing \" + this.mesh.name + \" to meshToObj with id \" +this.mesh.uniqueId);\n                    Engine.meshToObject.delete(mesh.uniqueId);\n\n                    //This is false so when doing a scene reload the textures persist\n                    mesh.dispose(false, false);\n\n                    //If it's not a material from the material system...\n                    if (!Material.Get(this.materialName)) {\n                        mesh.material?.dispose();\n                    }\n                    this.material = null;\n                } catch (e) {\n                    console.warn(\"Failed to dispose mesh of \" + (this.gameObject ? this.gameObject.name : \"<Unknown>\") + \". Has the array of meshes been modified?\")\n                }\n            });\n            this.meshes = new Array();\n        }\n    }\n\n    SetMesh(newMesh: BABYLON.Mesh | BABYLON.Mesh[]) {\n        //Just in case.\n        this.RemoveMesh();\n\n        if (newMesh instanceof BABYLON.Mesh) {\n            this.SetSingleMesh(newMesh);\n        } else {\n            //TODO Implement this.\n            newMesh.forEach((mesh: BABYLON.Mesh) => {\n                this.SetSingleMesh(mesh);\n            });\n        }\n\n        this.UpdateScaling();\n        this.UpdateShadows();\n        this.hasMesh = true;\n\n       // Debug.Log(this.onChangedMesh.observers.length);\n\n        this.onChangedMesh.notifyObservers(0);\n    }\n\n    private UpdateShadows() {\n        this.meshes.forEach((mesh: BABYLON.Mesh) => {\n            mesh.receiveShadows = this.receiveShadows;\n\n            if (this.castShadows) {\n                Lighting.AddCastingMesh(mesh);\n            } else {\n                Lighting.RemoveCastingMesh(mesh);\n            }\n\n        });\n\n    }\n\n    private SetSingleMesh(newMesh: BABYLON.Mesh) {\n        this.meshes.push(newMesh);\n\n        Engine.meshToObject.set(newMesh.uniqueId, this.gameObject);\n\n        //Meshes get parented to their transform. A mesh should never be moved by itself, but instead the transform component should be used.\n        newMesh.parent = (this.transform.transformNode);\n\n        newMesh.isVisible = true;\n\n        if (this.materialName)\n            this.SetMaterial(Material.Get(this.materialName));\n    }\n\n    listen_onChange = null;\n\n    SetMaterial(newMat: Material) {\n        this.material?.onChange.remove(this.listen_onChange);\n\n        this.material = newMat;\n        this.meshes.forEach(m => {\n            m.material = this.material.shader;\n        });\n        this.listen_onChange = this.material.onChange.add(matType => {\n            this.meshes.forEach(m => {\n                m.material = this.material.shader;\n            });\n            /*\n            if (matType == \"PBR\") {\n                \n            } else if (matType == \"Standard\") {\n\n            } else {\n                Debug.Log(`Material switched to unrecognized shader ${matType}!`);\n            }*/\n        });\n        this.lastMatName = this.materialName;\n    }\n\n    GetMesh(): BABYLON.Mesh {\n        return this.meshes[0];\n    }\n\n    GetMeshes(): BABYLON.Mesh[] {\n        return this.meshes;\n    }\n\n    LoadMesh(meshName: string, loadedScale: number = 1) {\n        this.RemoveMesh();\n        this.isLoadingMesh = true;\n\n        this.meshName = meshName;\n        this.lastMeshName = meshName;\n        this.scaleFactor = new BABYLON.Vector3(loadedScale, loadedScale, loadedScale);\n\n        if (meshName === \"box\" || meshName === \"sphere\") {\n\n            var defaultMesh = [];\n            if (meshName == \"box\") {\n                defaultMesh.push(BABYLON.Mesh.CreateBox(name, 1, Engine.scene));\n            } else {\n                defaultMesh.push(BABYLON.Mesh.CreateSphere(name, 8, 1, Engine.scene));\n            }\n            this.SetMesh(defaultMesh);\n            this.isLoadingMesh = false;\n            return;\n        }\n\n        //NEW STUFF\n\n        var modelUrl = URLResult.Create(meshName, FileType.Model);\n        if (modelUrl.baseUrl == null) {\n            print(\"Could not load mesh \" + meshName + \". Are you sure it exists?\");\n            this.isLoadingMesh = false;\n            return;\n        }\n\n        MeshLoader.Load(meshName, (instantiatedEntries: BABYLON.InstantiatedEntries) => {\n            if (this.markedForDestroy)\n            {\n                \n                return;\n            }\n            \n            this._instantiatedEntries = instantiatedEntries;\n            \n            var meshes = instantiatedEntries.rootNodes as BABYLON.Mesh[];\n            for (var i = 0; i < meshes.length; i++) {\n                meshes[i].isVisible = false;\n            }\n            //Only obj files can merge\n            if (this.mergeMeshes && this.meshName.endsWith(\".obj\")) {\n                this.SetMesh(BABYLON.Mesh.MergeMeshes(meshes, true, true, null, false, false));\n            } else {\n                this.SetMesh(meshes);\n                \n            }\n            this.isLoadingMesh = false;\n        });\n       \n    }\n\n    InternalDestroy() {\n        super.InternalDestroy();\n        this.castShadows = false;\n        this.receiveShadows = false;\n        this.UpdateShadows();\n        this.RemoveMesh();\n    }\n}\n\n"
                    },
                    {
                        "Transform.ts": "@ExecuteInEditMode\nclass Transform extends Component {\n\n    //This is a mesh because the Gizmo system does not like TransformNodes\n    transformNode: BABYLON.AbstractMesh;\n\n    public onPositionChange: BABYLON.Observable<Vector3>;\n    public onParentChange: BABYLON.Observable<Transform>;\n\n\n    @SerializeField\n    protected _position: Vector3;\n\n    @SerializeField\n    protected _eulerAngles: Vector3;\n\n    @SerializeField\n    protected _scale: Vector3;\n\n    public get up () : Vector3 \n    {\n        return Vector3.BtoV(this.transformNode.up);\n    }\n\n    public get right () : Vector3 \n    {\n        return Vector3.BtoV(this.transformNode.right);\n    }\n\n    public get forward () : Vector3 \n    {\n        return Vector3.BtoV(this.transformNode.forward);\n    }\n\n    private _absolutePosition: Vector3 = new Vector3();\n    private _absoluteScale: Vector3 = new Vector3();\n    private _absoluteRotation: Quaternion = new Quaternion();\n    private _absoluteEulerAngles: Vector3 = new Vector3();\n    private _absoluteRadians: Vector3 = new Vector3();\n\n    @SerializeField\n    @HideInInspector\n    uniqueId: string = \"\";\n\n    //ALL rotation is handled through the _rotation Quaternion\n    //E.g. if Radians are changed, Radians > EulerAngles > Quaternion > Mesh\n    //It has to be like that since Rigidbodies in Babylon set the Quaternion rotation\n    //After the Quaternion has been set, this is the only way to rotate objects in Babylon\n    private _radians: Vector3;\n    private _rotation: Quaternion;\n\n    private _children: GameObject[] = new Array();\n\n    PreAwake() {\n        if (this.uniqueId === \"\") {\n            this.uniqueId = uuidv4();\n        }\n\n        if (!this.transformNode) {\n            this.transformNode = new BABYLON.Mesh(this.gameObject.name, Engine.scene);\n        }\n\n        Engine.meshToObject[this.transformNode.uniqueId] = this.gameObject;\n        this.transformNode.reIntegrateRotationIntoRotationQuaternion = true;\n\n        this.transformNode.rotationQuaternion = new BABYLON.Quaternion();\n        this.localPosition = this._position ? this._position.clone() : Vector3.Zero();\n        this.localScale = this._scale ? this._scale.clone() : Vector3.One();\n        var rot = this._eulerAngles ? this._eulerAngles.clone() : Vector3.Zero();\n\n        this.localRotation = new Quaternion(0, 0, 0, 0);\n        this.localEulerAngles = rot;\n\n        this.onPositionChange = new BABYLON.Observable();\n        this.onParentChange = new BABYLON.Observable();\n    }\n\n    Start() {\n\n        //Temp fix for insanely long children lists.\n        //This seems to be caused by prefabs!\n        for (var i = this.ser_children.length - 1; i >= 0; i--) {\n            if (!this.ser_children[i]) {\n                this.ser_children.splice(i, 1);\n            }\n        }\n    }\n\n\n    FixedUpdate() {\n        // if (EditorSelection.HasSelection() && EditorSelection.GetSelection()[0] === this.gameObject)\n        {\n            //     print(this.transform.localPosition);\n        }\n\n        //This seems redundant but it's calling the getter for all these variables\n        //Because our inspector and serializer use the private variables, this needs to be done\n        //This could be optimized (only selected + when serialized as scene) but is a minor performance overhead.\n        this.transform.localPosition;\n        this.transform.localEulerAngles;\n        this.transform.localScale;\n    }\n\n\n    get parent(): Transform {\n        return this._parent;\n    }\n\n    //ONLY for serialization...\n    //getter only, since these will be set when Transforms are added automatically\n    @SerializeField\n    @HideInInspector\n    public get ser_children(): GameObject[] {\n        return this._ser_children;\n    }\n\n    public set ser_children(value: GameObject[]) {\n        //this._ser_children = new Array();\n    }\n\n    public GetAllChildrenRecursively(): GameObject[] {\n        var arr = new Array();\n        this.AddChildren(arr, this.ser_children);\n        return arr;\n    }\n\n    private AddChildren(arr: GameObject[], children: GameObject[]) {\n        children.forEach(t => {\n            arr.push(t);\n            this.AddChildren(arr, t.transform.ser_children);\n        });\n    }\n\n    private _ser_children: GameObject[] = new Array();\n\n    GetSiblingIndex(): number {\n        var c = this.parent ? this.parent.ser_children : SceneManager.GetActiveScene().rootObjs;\n\n        return c.indexOf(this.gameObject);\n    }\n\n    SetSiblingIndex(index: number) {\n        var c = this.parent ? this.parent.ser_children : SceneManager.GetActiveScene().rootObjs;\n        index = Mathf.Clamp(index, 0, c.length);\n\n        const oldIndex = c.indexOf(this.gameObject);\n        //Remove from old position\n        c.splice(oldIndex, 1);\n\n        //Add to new position\n        c.splice(index - 1, 0, this.gameObject);\n\n\n    }\n\n    Find(name: string) {\n        for (var i = 0; i < this.transform.ser_children.length; i++) {\n            var c = this.transform.ser_children[i];\n            if (c) {\n                if (c.name == name) {\n                    return c;\n                }\n                c = c.transform.Find(name);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public SetParent(parent: Transform, worldPositionStays: boolean = true) {\n        //Debug.Log(\"Setting parent of \" + this.name + \" to \" + parent?.name);\n        if (this.transform === parent) {\n            Debug.Log(\"Can't set \" + this.name + \" to it's own parent.\");\n            return;\n        }\n\n        //Already a parent...\n        if (parent === this.parent) {\n            return;\n        }\n\n        //We remove the object from the previous childrern list.\n        if (this._parent) {\n            let x = this._parent.ser_children.indexOf(this.gameObject);\n            this._parent.ser_children.splice(x, 1);\n        } else {\n            let i = SceneManager.GetActiveScene().rootObjs.indexOf(this.gameObject);\n            if (i !== -1) {\n                SceneManager.GetActiveScene().rootObjs.splice(i, 1);\n            }\n        }\n        this._parent = parent;\n\n        if (!this._parent) {\n            if (!this.markedForDestroy) {\n                let i = SceneManager.GetActiveScene().rootObjs.indexOf(this.gameObject);\n                if (i === -1) {\n                    SceneManager.GetActiveScene().rootObjs.push(this.gameObject);\n                }\n            }\n        }\n\n        if (parent?.transformNode.nonUniformScaling) {\n            //Debug.Log(`Parented ${this.name} to non-uniformly scaled ${parent.name}. This is allowed but not recommended as it can lead to strange distortions.`);\n        }\n\n        if (worldPositionStays) {\n            this.transformNode.setParent(parent?.transformNode);\n        } else {\n            this.transformNode.parent = parent?.transformNode;\n        }\n\n        //This array is auto populated when serializing.\n        if (!Serializer.isSettingParent) {\n            parent?.ser_children.push(this.gameObject);\n        }\n\n        this.onParentChange.notifyObservers(parent);\n        //Debug.Log(\"I was set to parent \" + parent?.name, true)\n    }\n\n    private _parent: Transform;\n\n\n    /*\n    Position, rotation and scale are all stored in the mesh. The Transform component\n    is nothing but a wrapper for the user. It will allow the user to easily update\n    the information and set rotation through eulerAngles or radians.\n    */\n\n    /*\n    The event listener system for position, scale and rotation is designed\n    to pick up on changes on the x,y,z components of these Vectors. Through that,\n    users can change one axis of a Vector, which now automatically updates the information\n    in the game.\n    */\n\n\n    // #region position\n    get position(): Vector3 {\n        Vector3.BtoV(this.transformNode.absolutePosition, this._absolutePosition);\n        return this._absolutePosition;\n    }\n\n    set position(value: Vector3) {\n        this._absolutePosition = value;\n\n        this._absolutePosition.onChange.clear();\n\n        this._absolutePosition.onChange.add(() => {\n            this.transformNode.setAbsolutePosition(Vector3.VtoB(this._absolutePosition, new BABYLON.Vector3()));\n            this.onPositionChange?.notifyObservers(this.localPosition);\n        });\n        this._absolutePosition.onChange.notifyObservers(null);\n    }\n\n    get localPosition(): Vector3 {\n        Vector3.BtoV(this.transformNode.position, this._position);\n        return this._position;\n    }\n\n    set localPosition(value: Vector3) {\n\n        this._position = value;\n\n        this._position.onChange.clear();\n\n        this._position.onChange.add(() => {\n            Vector3.VtoB(this._position, this.transformNode.position);\n            this.transformNode.computeWorldMatrix(true);\n            this.onPositionChange?.notifyObservers(this.localPosition);\n        });\n        this._position.onChange.notifyObservers(null);\n    }\n\n    // #endregion    \n\n\n    //#region scale\n    get lossyScale(): Vector3 {\n        Vector3.BtoV(this.transformNode.absoluteScaling, this._absoluteScale);\n        return this._absoluteScale;\n    }\n\n    get localScale(): Vector3 {\n\n        Vector3.BtoV(this.transformNode.scaling, this._scale);\n        return this._scale;\n    }\n\n    set localScale(value: Vector3) {\n        this._scale = value;\n\n        this._scale.onChange.clear();\n\n\n        this._scale.onChange.add(() => {\n            Vector3.VtoB(this._scale, this.transformNode.scaling);\n            this.transformNode.computeWorldMatrix(true);\n        });\n        this._scale.onChange.notifyObservers(null);\n    }\n\n    //#endregion\n\n\n    //#region rotation\n\n    get rotation(): Quaternion {\n        return Quaternion.BtoQ(this.transformNode.absoluteRotationQuaternion, this._absoluteRotation);\n    }\n\n    get eulerAngles(): Vector3 {\n        //This updates the absoluteEulerAngles value\n        return Quaternion.ToEulerAngles(this.rotation, this._absoluteEulerAngles);\n    }\n\n    set eulerAngles(value: Vector3) {\n        this._absoluteEulerAngles?.onChange.clear();\n\n        this._absoluteEulerAngles = value;\n\n        this._absoluteEulerAngles.onChange.add((i) => {\n            let p = this.transformNode.parent;\n            this.transformNode.setParent(null);\n            this.localRotation = Quaternion.Euler(this._absoluteEulerAngles.x, this._absoluteEulerAngles.y, this._absoluteEulerAngles.z);\n            this.transformNode.setParent(p);\n        });\n        this._absoluteEulerAngles.onChange.notifyObservers(null);\n    }\n\n    /*\n    get radians(): Vector3 {\n        //get the eulerAngles\n        this.eulerAngles;\n        this._radians.x = this._absoluteEulerAngles.x * Mathf.Rad2Deg;\n        this._radians.y = this._absoluteEulerAngles.y * Mathf.Rad2Deg;\n        this._radians.z = this._absoluteEulerAngles.z * Mathf.Rad2Deg;\n        return this._radians;\n    }\n    */\n\n    get localEulerAngles(): Vector3 {\n        Quaternion.ToEulerAngles(this.localRotation, this._eulerAngles);\n\n        return this._eulerAngles;\n    }\n\n    set localEulerAngles(value: Vector3) {\n\n        this._eulerAngles = value;\n        //TODO Should this be BEFORE assigning value??\n        this._eulerAngles.onChange.clear();\n\n        this._eulerAngles.onChange.add((index: number) => {\n            //The x eulerAngle needs to be looked at!\n            this.localRotation = Quaternion.Euler(this._eulerAngles.x, this._eulerAngles.y, this._eulerAngles.z, this._rotation);\n        });\n\n        this._eulerAngles.onChange.notifyObservers(null);\n    }\n\n    /*\n    //Radians are untested.\n    get localRadians(): Vector3 {\n        this._radians.x = this.localEulerAngles.x * Mathf.Rad2Deg;\n        this._radians.y = this.localEulerAngles.y * Mathf.Rad2Deg;\n        this._radians.z = this.localEulerAngles.z * Mathf.Rad2Deg;\n\n        return this._radians;\n    }\n\n    set localRadians(value: Vector3) {\n        this._radians = value;\n\n        this._radians.onChange.clear();\n\n        this._radians.onChange.add((index: number) => {\n            switch (index) {\n                case 0:\n                    this.localEulerAngles.x = this._radians.x * Mathf.Rad2Deg;\n                    break;\n                case 1:\n                    this.localEulerAngles.y = this._radians.y * Mathf.Rad2Deg;\n                    break;\n                case 2:\n                    this.localEulerAngles.z = this._radians.z * Mathf.Rad2Deg;\n                    break;\n                default:\n                    this.localEulerAngles.x = this._radians.x * Mathf.Rad2Deg;\n                    this.localEulerAngles.y = this._radians.y * Mathf.Rad2Deg;\n                    this.localEulerAngles.z = this._radians.z * Mathf.Rad2Deg;\n                    break;\n            }\n        });\n        this._radians.onChange.notifyObservers(null);\n    }\n    */\n\n    get localRotation(): Quaternion {\n        return Quaternion.BtoQ(this.transformNode.rotationQuaternion, this._rotation);\n    }\n\n    set localRotation(value: Quaternion) {\n        this._rotation = value;\n\n        this._rotation.onChange.clear();\n\n        this._rotation.onChange.add((i) => {\n            Quaternion.QtoB(this._rotation, this.transformNode.rotationQuaternion);\n            //Force calculate to make sure absolute values are updated\n            this.transformNode.computeWorldMatrix(true);\n        });\n        //Quaternion.QtoB(this._rotation, this.transformNode.rotationQuaternion);\n\n        this._rotation.onChange.notifyObservers(null);\n    }\n\n    TransformVector(vect: Vector3): Vector3 {\n        let matr = new BABYLON.Matrix();\n        let quat = this.transformNode.absoluteRotationQuaternion.clone();\n        quat.toRotationMatrix(matr);\n        let rotatedvect = BABYLON.Vector3.TransformCoordinates(Vector3.VtoB(vect), matr);\n        return Vector3.BtoV(rotatedvect);\n    }\n\n    //#endregion\n\n    public Rotate(xAxis: number, yAxis: number, zAxis: number, space?: BABYLON.Space): BABYLON.TransformNode {\n        this.transformNode.rotate(new BABYLON.Vector3(1, 0, 0), xAxis * Mathf.Deg2Rad, space);\n        this.transformNode.rotate(new BABYLON.Vector3(0, 1, 0), yAxis * Mathf.Deg2Rad, space);\n        let r = this.transformNode.rotate(new BABYLON.Vector3(0, 0, 1), zAxis * Mathf.Deg2Rad, space);\n        this.transformNode.computeWorldMatrix(true);\n        return r;\n    }\n\n    public Translate(x: number, y: number, z: number, space?: BABYLON.Space) {\n        this.transformNode.translate(new BABYLON.Vector3(1, 0, 0), x, space);\n        this.transformNode.translate(new BABYLON.Vector3(0, 1, 0), y, space);\n        this.transformNode.translate(new BABYLON.Vector3(0, 0, 1), z, space);\n        //This is super strange but somehow the last translation gets undone if in the next line the position gets set...\n        //transform.position = transform.position \n        this.transformNode.translate(new BABYLON.Vector3(0, 0, 0), 0, space);\n    }\n\n    private DisposeCurrentTransformNode() {\n        Engine.meshToObject.delete(this.transformNode.uniqueId);\n        this.transformNode.dispose();\n    }\n\n    OnDestroy() {\n        this.onParentChange.clear();\n        this.SetParent(null);\n        this.onPositionChange.clear();\n\n        this.DisposeCurrentTransformNode();\n    }\n}"
                    },
                    {
                        "Animator.ts": "//Animator.ts\n//@ExecuteInEditMode\nclass Animator extends Component {\n\n  //Great source of inspiration https://playground.babylonjs.com/#6I67BL#83\n\n  @SerializeField\n  public defaultAnim: string = \"\";\n\n  private _animationGroups: BABYLON.AnimationGroup[];\n\n  private meshLoadedObserver: BABYLON.Observer<number>;\n\n  public get animationGroups(): BABYLON.AnimationGroup[] {\n    return this._animationGroups;\n  }\n\n  private oneShotAnim: string = null;\n  private loopingAnim: string = null;\n\n  private currAnim: string = null;\n\n  private animWeights: number[];\n\n  private smoothing: number = 1;\n\n  Awake() {\n\n  }\n\n  OnEnable() {\n    this.meshLoadedObserver = this.renderer?.onChangedMesh.add((i) => this.OnMeshLoaded());\n  }\n\n  OnDisable() {\n    this.renderer?.onChangedMesh.remove(this.meshLoadedObserver);\n  }\n\n  public GetCurrentAnimName(): string {\n    return this.currAnim;\n  }\n\n  public PlayLoop(animName: string, transitionTime: number = 0.1) {\n\n    if (animName) {\n      this.loopingAnim = animName;\n      this.smoothing = 1 / (transitionTime == 0 ? 0.00001 : transitionTime);\n    }\n  }\n\n  public Play(animName: string, transitionTime: number = 0.1, overrideCurrent: boolean = true) {\n    if (animName) {\n      let anim = this.GetAnimByName(animName);\n      if (anim) {\n        if (overrideCurrent) {\n          anim.reset();\n        }\n        anim.play(false);\n        this.oneShotAnim = animName;\n        this.smoothing = 1 / (transitionTime == 0 ? 0.00001 : transitionTime);\n      }\n    }\n  }\n\n\n\n  private OnMeshLoaded() {\n    if (this.renderer?.instantiatedEntries) {\n      this.animWeights = new Array();\n      this._animationGroups = this.renderer.instantiatedEntries.animationGroups;\n      let s = this.renderer.instantiatedEntries.skeletons[0];\n\n      for (let i = 0; i < this._animationGroups.length; i++) {\n        let anim = this._animationGroups[i];\n        //\n        this.animWeights.push(0);\n        anim.play(true);\n        anim.setWeightForAllAnimatables(0);\n      }\n\n      if (Engine.isPlaying) {\n        this.PlayLoop(this.defaultAnim);\n      }\n    }\n\n  }\n\n  private GetAnimByName(name: string): BABYLON.AnimationGroup {\n    for (let i = 0; i < this._animationGroups.length; i++) {\n      let anim = this._animationGroups[i];\n      if (anim.name === name) {\n        return anim;\n      }\n    }\n    return null;\n  }\n\n  Update() {\n    this.currAnim = null;\n\n    if (this._animationGroups) {\n\n      if (this.oneShotAnim) {\n        let anim = this.GetAnimByName(this.oneShotAnim);\n\n        if (anim.isPlaying) {\n\n          let animatable = anim.animatables[0];\n          if (animatable.toFrame - animatable.masterFrame > this.smoothing * Time.deltaTime) {\n            this.currAnim = this.oneShotAnim;\n          } else {\n            this.oneShotAnim = null;\n          }\n        } else {\n          this.oneShotAnim = null;\n        }\n      }\n\n      if (!this.currAnim) {\n        this.currAnim = this.loopingAnim;\n      }\n\n      if (this.currAnim) {\n        for (let i = 0; i < this._animationGroups.length; i++) {\n          let anim = this._animationGroups[i];\n\n          if (anim.name === this.currAnim) {\n            this.animWeights[i] = Mathf.Clamp(this.animWeights[i] + this.smoothing * Time.deltaTime, 0, 1);\n          } else {\n            this.animWeights[i] = Mathf.Clamp(this.animWeights[i] - this.smoothing * Time.deltaTime, 0, 1);\n          }\n          anim.setWeightForAllAnimatables(this.animWeights[i]);\n        }\n      }\n\n\n    }\n\n  }\n\n\n}"
                    },
                    {
                        "Camera.ts": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Camera extends MonoBehaviour {\n  public static main: Camera;\n\n\n  public set mode(value: number) {\n    this.bCam.mode = value;\n  }\n\n  public get mode(): number {\n    return this.bCam.mode;\n  }\n\n  public orthoGraphicSize: number = 5;\n\n  //TargetCamera because regular Camera can't update position/rotation\n  public bCam: BABYLON.TargetCamera;\n\n  //This is a bit hacky but that way the camera view doesn't reset in playmode\n  Awake() {\n    if (this.bCam != null) {\n      this.bCam.dispose();\n    }\n    this.bCam = new BABYLON.TargetCamera(\"Camera\", new BABYLON.Vector3(0, 10, 0), Engine.scene);\n\n    this.bCam.viewport = new BABYLON.Viewport(0, 0, 1, 1);\n\n    this.bCam.layerMask = 0;\n\n    //Unshift because we dont want it to be at the top.\n    //If it's on top it will be used for interaction (e.g. picking a mesh through clicking)\n    Engine.scene.activeCameras.unshift(this.bCam);\n\n    Camera.main = this;\n  }\n\n  OnEnable() {\n    this.bCam.layerMask = 2;\n  }\n\n  OnDisable() {\n    this.bCam.layerMask = 0;\n  }\n\n  Update() {\n    this.UpdateRender();\n\n    if (Camera.main.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {\n      var vert = this.orthoGraphicSize;\n      var horz = vert * Engine.current.getScreenAspectRatio();\n      this.bCam.orthoTop = vert;\n      this.bCam.orthoBottom = -vert;\n      this.bCam.orthoLeft = -horz;\n      this.bCam.orthoRight = horz;\n    }\n  }\n\n  public UpdateRender() {\n    if (!this.transform)\n    {\n      return;\n    }\n    /*\n    let p: BABYLON.TransformNode = this.transform.transformNode;\n    let q: BABYLON.Quaternion = BABYLON.Quaternion.Identity();\n    let v: BABYLON.Vector3 = BABYLON.Vector3.Zero();\n    while (p) {\n      q.multiplyInPlace(p.rotationQuaternion);\n      v.addInPlace(p.position);\n      p = p.parent as BABYLON.TransformNode;\n    }\n    \n    this.bCam.rotationQuaternion = q.clone();\n    */\n\n    this.transform.transformNode.computeWorldMatrix(true);\n    this.bCam.rotationQuaternion = this.transform.transformNode.absoluteRotationQuaternion.clone();\n   // Debug.Log(this.bCam.rotationQuaternion);\n    this.bCam.position = this.transform.transformNode.absolutePosition.clone();\n\n\n  }\n\n  OnDestroy() {\n    this.bCam?.dispose();\n  }\n}"
                    },
                    {
                        "Light.ts": "enum LightType {\n  Directional,\n  Spot,\n  Point\n}\n\n@RegisterAsComponent\n@ExecuteInEditMode\nclass Light extends MonoBehaviour {\n  light: BABYLON.ShadowLight;\n\n  @SerializeEnumField(LightType)\n  public lightType = LightType.Directional;\n\n  private prevLightType = LightType.Directional;\n\n  @SerializeField\n  public color: Color = new Color(1, 1, 1);\n\n  @SerializeField\n  public castShadows: boolean = true;\n\n  private prevCastShadows: boolean = true;\n\n  @SerializeField\n  public intensity: number = .7;\n\n  @SerializeField\n  public range: number = 25;\n\n\n\n  @SerializeField\n  public coneAngle: number = 25;\n\n  @SerializeField\n  public exponent: number = 25;\n\n  @SerializeField\n  public shadowFrustrumSize: number = 25;\n\n  @SerializeField\n  public shadowFrustrumLength: number = 25;\n\n\n\n  rot: BABYLON.Vector3;\n\n\n  Awake() {\n    this.UpdateLight();\n  }\n\n  OnEnable() {\n    this.light.setEnabled(true);\n  }\n\n  OnDisable() {\n    this.light.setEnabled(false);\n  }\n\n  private UpdateLight() {\n\n    if (this.light) {\n      Lighting.RemoveLight(this);\n      this.light.dispose();\n    }\n\n\n    var dirLight;\n\n    switch (this.lightType) {\n      case LightType.Directional:\n        dirLight = new BABYLON.DirectionalLight(\"Light\", this.transform.transformNode.forward, Engine.scene);\n\n        break;\n      case LightType.Point:\n        dirLight = new BABYLON.PointLight(\"Light\", this.transform.transformNode.absolutePosition.clone(), Engine.scene)\n        break;\n\n      case LightType.Spot:\n        dirLight = new BABYLON.SpotLight(\"Light\", this.transform.transformNode.forward, this.transform.transformNode.absolutePosition.clone(), this.coneAngle * Mathf.Deg2Rad, this.exponent, Engine.scene)\n\n        break;\n      default:\n        break;\n    }\n\n    dirLight.autoUpdateExtends = false;\n    dirLight.shadowFrustumSize = this.shadowFrustrumSize;\n\n    this.light = dirLight;\n    if (this.castShadows) {\n      Lighting.AddLight(this);\n    }\n\n\n  }\n\n  Update() {\n\n    if (this.lightType != this.prevLightType) {\n      this.prevLightType = this.lightType;\n      this.UpdateLight();\n    }\n\n    if (this.castShadows != this.prevCastShadows) {\n      this.prevCastShadows = this.castShadows;\n      if (this.castShadows) {\n        Lighting.AddLight(this);\n      } else {\n        Lighting.RemoveLight(this);\n      }\n\n    }\n\n    Vector3.VtoB(this.transform.position, this.light.position);\n    this.light.direction = this.transform.transformNode.forward.clone();\n    this.light.intensity = this.intensity;\n    this.light.range = this.range;\n\n    this.light.shadowMaxZ = this.shadowFrustrumLength;\n    //Using the same color since why would you want a single light with\n    //two different light types?...\n    Color.UtoB(this.color, this.light.diffuse);\n    Color.UtoB(this.color, this.light.specular);\n\n    switch (this.lightType) {\n      case LightType.Directional:\n        var dirLight = this.light as BABYLON.DirectionalLight;\n        dirLight.shadowFrustumSize = this.shadowFrustrumSize;\n\n        break;\n      case LightType.Point:\n        var pLight = this.light as BABYLON.PointLight;\n\n        break;\n\n      case LightType.Spot:\n        var sLight = this.light as BABYLON.SpotLight;\n        sLight.exponent = this.exponent;\n        sLight.angle = this.coneAngle * Mathf.Deg2Rad;\n        break;\n      default:\n        break;\n    }\n\n  }\n\n  OnDrawGizmosSelected() {\n    switch (this.lightType) {\n      case LightType.Directional:\n        Gizmos.color = new Color(0.7, 0.7, 0.7);\n        let size = new Vector3(this.shadowFrustrumSize, this.shadowFrustrumSize, this.shadowFrustrumLength);\n        let pos = this.transform.forward.scale(this.shadowFrustrumLength * 0.5).add(this.transform.position);\n        Gizmos.DrawCube(pos, size, this.transform.rotation);\n        Gizmos.color = new Color(1, 1, 1);\n        break;\n      case LightType.Point:\n\n\n        break;\n\n      case LightType.Spot:\n\n        break;\n      default:\n        break;\n    }\n  }\n\n  OnDestroy() {\n    Lighting.RemoveLight(this);\n    this.light?.dispose();\n  }\n}\n\n\n"
                    }
                ]
            },
            {
                "Editor": [
                    {
                        "UnionButton.ts": "class UnionButton extends BABYLON.GUI.Button {\n\n  get textBlock(): BABYLON.GUI.TextBlock {\n    return this._tb;\n  }\n\n  private _tb: BABYLON.GUI.TextBlock;\n\n  constructor(text: string, resizeToText: boolean = true) {\n    super(\"Button_\" + text);\n    this.width = \"100px\";\n    this.height = \"20px\";\n    this.color = UnionEditor.style.darkLineColor.toHexString();\n    this.background = UnionEditor.style.backgroundColor.toHexString();\n\n    this.alpha = 1;\n\n    this.isPointerBlocker = true;\n    // Adding text\n    this._tb = new BABYLON.GUI.TextBlock(name + \"_button\", text);\n    this._tb.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this._tb.paddingTop = \"20%\";\n    this._tb.style = UnionEditor.fontStyle;\n    this._tb.resizeToFit = true;\n\n    this._tb.color = UnionEditor.style.textColor.toHexString();\n\n    this.addControl(this._tb);\n\n    this.onBeforeDrawObservable.add(e => {\n      if (resizeToText) {\n        this.widthInPixels = this._tb.widthInPixels + 20;\n      }\n    });\n\n    var _t = this;\n\n    this.onPointerEnterObservable.add(e => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n    this.onPointerOutObservable.add(e => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n\n    _t.pointerEnterAnimation = function () {\n      _t.background = UnionEditor.style.hoverColor.toHexString();\n    };\n    _t.pointerOutAnimation = function () {\n      _t.background = UnionEditor.style.backgroundColor.toHexString();\n    };\n    _t.pointerDownAnimation = function () {\n      _t.background = UnionEditor.style.darkLineColor.toHexString();\n    };\n    _t.pointerUpAnimation = function () {\n      _t.background = UnionEditor.style.backgroundColor.toHexString();\n    };\n  }\n}\n"
                    },
                    {
                        "MenuButton.ts": "class MenuButton extends UnionButton {\n\n  data: MenuItemData;\n  owner: MenuButtonList;\n  list: MenuButtonList;\n\n  constructor(owner: MenuButtonList, data: MenuItemData) {\n    //Only the top menu resizes\n    super(data.name, owner.owner == null);\n    this.color = UnionEditor.style.backgroundColor.toHexString();\n    this.owner = owner;\n    this.data = data;\n    this.textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.textBlock.style = UnionEditor.fontStyle;\n\n    this.isPointerBlocker = true;\n\n    //Remove the deeper menus when hovering\n    this.onPointerEnterObservable.add(e => {\n\n      owner.children.forEach(c => {\n        var b = c as MenuButton;\n        //We dispose any list since if it's this, a new one will get created\n        //if (b != this)\n        {\n          b.list?.dispose();\n        }\n      });\n\n      //If not top bar\n      if (this.GetTopOwner().isFocused) {\n        this.Expand();\n      }\n    });\n\n\n    this.onPointerClickObservable.add(e => {\n\n      if (!this.GetTopOwner().isFocused) {\n        this.GetTopOwner().isFocused = true;\n        this.Expand();\n      } else {\n        if (this.owner == this.GetTopOwner())\n        {\n          this.Collapse();\n        }\n      }\n\n      if (data.functionToCall) {\n        data.functionToCall();\n        //Clear all menus when clicking somewhere\n        this.Collapse();\n      }\n    });\n\n    this.onDisposeObservable.add(e => {\n      this.list?.dispose();\n    });\n  }\n\n  IsTopButton() {\n    return this.owner == this.GetTopOwner();\n  }\n\n  Collapse() {\n    var owner = this.GetTopOwner() as MenuButtonList;\n    owner.children.forEach(c => {\n      var b = c as MenuButton;\n      b.list?.dispose();\n    })\n    owner.isFocused = false;\n  }\n\n  Expand() {\n    if (this.data.children.length > 0) {\n      this.list = new MenuButtonList(this, this.data.children);\n      var pos = this.getLocalCoordinates(new BABYLON.Vector2()).negate();\n\n      UnionEditor.editorUI.addControl(this.list);\n      this.list.leftInPixels += pos.x;\n      this.list.topInPixels += pos.y;\n    }\n  }\n\n  GetTopOwner(): MenuButtonList {\n    return this.owner.GetTopOwner();\n  }\n}\n\n\nfunction MenuItem(value: string) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    {\n      if (!MenuItemData.main) {\n        MenuItemData.main = new MenuItemData();\n      }\n      MenuItemData.main.AddChild(value.split(\"/\"), descriptor.value);\n    }\n  }\n}\n\nclass MenuItemData {\n  static main: MenuItemData;\n\n  name: string;\n  functionToCall: any;\n  children: MenuItemData[] = new Array();\n\n  constructor() {\n\n  }\n\n  AddChild(items: string[], functionToCall: any) {\n    //Pop off the start of items\n    var name = items.shift();\n\n    var child = null;\n    //If the child already exists, we group them under the same MenuItemData\n    this.children.forEach(c => {\n      if (c.name == name) {\n        child = c;\n      }\n    });\n\n    //If it didn't exist yet in the menu, we add it here\n    if (!child) {\n      child = new MenuItemData();\n      this.children.push(child);\n      child.name = name;\n    }\n\n    //If there are more submenus...\n    if (items.length > 0) {\n      child.AddChild(items, functionToCall);\n    } else {\n      child.functionToCall = functionToCall;\n    }\n  }\n}"
                    },
                    {
                        "Windows": [
                            {
                                "EditorSystem.ts": "//script:EditorSystem\n\nclass EditorSystem\n{\n  constructor ()\n  {\n    UnionEditor.editorSystems.push(this);\n  }\n\n  OnGUI ()\n  {\n\n  }\n}"
                            },
                            {
                                "EditorWindow.ts": "class EditorWindow extends EditorSystem\n{\n  private sv : BABYLON.GUI.ScrollViewer;\n\n  public main : BABYLON.GUI.StackPanel;\n\n  public background : BABYLON.GUI.Rectangle;\n\n  constructor()\n  {\n    super();    \n    this.background = new BABYLON.GUI.Rectangle(\"EditorWindow\");\n    \n    this.background.cornerRadius = 0;\n    this.background.background = UnionEditor.style.backgroundColor.toHexString();\n    this.background.color = UnionEditor.style.backgroundColor.toHexString();\n    \n\n    this.background.onPointerEnterObservable.add((evt) => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n\n    this.background.onPointerOutObservable.add((evt) => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n\n    this.Refresh();\n  }\n\n  OnGUI()\n  {\n\n  }\n\n  Refresh()\n  {\n    this.main?.dispose();\n    this.sv?.dispose();\n\n    this.main = new BABYLON.GUI.StackPanel();\n    \n    this.main.fontSize = 14;\n\n    this.main.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.main.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    \n    this.sv = new BABYLON.GUI.ScrollViewer();\n    //this.sv.color = UnionEditor.style.darkLineColor.toHexString();\n    this.sv.thickness = 0;\n    this.background.addControl(this.sv);\n\n    this.sv.addControl(this.main);\n    this.sv.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.sv.barSize = 15;\n\n    \n    \n    //UnionEditor.editorUI.addControl(this.background);\n  }\n}"
                            },
                            {
                                "TopBarWindow.ts": "class TopBarWindow extends EditorWindow {\n\n  public static items: string[];\n\n  private topPanel: BABYLON.GUI.StackPanel;\n  private breadCrumbs: BABYLON.GUI.StackPanel;\n  public breadCrumbsText: BABYLON.GUI.Button;\n\n  @MenuItem(\"GameObject/UI/Button\")\n  static CreateButton() {\n    let canvas = TopBarWindow.GetOrCreateCanvas();\n    \n    let buttonGo = TopBarWindow.CreateChildOfGO(canvas.transform);\n    buttonGo.name = \"Button\";\n    buttonGo.AddComponent(Button);\n    buttonGo.AddComponent(UIImage);\n    let labelGo = TopBarWindow.CreateChildOfGO(buttonGo.transform);\n    labelGo.name = \"Text\";\n\n    let label = labelGo.AddComponent(Label);\n    label.text = \"Click me!\";\n  }\n\n  \n  @MenuItem(\"GameObject/UI/Canvas\")\n  static CreateCanvas() {\n    let canvas = Instantiate(NewCanvas);\n    canvas.name = \"Canvas\";    \n  }\n\n  @MenuItem(\"GameObject/UI/Text\")\n  static CreateText() {\n    let canvas = TopBarWindow.GetOrCreateCanvas();\n    \n    let labelGo = TopBarWindow.CreateChildOfGO(canvas.transform);\n    labelGo.name = \"Text\";\n    labelGo.AddComponent(Label); \n  }\n\n  @MenuItem(\"GameObject/UI/Image\")\n  static CreateImage() {\n    let canvas = TopBarWindow.GetOrCreateCanvas();\n    \n    let imageGo = TopBarWindow.CreateChildOfGO(canvas.transform);\n    imageGo.name = \"Image\";\n    imageGo.AddComponent(UIImage); \n  }\n\n  private static GetOrCreateCanvas () : NewCanvas\n  {\n    let canvas = null;\n    if (EditorSelection.HasSelection()) {\n      canvas = EditorSelection.GetSelection()[0].GetComponentInParent(NewCanvas);\n    }\n    \n    if (!canvas) {\n      canvas = GameObject.FindObjectOfType(NewCanvas);\n    }\n    if (!canvas) {\n      canvas = Instantiate(NewCanvas);\n      canvas.name = \"Canvas\";\n    }\n    return canvas;\n  }\n\n  @MenuItem(\"GameObject/Create Empty\")\n  static CreateEmpty() {\n    var go: GameObject = new GameObject();\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/Create Child\")\n  static CreateEmptyChildMenuItem() {\n    TopBarWindow.CreateEmptyChild();\n  }\n\n  static CreateEmptyChild(): GameObject {\n    let parent = null;\n    if (EditorSelection.HasSelection()) {\n      parent = EditorSelection.GetSelection()[0].transform;\n    }\n    let go = TopBarWindow.CreateChildOfGO(parent);\n    EditorSelection.SetSelectedGameObject(go);\n    return go;\n  }\n\n  private static CreateChildOfGO(parent: Transform): GameObject {\n    let go: GameObject = new GameObject();\n    go.transform.SetParent(parent, false);\n    if (go.GetComponentInParent(NewCanvas)) {\n      go.AddComponent(RectTransform);\n    }\n    return go;\n  }\n\n\n  @MenuItem(\"GameObject/Create Parent\")\n  static CreateParent() {\n    var go: GameObject = new GameObject();\n    go.transform.position = EditorSelection.GetCenterPoint();\n    var first = true;\n    EditorSelection.GetSelection().forEach(sgo => {\n      if (first) {\n        first = false;\n        var i: number = sgo.transform.GetSiblingIndex();\n        go.transform.SetParent(sgo.transform.parent, true);\n        go.transform.SetSiblingIndex(i + 1);\n      }\n      sgo.transform.SetParent(go.transform, true);\n    });\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/3D Object/Cube\")\n  static CreateBox() {\n    var go: GameObject = new GameObject();\n    go.name = \"Box\";\n    go.AddComponent(Renderer).LoadMesh(\"box\");\n    go.AddComponent(BoxCollider);\n    go.AddComponent(Rigidbody);\n    if (EditorSelection.HasSelection()) {\n      // go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/3D Object/Sphere\")\n  static Sphere() {\n    var go: GameObject = new GameObject();\n    go.name = \"Sphere\";\n    go.AddComponent(Renderer).LoadMesh(\"sphere\");\n    go.AddComponent(SphereCollider);\n    go.AddComponent(Rigidbody);\n    if (EditorSelection.HasSelection()) {\n      // go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/Light\")\n  static CreateLight() {\n    var go: GameObject = new GameObject();\n    go.name = \"Light\";\n    go.AddComponent(Light);\n    go.transform.position = new Vector3(10, 14, -10);\n    go.transform.localEulerAngles = new Vector3(45, -45, 0);\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/Camera\")\n  static CreateCamera() {\n    var go: GameObject = new GameObject();\n    go.name = \"Camera\";\n    go.AddComponent(Camera);\n    go.transform.position = new Vector3(0, 0, -10);\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n\n\n  constructor() {\n    super()\n    this.background.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.background.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.background.width = \"100%\";\n    this.background.heightInPixels = 60;\n    this.background.background = UnionEditor.style.darkLineColor.toHexString();\n\n    this.breadCrumbs = new BABYLON.GUI.StackPanel();\n\n    this.breadCrumbs.isVertical = false;\n    this.breadCrumbs.height = \"20px\";\n\n    this.breadCrumbs.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.breadCrumbs.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n    this.breadCrumbsText = UnionEditor.CreateButton(\"Breadcrumbs\");\n    this.breadCrumbsText.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.breadCrumbsText.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n    this.breadCrumbsText.color = UnionEditor.style.backgroundColor.toHexString();\n    this.breadCrumbsText.width = \"200px\";\n    this.breadCrumbs.addControl(this.breadCrumbsText);\n\n    this.background.addControl(this.breadCrumbs);\n    var buttonList = new MenuButtonList(null, MenuItemData.main.children, false);\n    this.breadCrumbs.addControl(buttonList);\n    //buttonList.paddingLeftInPixels += 100;\n\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n        buttonList.children.forEach(c => {\n          var b = c as MenuButton;\n          b.list?.dispose();\n        });\n        buttonList.isFocused = false;\n      }\n    });\n\n    this.topPanel = new BABYLON.GUI.StackPanel();\n\n    this.topPanel.isVertical = false;\n    this.topPanel.height = \"40px\";\n\n    this.topPanel.fontSize = \"14px\";\n    this.topPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.topPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    this.background.addControl(this.topPanel);\n\n    var playButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"PlayButton\", \"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.play_button.png\");\n    playButton.width = \"25px\";\n    playButton.height = \"25px\";\n    playButton.image.width = \"20px\";\n    playButton.image.height = \"20px\";\n    playButton.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    playButton.background = UnionEditor.style.backgroundColor.toHexString();\n    playButton.color = UnionEditor.style.darkLineColor.toHexString();\n    playButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    playButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    playButton.topInPixels = 10;\n    this.topPanel.addControl(playButton);\n\n    playButton.onPointerClickObservable.add(() => {\n      //The scene saves when going into PlayMode\n      if (!Engine.isPlaying) {\n        SceneManager.SaveCurrentScene();\n      }\n\n      if (!Engine.isPlaying) {\n        Engine.SwitchToPlayMode();\n        playButton.background = UnionEditor.style.selectionColor.toHexString();\n\n      } else {\n        Engine.StopPlayMode();\n        playButton.background = UnionEditor.style.backgroundColor.toHexString();\n      }\n      EditorSelection.SetSelectedGameObject(null);\n    });\n\n\n    var pauseButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"PlayButton\", \"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.pause_button.png\");\n    pauseButton.width = \"25px\";\n    pauseButton.height = \"25px\";\n    pauseButton.image.width = \"20px\";\n    pauseButton.image.height = \"20px\";\n    pauseButton.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    pauseButton.background = UnionEditor.style.backgroundColor.toHexString();\n    pauseButton.color = UnionEditor.style.darkLineColor.toHexString();\n    pauseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    pauseButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    pauseButton.topInPixels = 10;\n    this.topPanel.addControl(pauseButton);\n\n    pauseButton.onPointerClickObservable.add(() => {\n      print(\"Not yet implemented\");\n    });\n\n  }\n\n}\n"
                            },
                            {
                                "HierarchyWindow.ts": "class HierarchyWindow extends EditorWindow\n{\n  public static refresh : boolean = false;\n\n  public static idToItem: Record<number, HierarchyItem> \n\n  //This needs to be stored separately since when the HierarchyItems are destroyed on refresh,\n  //this info needs to be retained\n  public static idToCollapse: Record<number, HierarchyItem> \n\n  lastObjects : number = 0;\n\n  private list : HierarchyList;\n\n  constructor ()\n  {\n    super();\n    HierarchyWindow.idToItem = {};\n    HierarchyWindow.idToCollapse = {};\n    SceneManager.onSceneLoaded.add((ev: Scene) => {\n      this.DisplaySceneHierarchy();\n      //HierarchyWindow.refresh = true;\n    });\n  }\n\n\n  OnGUI ()\n  {\n    super.OnGUI();\n    var scene = SceneManager.GetActiveScene();\n    //Simple 'isDirty' check\n    if (scene != null && (scene.objs.length != this.lastObjects || HierarchyWindow.refresh))\n    {\n      HierarchyWindow.refresh = false;\n      this.lastObjects = scene.objs.length;\n      this.DisplaySceneHierarchy();\n    }\n  }\n\n  DisplaySceneHierarchy ()\n  {\n    this.Refresh();\n    this.list?.dispose();\n    var scene = SceneManager.GetActiveScene();\n\n    this.list = new HierarchyList(scene.rootObjs, 0, null);\n    this.main.addControl(this.list);\n  }\n}"
                            },
                            {
                                "EditorWindowContainer.ts": "class EditorWindowContainer extends BABYLON.GUI.StackPanel {\n\n  public windows: BABYLON.GUI.Container[] = new Array();\n  public dividers: EditorWindowDivider[] = new Array();\n\n  constructor(isVertical: boolean, sizes: number[] = null) {\n    super(\"EditorWindowContainer\")\n    this.isVertical = isVertical;\n\n    Engine.editorScene.onAfterRenderObservable.addOnce(e => {\n      this.UpdateSizes(sizes);\n    });\n  }\n\n  UpdateSizes(sizes: number[]) {\n    var pos = 0;\n    var i = 0;\n    this.dividers.forEach(d => {\n      if (this.isVertical) {\n        if (sizes?.length > i) {\n          pos = sizes[i];\n        } else {\n          pos += this.heightInPixels / this.windows.length;\n        }\n        d.topInPixels = pos;\n      } else {\n        if (sizes?.length > i) {\n          pos = sizes[i];\n        } else {\n          pos += this.widthInPixels / this.windows.length;\n        }\n        d.leftInPixels = pos;\n      }\n      i++;\n    });\n\n    this.UpdatePosition();\n  }\n\n  //** Updates the position of the windows */\n  UpdatePosition() {\n    //this.dividers[0].topInPixels = this.heightInPixels * 0.5;\n    var lastDividerPos = 0;\n    for (var i = 0; i < this.windows.length; i++) {\n      var w = this.windows[i];\n      var newHeight;\n      if (i < this.dividers.length) {\n        newHeight = (this.isVertical ? this.dividers[i].topInPixels : this.dividers[i].leftInPixels) - lastDividerPos;\n        lastDividerPos += (newHeight + EditorWindowDivider.dividerHeight);\n      } else {\n        newHeight = (this.isVertical ? this.heightInPixels : this.widthInPixels) - lastDividerPos;\n      }\n      if (this.isVertical) {\n        w.heightInPixels = newHeight;\n      } else {\n        w.widthInPixels = newHeight;\n      }\n\n    };\n  }\n\n  public Add(window: BABYLON.GUI.Container) {\n    if (this.windows.length > 0) {\n      var divider = new EditorWindowDivider(this);\n      this.dividers.push(divider);\n    }\n\n    //We have to set these to pixels (as opposed to default perc.) to avoid errors in the console\n    if (this.isVertical) {\n      window.heightInPixels = 0;\n    } else {\n      window.widthInPixels = 0;\n    }\n\n    this.addControl(window);\n    this.windows.push(window);\n  }\n}\n\n\nclass EditorWindowDivider extends BABYLON.GUI.Rectangle {\n\n  static dividerHeight = 3;\n\n  isOverThisControl: boolean = false;\n  pointerObserver: BABYLON.Observer<any>;\n  isAdjustingByMouse: boolean = false;\n\n  private pointerOffset: BABYLON.Vector2 = new BABYLON.Vector2();\n\n  constructor(owner: EditorWindowContainer) {\n    super(\"EditorWindowDivider\");\n    owner.addControl(this);\n    if (owner.isVertical) {\n      this.width = \"100%\";\n      this.heightInPixels = EditorWindowDivider.dividerHeight;\n    } else {\n      this.widthInPixels = EditorWindowDivider.dividerHeight;\n      this.height = \"100%\";\n    }\n    this.thickness = 0;\n    this.background = UnionEditor.style.darkLineColor.toHexString();\n\n    this.onPointerEnterObservable.add((ev) => {\n      EditorUI.SetPointerOverEditor(this);\n      Engine.cursor = owner.isVertical ? \"row-resize\" : \"col-resize\";\n      this.isOverThisControl = true;\n    });\n    this.onPointerOutObservable.add((ev) => {\n      EditorUI.RemovePointerOverEditor(this);\n      Engine.cursor = \"default\";\n      this.isOverThisControl = false;\n    });\n\n    this.pointerObserver = Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.isOverThisControl) {\n            this.isAdjustingByMouse = true;\n            this.pointerOffset.x = pointerInfo.event.x - this.leftInPixels;\n            this.pointerOffset.y = pointerInfo.event.y - this.topInPixels;\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERUP:\n          this.isAdjustingByMouse = false;\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n          if (this.isAdjustingByMouse) {\n            if (owner.isVertical) {\n              this.topInPixels = pointerInfo.event.y - this.pointerOffset.y;\n            } else {\n              this.leftInPixels = pointerInfo.event.x - this.pointerOffset.x;\n            }\n\n            owner.UpdatePosition();\n          }\n          break;\n      }\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      Engine.scene.onPointerObservable.remove(this.pointerObserver);\n    })\n  }\n}"
                            },
                            {
                                "GameViewWindow.ts": "class GameViewWindow extends EditorWindow {\n\n    constructor() {\n        super();\n        this.background.alpha = 0;\n        this.background.isPointerBlocker = false;\n\n\n    }\n\n    OnGUI ()\n    {\n        if (Camera.main)\n        {\n            EditorHelpers.MapCamToGUIContainer(Camera.main.bCam, this.background);\n        }\n    }\n}\n"
                            },
                            {
                                "SceneViewWindow.ts": "class SceneViewWindow extends EditorWindow {\n\n    cam: BABYLON.ArcRotateCamera;\n\n    isAttached: boolean = false;\n\n    constructor() {\n        super();\n        this.background.alpha = 0;\n        this.background.isPointerBlocker = false;\n\n        this.cam = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), Engine.scene);\n\n\n        this.cam.attachControl(Engine.canvas, true);\n        this.cam.layerMask = 4;\n        this.cam.wheelPrecision = 10\n        this.cam.minZ = 0.01;\n        this.cam.maxZ = 10000;\n        this.isAttached = true;\n\n        Engine.scene.activeCameras.push(this.cam);\n\n        var keyDownObserver = Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt => {\n            if (evt.sourceEvent.keyCode == 70 /*f-key*/) {\n\n                var hasSelection = EditorSelection.GetSelection()?.length > 0;\n                if (hasSelection) {\n                    this.cam.target = Vector3.VtoB(EditorSelection.GetCenterPoint(), new BABYLON.Vector3());\n                }\n            }\n        }));\n\n        this.cam.onDisposeObservable.addOnce(e => {\n            Engine.scene.actionManager.unregisterAction(keyDownObserver);\n        });\n\n        Engine.scene.onPointerObservable.add(pointer => {\n            var evt = pointer.event as WheelEvent;\n            //  this.zoomTarget -= evt.deltaY * this.zoomSpeed;\n            // this.zoomTarget = Mathf.Clamp(this.zoomTarget, this.minZoom, this.maxZoom);\n            if (Input.GetKey(KeyCode.Shift))\n            {\n                this.cam.wheelPrecision += evt.deltaY * 0.01;\n                Debug.Log(this.cam.wheelPrecision);              \n            }\n            \n            }, BABYLON.PointerEventTypes.POINTERWHEEL, false);\n\n    }\n\n    OnGUI() {\n        this.UpdateCamViewport();\n\n        var posRatio = Engine.editorScene.pointerY / Engine.canvas.height;\n\n        if (posRatio < 0.5) {\n            Engine.scene.activeCamera = this.cam;\n        } else {\n            if (Camera.main) {\n                Engine.scene.activeCamera = Camera.main.bCam;\n            }\n        }\n\n        //Detach on Update\n        if (this.isAttached && (EditorUI.GetPointerOverEditor() !== this || !Input.GetKey(KeyCode.Alt))) {\n            this.cam.detachControl(Engine.canvas);\n            this.isAttached = false;\n        }\n        else if (!this.isAttached && (EditorUI.GetPointerOverEditor() === this && Input.GetKey(KeyCode.Alt))) {\n            this.cam.attachControl(Engine.canvas, true);\n            this.isAttached = true;\n        }\n    }\n\n    UpdateCamViewport() {\n        EditorHelpers.MapCamToGUIContainer(this.cam, this.background);     \n    }\n}\n"
                            }
                        ]
                    },
                    {
                        "MenuButtonList.ts": "class MenuButtonList extends BABYLON.GUI.StackPanel {\n\n  owner : MenuButton;\n  isFocused : boolean;\n\n  constructor(owner : MenuButton, itemDataList: MenuItemData[], isVertical = true) {\n    super();\n    this.owner = owner;\n    this.isVertical = isVertical;\n    //The first line after the main top bar should be moved down\n    if (owner?.owner && !owner.owner.isVertical)\n    {\n      this.topInPixels += 20;\n    } else {\n      this.leftInPixels += 100;\n    }\n\n    if (isVertical) {\n      this.widthInPixels = 100;\n      \n    } else {\n      this.heightInPixels = 20;\n    }\n    this.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    itemDataList.forEach(itemData => {\n      var button = new MenuButton(this, itemData);\n      this.addControl(button);\n    });\n\n  }\n\n  GetTopOwner () : MenuButtonList {\n    if (!this.owner)\n      return this;\n    return this.owner.GetTopOwner();\n  }\n}\n"
                    },
                    {
                        "EditorHelpers.ts": "class EditorHelpers {\n    public static MapCamToGUIContainer(cam: BABYLON.Camera, cont: BABYLON.GUI.Control) {\n        var width = UnionEditor.editorUI.getSize().width;\n        var height = UnionEditor.editorUI.getSize().height;\n        var p = 0;//p is a minor pixel padding\n        var x = (cont.centerX - cont.widthInPixels * 0.5 + p) / width;\n        var y = 1 - ((cont.centerY + cont.heightInPixels * 0.5 - p) / height);\n        cam.viewport = new BABYLON.Viewport(\n            x,\n            y,\n            (cont.widthInPixels - p * 2) / width,\n            (cont.heightInPixels - p * 2) / height);\n    }\n}\n\n@RegisterAsComponent\nclass FPSCounter extends MonoBehaviour {\n    nFrameUpdateInterval: number = 10;\n\n    text: TextLabel;\n    average: number = 0;\n    nFramesSinceUpdate: number = 0;\n\n    Start() {\n        this.text = this.gameObject.AddComponent(TextLabel);\n        this.transform.position.x = 4;\n        this.transform.position.y = 4;\n    }\n\n    Update() {\n        this.nFramesSinceUpdate++;\n        this.average += Time.deltaTime;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval) {\n            this.text.text = \"FPS: \" + (1 / (this.average / this.nFrameUpdateInterval)).toFixed(0);\n            this.average = 0;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n\n    OnDestroy() {\n\n    }\n}\n\n\nclass ObjCounter extends MonoBehaviour {\n\n    nFrameUpdateInterval: number = 1;\n\n    text: TextLabel;\n    nFramesSinceUpdate: number = 0;\n\n    Start() {\n        this.text = this.gameObject.AddComponent(TextLabel);\n        this.transform.position.x = 4;\n        this.transform.position.y = 4.5;\n    }\n\n    Update() {\n        this.nFramesSinceUpdate++;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval) {\n            this.text.text = \"Objs \" + SceneManager.GetActiveScene().objs.length;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n\n}"
                    },
                    {
                        "EditorGizmos.ts": "class EditorGizmos extends EditorSystem {\n  //gizmoManager: BABYLON.GizmoManager;\n\n  private gizmoMode: Mode;\n\n  private prevMode: Mode;\n\n  //Since the GizmoManager requires a mesh to attach the pivot to, we will just use a dummy Mesh\n  private dummyMesh: BABYLON.Mesh;\n\n  private canSelect: boolean;\n\n  private isMoving: boolean;\n  private isRotating: boolean;\n  private isScaling: boolean;\n\n  private lastPos: BABYLON.Vector3 = new BABYLON.Vector3();\n  private lastRot: BABYLON.Vector3 = new BABYLON.Vector3();\n\n  constructor() {\n    super()\n\n    this.dummyMesh = new BABYLON.Mesh(\"GizmoDummyMesh\", Engine.scene);\n\n\n    // Initialize GizmoManager\n    // Engine.gizmoManager = new BABYLON.GizmoManager(Engine.scene);\n    // Initialize all gizmos\n    Engine.gizmoManager.positionGizmoEnabled = true;\n    Engine.gizmoManager.attachToMesh(this.dummyMesh);\n\n    Engine.gizmoManager.keepDepthUtilityLayer.setRenderCamera(UnionEditor.sceneView.cam);\n    Engine.gizmoManager.utilityLayer.setRenderCamera(UnionEditor.sceneView.cam);\n    Engine.gizmoManager.attachToMesh(this.dummyMesh);\n    Engine.gizmoManager.usePointerToAttachGizmos = false;\n\n    //Need to enable once to access gizmos\n    Engine.gizmoManager.positionGizmoEnabled = true;\n    Engine.gizmoManager.rotationGizmoEnabled = true;\n    Engine.gizmoManager.scaleGizmoEnabled = true;\n\n    Engine.gizmoManager.clearGizmoOnEmptyPointerEvent = false;\n\n    Engine.gizmoManager.gizmos.scaleGizmo.sensitivity = 10;\n\n    Engine.gizmoManager.gizmos.positionGizmo.onDragStartObservable.add((ev) => {\n      this.lastPos = this.dummyMesh.position.clone();\n      this.isMoving = true;\n    });\n    Engine.gizmoManager.gizmos.positionGizmo.onDragEndObservable.add((ev) => {\n      this.isMoving = false;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    Engine.gizmoManager.gizmos.rotationGizmo.onDragStartObservable.add((ev) => {\n      this.lastRot = this.dummyMesh.rotationQuaternion.toEulerAngles().clone();\n      this.isRotating = true;\n    });\n    Engine.gizmoManager.gizmos.rotationGizmo.onDragEndObservable.add((ev) => {\n      this.isRotating = false;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    Engine.gizmoManager.gizmos.scaleGizmo.onDragStartObservable.add((ev) => {\n      this.lastPos = this.dummyMesh.scaling.clone();\n      this.isScaling = true;\n    });\n    Engine.gizmoManager.gizmos.scaleGizmo.onDragEndObservable.add((ev) => {\n      this.isScaling = false;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    Engine.gizmoManager.positionGizmoEnabled = false;\n    Engine.gizmoManager.rotationGizmoEnabled = false;\n    Engine.gizmoManager.scaleGizmoEnabled = false;\n\n    this.gizmoMode = Mode.Translate;\n\n    Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.canSelect) {\n            var pickResult = Engine.scene.pick(Engine.scene.pointerX, Engine.scene.pointerY);\n            var go: GameObject = null;\n            if (pickResult.hit) {\n              var mesh = pickResult.pickedMesh;\n              go = !mesh?.parent ? null : Engine.meshToObject[mesh.parent.uniqueId];\n              go = EditorSelection.GetPrefabParent(go);\n            }\n            if (Input.GetKey(KeyCode.Control)) {\n              EditorSelection.ToggleSelectedGameObject(go);\n            } else {\n              if (go) {\n                EditorSelection.SetSelectedGameObject(go);\n\n              } else {\n                EditorSelection.SetSelectedGameObject(null);\n              }\n            }\n\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n\n          break;\n      }\n    });\n\n\n  }\n\n  OnGUI() {\n    var selection = EditorSelection.GetSelection();\n\n    var hasSelection = selection?.length > 0;\n    if (hasSelection) {\n\n      if (this.isMoving) {\n        //How much the gizmo moved\n        var offset = this.dummyMesh.position.subtract(this.lastPos);\n\n        selection.forEach(go => {\n          if (!go.prefabParent || go.prefabParent == go) {\n            //For some reason I need to set the entire Vector. The change is not recognized otherwise? 0_o\n            let newPos = new Vector3(\n              go.transform.position.x + offset.x,\n              go.transform.position.y + offset.y,\n              go.transform.position.z + offset.z\n            );\n            if (Engine.isPlaying) {\n              //Bugfix: To avoid the gizmo moving the object in it's offset position every frame\n              let c = go.GetComponent(Collider);\n              if (c) {\n                 newPos.subtractInPlace(c.GetGizmoCenter());\n              }\n            }\n            go.transform.position = newPos;\n          }\n        });\n\n        this.lastPos = this.dummyMesh.position.clone();\n      }\n      else {\n       // let centerPoint = EditorSelection.GetCenterPoint();\n        //Debug.Log(centerPoint);\n        Vector3.VtoB(EditorSelection.GetCenterPoint(), this.dummyMesh.position);\n      }\n      if (this.isRotating) {\n        var offset2 = this.dummyMesh.rotationQuaternion.toEulerAngles().subtract(this.lastRot)\n\n        selection.forEach(go => {\n          if (!go.prefabParent || go.prefabParent == go) {\n            //We set each individual value so the inspector displays it properly\n            go.transform.localEulerAngles.x = go.transform.localEulerAngles.x + offset2.x * Mathf.Rad2Deg;\n            go.transform.localEulerAngles.y = go.transform.localEulerAngles.y + offset2.y * Mathf.Rad2Deg;\n            go.transform.localEulerAngles.z = go.transform.localEulerAngles.z + offset2.z * Mathf.Rad2Deg;\n          }\n\n        });\n\n        this.lastRot = this.dummyMesh.rotationQuaternion.toEulerAngles().clone();\n      } else {\n        //Just use the rotation of the first selected object...\n        this.dummyMesh.rotationQuaternion = EditorSelection.GetSelection()[0].transform.transformNode.absoluteRotationQuaternion.clone();\n      }\n\n      if (this.isScaling) {\n        var offset3 = this.dummyMesh.scaling.subtract(this.lastPos)\n\n        selection.forEach(go => {\n          if (!go.prefabParent || go.prefabParent == go) {\n            go.transform.localScale.x = go.transform.localScale.x + offset3.x;\n            go.transform.localScale.y = go.transform.localScale.y + offset3.y;\n            go.transform.localScale.z = go.transform.localScale.z + offset3.z;\n          }\n        });\n\n        this.lastPos = this.dummyMesh.scaling.clone();\n      }\n    }\n\n\n    Engine.gizmoManager.positionGizmoEnabled = this.gizmoMode == Mode.Translate && hasSelection;\n    Engine.gizmoManager.rotationGizmoEnabled = this.gizmoMode == Mode.Rotate && hasSelection;\n    Engine.gizmoManager.scaleGizmoEnabled = this.gizmoMode == Mode.Scale && hasSelection;\n    Engine.gizmoManager.boundingBoxGizmoEnabled = false;\n\n    if (Input.GetKeyDown(KeyCode.W)) {\n      this.gizmoMode = Mode.Translate;\n    }\n\n    if (Input.GetKeyDown(KeyCode.E)) {\n      this.gizmoMode = Mode.Rotate;\n    }\n\n    if (Input.GetKeyDown(KeyCode.R)) {\n      this.gizmoMode = Mode.Scale;\n    }\n\n    if (EditorUI.GetPointerOverEditor() === UnionEditor.sceneView && !Input.GetKey(KeyCode.Alt)) {\n      this.canSelect = true;\n      //Engine.gizmoManager.clearGizmoOnEmptyPointerEvent = false;\n      //Engine.gizmoManager.usePointerToAttachGizmos = false;\n    } else {\n      this.canSelect = false;\n      //Engine.gizmoManager.clearGizmoOnEmptyPointerEvent = true;\n      //Engine.gizmoManager.usePointerToAttachGizmos = true;\n\n    }\n\n    if (Input.GetKeyDown(KeyCode.Escape)) {\n      EditorSelection.SetSelectedGameObject(null);\n    }\n\n  }\n\n}\n\nenum Mode {\n  Translate,\n  Rotate,\n  Scale\n}"
                    },
                    {
                        "EditorSelection.ts": "class EditorSelection extends EditorSystem {\n  constructor() {\n    super();\n    EditorSelection.onSelected = new BABYLON.Observable();\n\n    UnionEditor.editorUI.onClipboardObservable.add((ev) => {\n\n      // Copy listener\n      // if (ev.type === BABYLON.ClipboardEventTypes.COPY) {\n      // EditorSelection.Copy();\n      //  }\n      // Paste listener\n      //   if (ev.type === BABYLON.ClipboardEventTypes.PASTE) {\n      //  EditorSelection.Paste();\n      //  }\n\n    });\n\n    Engine.scene.onKeyboardObservable.add((keybrd) => {\n      if (keybrd.event.ctrlKey && keybrd.type == BABYLON.KeyboardEventTypes.KEYDOWN) {\n        if (keybrd.event.key === \"d\") {\n          if (EditorSelection.HasSelection()) {\n            keybrd.event.preventDefault();\n            let copyData = EditorSelection.CopySub();\n            let parent = EditorSelection.GetSelection()[0].transform.parent;\n            EditorSelection.PasteSub(copyData, parent);\n          }\n        }\n        if (keybrd.event.key === \"c\") {\n          EditorSelection.Copy();\n        }\n        if (keybrd.event.key === \"v\") {\n          EditorSelection.Paste();\n        }\n      }\n\n\n    });\n  }\n\n  private static copyDataString = \"UNION_COPY_DATA_\";\n\n  @MenuItem(\"Edit/Copy\")\n  private static Copy() {\n    if (EditorSelection.HasSelection()) {\n      let copyData = EditorSelection.CopySub();\n      navigator.clipboard.writeText(EditorSelection.copyDataString + copyData);\n    }\n\n  }\n\n  @MenuItem(\"Edit/Paste\")\n  private static async Paste() {\n\n    let clipboardData = await navigator.clipboard.readText();\n    if (clipboardData.startsWith(EditorSelection.copyDataString)) {\n      let selectionData = clipboardData.substring(EditorSelection.copyDataString.length);\n      if (selectionData) {\n        let parent = null;\n        if (EditorSelection.HasSelection()) {\n          parent = EditorSelection.GetSelection()[0].transform;\n        }\n        EditorSelection.PasteSub(selectionData, parent);\n      }\n    }\n  }\n\n  private static CopySub(): string {\n    if (EditorSelection.HasSelection()) {\n      let obj = new SerializedSelectionData();\n      obj.selected = EditorSelection.GetSelection();\n      let data = Serializer.ToJSON(obj, false);\n      return data;\n    }\n    return null;\n  }\n\n  private static PasteSub(jsonData, newParent: Transform = null): SerializedSelectionData {\n    EditorSelection.SetSelectedGameObject(null);\n\n    let obj: SerializedSelectionData;\n    try {\n      //We try since we don't know what the exact jsonData is.\n      Serializer.generatingNewGUIDs = true;\n      obj = Serializer.FromJSON(jsonData);\n      Serializer.generatingNewGUIDs = false;\n\n    } catch (e) {\n      print(e)\n      //If something is pasted from the clipboard that's not a GameObject, just ignore.\n    } finally {\n      if (newParent) {\n        //We uncollapse the new parent (which will show once the parenting is done)\n        HierarchyWindow.idToCollapse[newParent.uniqueId] = false;\n      }\n      obj.selected.forEach(clone => {\n        EditorSelection.AddSelectedGameObject(clone);\n        clone.transform.SetParent(newParent, false);\n      });\n\n      return obj;\n    }\n  }\n\n\n  private static selected: GameObject[] = new Array();\n\n  public static onSelected: BABYLON.Observable<SelectionData>\n\n\n  public static IsSelected(value: GameObject, includeParent: boolean = false): boolean {\n    while (!this.IsSelectedSelf(value)) {\n      if (!includeParent || !value.transform.parent) {\n        return false;\n      }\n      //Check if the parent is selected instead\n      value = value.transform.parent.gameObject;\n    }\n    return true;\n  }\n\n  private static IsSelectedSelf(value: GameObject) {\n    return this.selected.indexOf(value) > -1;\n  }\n\n  public static HasSelection(): boolean {\n    return this.GetSelection().length > 0;\n  }\n\n  public static currentSelectedGameObject;\n\n  public static GetSelection(): GameObject[] {\n    return this.selected;\n  }\n\n  public static GetCenterPoint(): Vector3 {\n    var v = new Vector3();\n    this.selected.forEach((s: GameObject) => {\n      let rect = s.GetComponent(RectTransform);\n      if (rect) {\n        v.x += rect.pickMesh.absolutePosition.x;\n        v.y += rect.pickMesh.absolutePosition.y;\n        v.z += rect.pickMesh.absolutePosition.z;\n      } else {\n        v.x += s.transform.position.x;\n        v.y += s.transform.position.y;\n        v.z += s.transform.position.z;\n        //Otherwise a collider on runtime gives an offset to the gizmo. This is to Undo that.\n        if (Engine.isPlaying) {\n          let c = s.GetComponent(Collider);\n          if (c) {\n            v.subtractInPlace(c.GetGizmoCenter());\n          }\n        }\n      }\n    });\n    v.x /= this.selected.length;\n    v.y /= this.selected.length;\n    v.z /= this.selected.length;\n    return v;\n  }\n\n  public static ToggleSelectedGameObject(go: GameObject) {\n    if (EditorSelection.IsSelected(go)) {\n      EditorSelection.RemoveSelectedGameObject(go);\n    } else {\n      EditorSelection.AddSelectedGameObject(go);\n    }\n  }\n\n  public static AddSelectedGameObject(params: GameObject | GameObject[]) {\n    if (!params)\n      return;\n\n    if (params instanceof GameObject)\n      params = new Array(params);\n\n    params.forEach(value => {\n      //value = this.GetSelectableParent(value);\n      if (this.selected.indexOf(value) == -1) {\n        this.selected.push(value);\n        this.onSelected.notifyObservers({ obj: value, isSelected: true });\n      }\n    });\n  }\n\n  public static GetPrefabParent(v: GameObject) {\n    if (!v)\n      return null;\n    if (v.prefabParent)\n      return v.prefabParent;\n    return v;\n  }\n\n  public static RemoveSelectedGameObject(params: GameObject | GameObject[]) {\n    if (!params)\n      return;\n\n    if (params instanceof GameObject)\n      params = new Array(params);\n\n    params.forEach(value => {\n      const index = this.selected.indexOf(value);\n      if (index > -1) {\n        this.selected.splice(index, 1);\n        this.onSelected.notifyObservers({ obj: value, isSelected: false });\n      }\n    });\n  }\n\n  private static ClearSelection() {\n    //Clear old selection\n    this.selected.forEach((s: GameObject) => {\n      this.onSelected.notifyObservers({ obj: s, isSelected: false });\n    });\n\n    this.selected = new Array();\n  }\n\n  public static SetSelectedGameObject(params: GameObject | GameObject[]) {\n    this.ClearSelection();\n\n    this.AddSelectedGameObject(params);\n  }\n}\n\nclass SelectionData {\n  obj: BaseObject;\n  isSelected: boolean;\n}\n\nclass SerializedSelectionData {\n  @SerializeField\n  selected: GameObject[];\n}\n"
                    },
                    {
                        "UnionEditor.ts": "\nclass UnionEditor {\n\n  public static style: EditorStyle;\n\n  public static editorUI: BABYLON.GUI.AdvancedDynamicTexture;\n\n  public static sceneView: SceneViewWindow;\n  public static gameView: GameViewWindow;\n\n  public static editorSystems: EditorSystem[];\n\n  public static fontStyle: BABYLON.GUI.Style;\n  public static fontStyleBold: BABYLON.GUI.Style;\n\n  private static uiCam: BABYLON.TargetCamera;\n\n  private static topBar: TopBarWindow;\n  private static leftBar: EditorWindowContainer;\n\n  private static rightBar: EditorWindowContainer;\n\n  public static CreateButton(name: string): BABYLON.GUI.Button {\n    var button = new UnionButton(name);\n    return button;\n  }\n\n  public static CreateCheckbox(name: string = \"Checkbox\"): BABYLON.GUI.Checkbox {\n    var cBox = new BABYLON.GUI.Checkbox(name);\n    cBox.paddingLeftInPixels = 2;\n    cBox.paddingRightInPixels = 2;\n    cBox.width = \"15px\";\n    cBox.height = \"10px\";\n    cBox.color = \"white\";\n    cBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    return cBox;\n  }\n\n  public static CreateInputText(name: string = \"InputText\"): BABYLON.GUI.InputText {\n    var vInput = new BABYLON.GUI.InputText();\n    vInput.style = UnionEditor.fontStyle;\n    vInput.margin = \"2px\";\n    vInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    vInput.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    vInput.width = \"100px\";\n    vInput.height = \"20px\";\n    vInput.color = UnionEditor.style.textColor.toHexString();\n    vInput.thickness = 0;\n    vInput.onFocusSelectAll = true;\n    return vInput;\n  }\n\n  public static SetTitle(name: string) {\n    this.topBar.breadCrumbsText.textBlock.text = name;\n  }\n\n  private static mainPanel: EditorWindowContainer;\n\n  private static defaultInspectorWidth = 270;\n\n\n\n  public static Init() {\n    this.style = new EditorStyle();\n\n    this.editorSystems = new Array();\n\n    //Here to render the User Interface\n    this.uiCam = new BABYLON.TargetCamera(\"uiCam\", new BABYLON.Vector3(999999, 0, 999999), Engine.editorScene);\n    this.uiCam.viewport = new BABYLON.Viewport(0, 0, 1, 1);\n    this.uiCam.attachControl(Engine.canvas, true);\n\n    Engine.editorScene.activeCameras.push(this.uiCam);\n\n    this.editorUI = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\", true, Engine.editorScene);\n    this.editorUI.layer.layerMask = 1;\n    this.editorUI.renderAtIdealSize = true;\n    this.editorUI.registerClipboardEvents();\n\n\n    this.fontStyle = new BABYLON.GUI.Style(this.editorUI);\n    this.fontStyle.fontSize = 12;\n    this.fontStyle.fontFamily = \"Roboto\";\n\n    this.fontStyleBold = new BABYLON.GUI.Style(this.editorUI);\n    this.fontStyleBold.fontSize = 13;\n    this.fontStyleBold.fontWeight = \"bold\";\n    this.fontStyleBold.fontFamily = \"Roboto\";\n\n    var mainStack = new BABYLON.GUI.StackPanel();\n    mainStack.height = \"100%\";\n    UnionEditor.editorUI.addControl(mainStack);\n\n    this.topBar = new TopBarWindow();\n    mainStack.addControl(this.topBar.background);\n\n    this.mainPanel = new EditorWindowContainer(false, [UnionEditor.editorUI.getSize().width - this.defaultInspectorWidth]);\n    mainStack.addControl(this.mainPanel);\n    this.mainPanel.width = \"100%\";\n\n    var leftBar = new EditorWindowContainer(true);\n    leftBar.height = \"100%\";\n    this.mainPanel.Add(leftBar);\n\n    this.sceneView = new SceneViewWindow();\n    leftBar.Add(this.sceneView.background);\n    this.gameView = new GameViewWindow();\n    leftBar.Add(this.gameView.background);\n    this.leftBar = leftBar;\n\n    var rightBar = new EditorWindowContainer(true);\n    rightBar.height = \"100%\";\n    this.mainPanel.Add(rightBar);\n\n    new EditorSelection();\n    new EditorGizmos();\n\n    //TODO clean this up. Should windows inherit from Container/Rectangle?\n    rightBar.Add(new HierarchyWindow().background);\n    rightBar.Add(new InspectorWindow().background);\n    this.rightBar = rightBar;\n    Undo.Init();\n  }\n\n  static prevWidth = 0;\n  static prevHeight = 0;\n\n  static updateNextFrame = 0;\n\n  public static Update() {\n\n    if (this.editorUI.getSize().width != this.prevWidth || this.editorUI.getSize().height != this.prevHeight) {\n      this.prevWidth = this.editorUI.getSize().width;\n      this.prevHeight = this.editorUI.getSize().height;\n      this.updateNextFrame = 0;\n    }\n    if (this.updateNextFrame <= 2) {\n      this.updateNextFrame++;\n    }\n    //We need wait two frames for the width to update.\n    if (this.updateNextFrame === 2) {\n      this.mainPanel.heightInPixels = this.prevHeight - this.topBar.background.heightInPixels;\n      let inspectorWidth = this.rightBar.widthInPixels;\n      this.mainPanel.UpdateSizes([this.prevWidth - inspectorWidth]);\n\n    }\n\n\n    if (Input.GetKeyDown(KeyCode.Delete)) {\n      //Prevent deleting objects while in a textfield\n      if (!this.editorUI.focusedControl) {\n        var sel = EditorSelection.GetSelection();\n        EditorSelection.SetSelectedGameObject(null);\n        sel.forEach(c => {\n          Destroy(c);\n        });\n\n      }\n\n\n    }\n\n    this.editorSystems.forEach((window: EditorWindow) => {\n      window.OnGUI();\n    });\n  }\n}\n\nclass EditorStyle {\n\n  //Unity grey\n  backgroundColor = new BABYLON.Color3(0.219607843, 0.219607843, 0.219607843);\n  componentBackgroundColor = new BABYLON.Color3(0.2431372549, 0.2431372549, 0.2431372549);\n  lineColor = new BABYLON.Color4(0, 0, 0, 0);\n  semiDarkLineColor = new BABYLON.Color3(0.19215686274, 0.19215686274, 0.19215686274);\n  darkLineColor = new BABYLON.Color3(0.1, 0.1, 0.1);\n  textColor = new BABYLON.Color3(0.8, 0.8, 0.8);\n  greyedOutColor = new BABYLON.Color3(0.368627451, 0.368627451, 0.368627451);\n\n  selectedTextColor = new BABYLON.Color3(1, 1, 1);\n  selectionColor = new BABYLON.Color3(0.17254902, 0.364705882, 0.529411765);\n  selectionGreyedOutColor = new BABYLON.Color3(0.239215686, 0.28627451, 0.376470588);\n\n  hoverColor = new BABYLON.Color3(0.270588235, 0.270588235, 0.270588235);\n  buttonColor = new BABYLON.Color3(0.34509803921, 0.34509803921, 0.34509803921);\n}\n\n"
                    },
                    {
                        "HierarchyItem.ts": "\nclass BaseHierarchyItem {\n\n    background: BABYLON.GUI.Rectangle;\n    parentList: HierarchyList;\n\n    constructor(parentList: HierarchyList) {\n        this.parentList = parentList;\n        this.background = new BABYLON.GUI.Rectangle(\"HierarchyItem\");\n        this.background.color = UnionEditor.style.backgroundColor.toHexString();\n        this.background.width = \"100%\";\n        //Needs to block the pointer for the Gizmos to work.\n        this.background.isPointerBlocker = true;\n    }\n\n    OnReleased() {\n\n    }\n}\n\n\nclass HierarchyItem extends BaseHierarchyItem {\n\n    public static justClicked: HierarchyItem = null;\n\n    public onChange: BABYLON.Observable<string>;\n    public onSelect: BABYLON.Observable<boolean>;\n\n    //Tweakables\n    itemHeight: number = 17;\n\n    maxDoubleClickDelay: number = 0.3;\n\n    //Gameplay Vars\n    public static currentDraggedItem: HierarchyItem = null;\n    public static currentHoveredItem: BaseHierarchyItem = null;\n\n    lastClickTime: number;\n    isSelected: boolean;\n    obj: GameObject;\n    //Don't set this directly, but use SetCollapse instead...\n    isCollapsed = true;\n\n    //References\n    public p: BABYLON.GUI.StackPanel;\n    private collapseButton: BABYLON.GUI.Button;\n    childrenList: HierarchyList;\n\n    private nameField: BABYLON.GUI.TextBlock;\n\n    constructor(parentList: HierarchyList, obj: GameObject) {\n        super(parentList);\n\n        this.obj = obj;\n\n        this.onChange = new BABYLON.Observable();\n        this.onSelect = new BABYLON.Observable();\n\n        this.p = new BABYLON.GUI.StackPanel();\n        this.p.width = \"100%\";\n        this.p.heightInPixels = this.itemHeight;\n        this.p.isVertical = true;\n        this.p.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT\n\n        var item = new BABYLON.GUI.Container();;\n        item.width = \"100%\";\n        item.height = \"20px\";\n        //item.isVertical = false;\n        this.p.addControl(item);\n\n        if(!obj.transform)\n        {            \n            Debug.Log(\"Object \" + obj.name + \" has no transform!\");\n            return;\n        }\n\n        HierarchyWindow.idToItem[obj.transform.uniqueId] = this;\n\n        if (obj.transform.ser_children.length > 0) {\n            this.collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n            this.collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n            this.collapseButton.width = \"20px\";\n            this.collapseButton.color = UnionEditor.style.lineColor.toHexString();\n            this.collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n            this.background.addControl(this.collapseButton);\n\n            this.collapseButton.onPointerUpObservable.add((evt) => {\n                this.SetCollapse(!this.isCollapsed);\n            });\n        }\n\n        this.nameField = new BABYLON.GUI.TextBlock(\"\", obj.name);\n        this.nameField.style = UnionEditor.fontStyle;\n        this.nameField.paddingLeft = \"25px\";\n        //this.nameField.color = obj.prefabParent ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.textColor.toHexString();\n        this.nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n        this.background.addControl(this.nameField);\n\n\n        var nameInput: BABYLON.GUI.InputText = null;\n\n        this.background.onPointerDownObservable.add((ev) => {\n            HierarchyItem.currentDraggedItem = this;\n            HierarchyItem.currentHoveredItem = this;\n        });\n\n        //This pointerUp is called when releasing a the pointer \n        //but NOT on the object the poitner is released, but rather where it was released from\n        this.background.onPointerUpObservable.add((ev) => {\n            var hover = HierarchyItem.currentHoveredItem;\n\n            if (!hover) {\n\n                //If not hovering over itself\n            } else if (this != hover) {\n                hover.OnReleased();\n                HierarchyWindow.refresh = true;\n            }\n\n            HierarchyItem.currentDraggedItem = null;\n        });\n\n        Engine.scene.onPointerObservable.add((pointerInfo) => {\n            if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n                if (this != HierarchyItem.currentDraggedItem)\n                    return;\n            }\n        });\n\n        this.background.onPointerEnterObservable.add((ev) => {\n            if (HierarchyItem.currentDraggedItem) {\n\n                if (HierarchyItem.currentDraggedItem != this) {\n                    HierarchyItem.currentHoveredItem = this;\n                    this.background.background = UnionEditor.style.hoverColor.toHexString();\n                }\n            }\n        });\n\n        this.background.onPointerOutObservable.add((ev) => {\n            if (HierarchyItem.currentHoveredItem == this) {\n                HierarchyItem.currentHoveredItem = null;\n                if (!EditorSelection.IsSelected(this.obj)) {\n                    this.background.background = UnionEditor.style.backgroundColor.toHexString();\n                }\n            }\n        });\n\n\n        this.background.onPointerClickObservable.add((ev) => {\n            HierarchyItem.justClicked = this;\n            var clickDelay = Time.time - this.lastClickTime;\n            //Double click\n            if (clickDelay < this.maxDoubleClickDelay) {\n\n                if (nameInput == null) {\n                    nameInput = new BABYLON.GUI.InputText();\n                    nameInput.text = this.nameField.text;\n                    nameInput.width = 1;\n                    nameInput.height = 1;\n                    nameInput.color = UnionEditor.style.selectedTextColor.toHexString();\n                    nameInput.textHighlightColor = UnionEditor.style.selectionColor.toHexString();\n                    nameInput.onFocusSelectAll = true;\n                        \n                    nameInput.style = UnionEditor.fontStyle;\n\n                    this.background.addControl(nameInput);\n                    UnionEditor.editorUI.moveFocusToControl(nameInput);\n                    nameInput.onBlurObservable.add((ev) => {\n                        this.nameField.text = nameInput.text;\n                        nameInput.dispose();\n                        nameInput = null;\n                        obj.name = this.nameField.text;\n                        this.onChange.notifyObservers(obj.name);\n                    });\n                }\n                //Single click\n            } else {\n                this.onSelect.notifyObservers(this.isSelected);\n            }\n\n            this.lastClickTime = Time.time;\n\n        });\n\n        item.addControl(this.background);\n        item.paddingBottomInPixels = -3;\n        item.paddingTopInPixels = -3;\n        EditorSelection.onSelected.add((data: SelectionData) => {\n            if (this.obj === data.obj) {\n                this.SetSelected(data.isSelected);\n            } else {\n                this.ExpandIfChildSelected(data.obj, data.obj)\n            }\n        });\n\n        let collapsed = HierarchyWindow.idToCollapse[obj.transform.uniqueId];\n        if (collapsed === undefined)\n            collapsed = true;\n        this.SetCollapse(collapsed);\n        this.SetSelected(EditorSelection.IsSelected(obj));\n\n        let update = Engine.editorScene.onBeforeRenderObservable.add(e => {\n            if (this.isSelected) {\n                this.nameField.color = UnionEditor.style.selectedTextColor.toHexString();\n            } else if (obj.prefabParent) {\n                this.nameField.color = this.obj.activeInHierarchy ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.selectionGreyedOutColor.toHexString();\n            } else {\n                this.nameField.color = this.obj.activeInHierarchy ? UnionEditor.style.textColor.toHexString() : UnionEditor.style.greyedOutColor.toHexString();\n            }\n\n\n\n\n        });\n\n        this.background.onDisposeObservable.addOnce(e => {\n            Engine.editorScene.onBeforeRenderObservable.remove(update);\n        });\n    }\n\n    ExpandIfChildSelected(obj, original) {\n\n        if (!obj) {\n            return;\n        }\n        if (this.obj === obj) {\n            if (this.obj !== original) {\n                //I need to find a way to expand the parent\n                this.SetCollapse(false);\n                if (this.childrenList) {\n                    this.childrenList.items.forEach(c => {\n                        c.ExpandIfChildSelected(obj, original);\n                    });\n                }\n            }\n            return;\n        }\n\n        if (!obj.transform.parent)\n            return;\n\n        return this.ExpandIfChildSelected(obj.transform.parent.gameObject, original);\n    }\n\n\n    SetCollapse(value: boolean) {\n        //Can't collapse if it has no children\n        if (value == this.isCollapsed || this.obj.transform.ser_children.length === 0 || !this.collapseButton)\n            return;\n\n        this.isCollapsed = value;\n        HierarchyWindow.idToCollapse[this.obj.transform.uniqueId] = value;\n        this.collapseButton.textBlock.text = this.isCollapsed ? \">\" : \"v\";\n        if (this.isCollapsed) {\n            //We collapse all children before we collapse a parent\n            this.childrenList.items.forEach(item => {\n                item.SetCollapse(true);\n            });\n            this.childrenList.dispose();\n            this.AddToHeight(-this.obj.transform.ser_children.length);\n        } else {\n            //TODO Clean this up! The HierarchyWindow shouldn't clean the child list\n            this.obj.transform.ser_children = this.obj.transform.ser_children.filter(function (el) {\n                return el != null;\n            });\n\n            this.childrenList = new HierarchyList(this.obj.transform.ser_children, this.parentList.tabSize, this);\n            this.p.addControl(this.childrenList);\n            this.AddToHeight(this.obj.transform.ser_children.length);\n        }\n    }\n\n    public AddToHeight(nElements: number) {\n        this.p.heightInPixels += nElements * (this.itemHeight + 5); //5 because of HierarchySplitItemWidth <- FIX THIS!\n        this.p.heightInPixels += nElements > 0 ? 5 : -5;\n        if (this.parentList.parentItem) {\n            this.parentList.parentItem.AddToHeight(nElements);\n        }\n    }\n\n    OnReleased() {\n        //After releasing, parent all selected objects to here.\n        EditorSelection.GetSelection().forEach(go => {\n            go.transform.SetParent(this.obj.transform, true);\n        });\n    }\n\n    public ExpandRecursively() {\n        if (this.parentList.parentItem.isCollapsed) {\n            this.parentList.parentItem.ExpandRecursively();\n        }\n        this.SetCollapse(false);\n    }\n\n    SetSelected(value: boolean) {\n        this.isSelected = value;\n        if (value) {\n            this.background.background = UnionEditor.style.selectionColor.toHexString();\n\n\n            //No point in doing this since HierarchyItems don't exist when collapsed...\n            //this.parentList.parentItem.ExpandRecursively();\n\n        } else {\n            this.background.background = UnionEditor.style.backgroundColor.toHexString();\n            //this.nameField.color = this.obj.prefabParent ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.textColor.toHexString();\n        }\n    }\n}\n\nclass HierarchySplitItem extends BaseHierarchyItem {\n\n    siblingIndex: number;\n\n    constructor(parentList: HierarchyList, siblingIndex: number) {\n        super(parentList);\n\n        this.siblingIndex = siblingIndex;\n\n        this.background.heightInPixels = 5;\n        this.background.color = UnionEditor.style.lineColor.toHexString();\n\n        this.background.onPointerEnterObservable.add((ev) => {\n            if (HierarchyItem.currentDraggedItem) {\n                HierarchyItem.currentHoveredItem = this;\n                this.background.background = UnionEditor.style.selectionColor.toHexString();\n            }\n        });\n\n        this.background.onPointerOutObservable.add((ev) => {\n            if (HierarchyItem.currentHoveredItem == this) {\n                HierarchyItem.currentHoveredItem = null;\n                this.background.background = UnionEditor.style.lineColor.toHexString();\n            }\n        });\n    }\n\n    //The SplitItem returns it's parent since that will be the new parent for a dragged on object\n    OnReleased() {\n        //After releasing, parent all objects to my parent and set the sibling index\n        //TODO The splitter item should also know the parent\n        EditorSelection.GetSelection().forEach(go => {\n            var i = go.transform.GetSiblingIndex();\n            var parentChange = go.transform.parent != this.parentList?.parentItem?.obj.transform;\n\n            go.transform.SetParent(this.parentList?.parentItem?.obj.transform, true);\n\n            //Only if the parent didn't change, and we moved it from a higher spot to a lower spot\n            //We have to adjust our sibling index\n            if (parentChange || i > this.siblingIndex) {\n                this.siblingIndex += 1;\n            }\n\n            go.transform.SetSiblingIndex(this.siblingIndex);\n        });\n    }\n}\n\n"
                    },
                    {
                        "EditorUI.ts": "//TODO is this Editor only?\nclass EditorUI {\n  //A variety of objects (such as EditorWindows, but also ColorPicker) use this\n  //private static objs: any[] = new Array();\n\n  private static curr: any;\n\n  public static SetPointerOverEditor(obj: any) {\n    //Debug.Log(\"Pointer over \" + this.curr)\n    this.curr = obj;\n    /*\n    if (this.objs.indexOf(obj) == -1) {\n      this.objs.push(obj);\n    }\n    */\n  }\n\n  public static RemovePointerOverEditor(obj: any) {\n    //Debug.Log(\"Pointer not over \" + this.curr);\n    if (this.curr === obj) {\n      this.curr = null;\n    }\n    /*\n    var i = this.objs.indexOf(obj);\n    if (i != -1) {\n      this.objs.splice(i, 1);\n    }\n    */\n  }\n\n  public static GetPointerOverEditor () : any{\n    return this.curr;\n  }\n\n  public static IsPointerOverEditor(): boolean {\n    return this.curr != null;\n\n    //return this.objs.length != 0;\n  }\n\n}"
                    },
                    {
                        "Gizmos.ts": "//Gizmos.ts\nclass Gizmos {\n\n  public static color : Color;\n\n  //Increase to get more round gizmos\n  private static gizmoPrecision = 150;\n\n  //This is a magical number to allow for the drawn gizmos to be the same as the radius in engine\n  private static radiusMultiplier = 75;\n\n  private static gizmos: BABYLON.LinesMesh[];\n\n  public static Init() {\n    Gizmos.gizmos = new Array();\n\n    Engine.scene.onAfterRenderObservable.add(() => {\n      for (let i = Gizmos.gizmos.length - 1; i >= 0; i--) {\n        let gizmo = Gizmos.gizmos.splice(i, 1)[0];\n        gizmo.dispose();\n      }\n\n    });\n  }\n\n  public static DrawCube(position: Vector3, size: Vector3, rotation?: Quaternion) {\n    let min = new BABYLON.Vector3(-size.x*0.5, - size.y*0.5,  - size.z*0.5);\n    let max = new BABYLON.Vector3(size.x*0.5,  size.y*0.5,  size.z*0.5);\n    let myPoints = [\n      min,\n      new BABYLON.Vector3(max.x, min.y, min.z),\n      new BABYLON.Vector3(max.x, min.y, max.z),\n      new BABYLON.Vector3(min.x, min.y, max.z),\n      min,\n      new BABYLON.Vector3(min.x, max.y, min.z),\n      new BABYLON.Vector3(max.x, max.y, min.z),\n      new BABYLON.Vector3(max.x, min.y, min.z),\n      new BABYLON.Vector3(max.x, max.y, min.z),\n      max,\n      new BABYLON.Vector3(max.x, min.y, max.z),\n      max,\n      new BABYLON.Vector3(min.x, max.y, max.z),\n      new BABYLON.Vector3(min.x, min.y, max.z),\n      new BABYLON.Vector3(min.x, max.y, max.z),\n      new BABYLON.Vector3(min.x, max.y, min.z)\n    ];\n\n    let boundingBoxLines = BABYLON.MeshBuilder.CreateLines(\"lines\", { points: myPoints }, Engine.scene);\n    boundingBoxLines.color = Color.UtoB(Gizmos.color);\n    boundingBoxLines.position = Vector3.VtoB(position);\n    boundingBoxLines.rotationQuaternion = Quaternion.QtoB(rotation, new BABYLON.Quaternion());\n    Gizmos.gizmos.push(boundingBoxLines);\n  }\n\n  public static DrawLine(from: Vector3, to: Vector3) {\n    \n    let myPoints = [\n      Vector3.VtoB(from),\n      Vector3.VtoB(to)\n    ];\n\n    let line = BABYLON.MeshBuilder.CreateLines(\"lines\", { points: myPoints }, Engine.scene);\n    line.color = Color.UtoB(Gizmos.color);\n    Gizmos.gizmos.push(line);\n  }\n\n\n  public static DrawSphere(position: Vector3, range: number) {\n    Gizmos.DrawCircle(0, position, range);\n    Gizmos.DrawCircle(1, position, range);\n    Gizmos.DrawCircle(2, position, range);\n  }\n\n  private static DrawCircle(axis: number, position: Vector3, range: number) {\n    var tess = Gizmos.gizmoPrecision;\n\n    var radius = range * this.radiusMultiplier;\n    var pi2 = Math.PI * 2;\n    var p = [];\n    for (var i = 0; i <= tess; i++) {\n      var ang = i * pi2 / tess;\n      var c1 = radius * Math.cos(ang) / tess;\n      var c2 = radius * Math.sin(ang) / tess;\n      var x = axis == 0 ? 0 : c1;\n      var y = axis == 1 ? 0 : c2;\n      var z = axis == 2 ? 0 : axis == 1 ? c2 : c1;\n      p.push(new BABYLON.Vector3(x, y, z));\n    }\n\n    var circle = BABYLON.Mesh.CreateLines('circle', p, Engine.scene);\n    circle.position = Vector3.VtoB(position);\n    circle.color = new BABYLON.Color3(0, 1, 0);\n    Gizmos.gizmos.push(circle);\n  }\n\n\n}"
                    },
                    {
                        "Dropdown.ts": "class Dropdown extends BABYLON.GUI.StackPanel\n{\n  public isSearchable : boolean;\n  public maxOptions : number;\n  public onSelect : BABYLON.Observable<string>;\n\n  options : string[] = new Array();\n  searchInput : BABYLON.GUI.InputText;\n\n  optionStack : BABYLON.GUI.StackPanel;\n\n  filteredOptions : string[] = new Array();\n\n constructor (maxOptions : number = -1)\n {\n   super();\n   this.maxOptions = maxOptions;\n   this.onSelect = new BABYLON.Observable();\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n        this.dispose();\n      }\n    });\n\n    \n    this.onPointerEnterObservable.add((evt) => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n\n    this.onPointerOutObservable.add((evt) => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n    \n\n    this.widthInPixels = 150;\n    this.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n }\n\n public SetOptions (options: string[])\n {\n    this.options = options;\n    this.Refresh();\n }\n\n Refresh ()\n {\n    this.searchInput = new EditorInputText();\n    this.addControl(this.searchInput);\n    this.searchInput.text = \"\";\n    this.searchInput.widthInPixels = this.widthInPixels;\n    \n    this.searchInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.searchInput.onTextChangedObservable.add((ev) => {\n      this.RefreshOptions();\n    });\n\n    this.searchInput.onKeyboardEventProcessedObservable.add((ev) =>\n    {\n      if (ev.keyCode == KeyCode.Enter)\n      {\n        if (this.filteredOptions.length > 0)\n        {\n          this.onSelect.notifyObservers(this.filteredOptions[0]);\n        }\n      }\n    });\n    this.RefreshOptions();\n    //We have to wait one frame or else we get error messages?\n    this.Focus();\n }\n\n async Focus ()\n {\n    await null;\n    UnionEditor.editorUI.moveFocusToControl(this.searchInput);\n }\n\n RefreshOptions () \n {\n   this.optionStack?.dispose();\n\n   this.optionStack = new BABYLON.GUI.StackPanel;\n   this.addControl(this.optionStack);\n   var filter = \"\";\n   if (this.isSearchable)\n   {\n     filter = this.searchInput.text;\n   }\n\n   var i = 0;\n   this.filteredOptions = new Array();\n   this.options.forEach((option : string) => {\n    if (option.toLowerCase().includes(filter.toLowerCase()))\n    {\n      if (i != -1 && i >= this.maxOptions)\n      {\n        return;\n      }\n      i++;\n      this.filteredOptions.push(option);\n      \n    }\n   });\n\n    this.filteredOptions.forEach((option : string) => {\n        var optionButton = new UnionButton(option, false);\n        optionButton.widthInPixels = this.widthInPixels;        \n        optionButton.height = \"20px\";\n        optionButton.color = UnionEditor.style.darkLineColor.toHexString();\n        optionButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n        optionButton.onPointerClickObservable.add(() =>\n        {\n          this.onSelect.notifyObservers(option);\n        });\n        this.optionStack.addControl(optionButton);\n    });\n }\n}\n"
                    },
                    {
                        "Inspector": [
                            {
                                "PropertyInspector.ts": "class PropertyInspector extends BABYLON.GUI.StackPanel {\n\n  public onValueChanged: BABYLON.Observable<any> = new BABYLON.Observable();\n\n  //This is a variable used to store which PropertyInspector was last created\n  //We can use that to tab through the Inspectors after\n  //Currently only setup in the Text Inspector\n  public static lastCreated: PropertyInspector;\n\n  protected previous: PropertyInspector;\n  public next: PropertyInspector;\n\n  isAdjustingByMouse: boolean = false;\n  isOverThisControl: boolean = false;\n\n  //The object that 'owns' this property\n  owner: any;\n  prop: SerializedProperty;\n  valueInput: any;\n\n  public nameField: BABYLON.GUI.TextBlock;\n\n  get value(): any {\n    return this._value;\n  }\n\n  set value(v: any) {\n    this._value = v;\n  }\n\n  _value: any;\n\n  constructor(owner: any, prop: SerializedProperty, value: any) {\n    super()\n\n    this.isVertical = false;\n    //this.adaptWidthToChildren = true;\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.owner = owner;\n    this.prop = prop;\n    this.value = value;\n    this.isPointerBlocker = false;\n\n    this.heightInPixels = 22;\n    this.paddingBottom = 1;\n    this.paddingTop = 1;\n    this.nameField = new BABYLON.GUI.TextBlock(\"\", this.ConvertToInspectorName(prop.name));\n    this.nameField.paddingLeft = \"5px\";\n    this.nameField.color = UnionEditor.style.textColor.toHexString();\n    this.nameField.style = UnionEditor.fontStyle;\n    this.nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    if (owner instanceof Component) {\n      //  this.nameField.width = \"60px\"\n    }\n    else {\n      // this.nameField.resizeToFit = true;\n    }\n    this.nameField.widthInPixels = 100;\n    this.nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(this.nameField);\n    this.nameField.isPointerBlocker = false;\n\n  }\n\n  ConvertToInspectorName(value: string) {\n    var v = value.toString();\n    v = v.replace(\"_\", \" \");\n    v = v.trim();\n    //Start with uppercase\n    v = v[0].toUpperCase() + v.substring(1, v.length);\n    //padding\n    v = \"  \" + v;\n    return v;\n  }\n\n  Init() {\n    var beforeRenderObserver = Engine.editorScene.onBeforeRenderObservable.add(() => {\n      this.Update();\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      Engine.editorScene.onBeforeRenderObservable.remove(beforeRenderObserver);\n    });\n  }\n\n  Update() {\n\n  }\n\n  UpdateProperty(markAsDirty: boolean = true) {\n    this.owner[this.prop.name] !== this.value\n    {\n      this.owner[this.prop.name] = this.value;\n      this.onValueChanged.notifyObservers(this.value);\n      if (markAsDirty) {\n        SceneManager.MarkSceneAsDirty();\n      }\n    }\n\n  }\n\n  public static Create(c: any, key: SerializedProperty, value: any): PropertyInspector {\n    var propInspector: PropertyInspector = null;\n    //TODO using declarations in the Inspector classes this could be a bit prettier.      \n    if (key.propType != null) {\n      propInspector = new EnumInspector(c, key, value);\n    } else if (value === null) {\n      return;\n    } else if (typeof value === 'number') {\n      propInspector = new NumberInspector(c, key, value);\n    } else if (typeof value === 'string') {\n      propInspector = new TextInspector(c, key, value);\n    } else if (typeof value === 'boolean') {\n      propInspector = new BoolInspector(c, key, value);\n    } else if (value instanceof Array) {\n      propInspector = new ArrayInspector(c, key, value);\n    } else if (value instanceof Vector3) {\n      propInspector = new Vector3Inspector(c, key, value);\n    } else if (value instanceof Color) {\n      propInspector = new ColorInspector(c, key, value);\n    } else {\n      Debug.Log(\"Creating generic text inspector for \" + typeof value);\n      propInspector = new TextInspector(c, key, value);\n    }\n    propInspector.Init();\n    return propInspector;\n  }\n\n}"
                            },
                            {
                                "EnumInspector.ts": "class EnumInspector extends PropertyInspector {\n\n  dropDown: Dropdown;\n\n  Init() {\n    super.Init();\n\n    var values: string[] = [];\n    for (var enumMember in this.prop.propType) {\n      if (typeof this.prop.propType[enumMember] === 'number') {\n        values.push(enumMember);\n      }\n    }\n\n    var v = UnionEditor.CreateButton(values[this.value]);\n\n    this.valueInput = v;\n    v.paddingLeftInPixels = 2;\n    v.paddingRightInPixels = 2;\n    v.width = \"35px\";\n    v.height = \"20px\";\n    v.color = UnionEditor.style.darkLineColor.toHexString();\n    //v.textBlock.color = UnionEditor.style.textColor.toHexString();\n    v.background = UnionEditor.style.buttonColor.toHexString();\n\n\n    \n    v.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(v);\n\n    v.onPointerClickObservable.add(() => {\n      this.dropDown?.dispose();\n      this.dropDown = new Dropdown(3);\n      this.dropDown.isSearchable = true;\n\n      this.dropDown.SetOptions(values);\n      UnionEditor.editorUI.addControl(this.dropDown);\n      this.dropDown.leftInPixels = v.centerX * 0.5 - this.widthInPixels * 0.5;\n      this.dropDown.topInPixels = v.centerY + this.heightInPixels * 0.5;\n      //Debug.Log(UnionEditor.editorUI.getSize().height)\n      this.dropDown.isPointerBlocker = true;\n      this.dropDown.onSelect.addOnce((selected: string) => {\n        this.value = this.prop.propType[selected];\n        v.textBlock.text = values[this.value];\n        this.dropDown.dispose();\n        this.UpdateProperty();\n      });\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      this.dropDown?.dispose();\n    });\n\n  }\n\n}\n"
                            },
                            {
                                "TextInspector.ts": "class TextInspector extends PropertyInspector\n{\n  Init()\n  {\n    super.Init();\n\n    if (PropertyInspector.lastCreated)\n    {\n      //We set this up to tab through this afterwards\n      this.previous = PropertyInspector.lastCreated;\n      PropertyInspector.lastCreated.next = this;\n    }\n    PropertyInspector.lastCreated = this;\n\n    var vInput = UnionEditor.CreateInputText();\n    this.valueInput = vInput;   \n    vInput.text = this.value ? this.value : \"\";\n    vInput.width = \"100px\";        \n    this.valueInput.onBlurObservable.add((ev) => {\n      this.UpdateValueFromText();\n    });\n\n    vInput.onKeyboardEventProcessedObservable.add((event) => {\n      if (event.key == \"Tab\")\n      {\n        var nextSelected : PropertyInspector = this.next;\n        if (event.shiftKey)\n        {\n          nextSelected = this.previous;\n        }\n        if (nextSelected)\n        {\n          UnionEditor.editorUI.moveFocusToControl(nextSelected.valueInput);\n          event.preventDefault();\n        }\n      }\n    });    \n\n    this.addControl(this.valueInput);\n    \n\n    this.onDisposeObservable.addOnce(e => {\n      vInput.onKeyboardEventProcessedObservable.clear();\n      vInput.onBlurObservable.clear();\n    })\n  }\n\n  UpdateValueFromText()\n  {\n    if (this.value != this.valueInput.text)\n    {\n      this.value = this.valueInput.text;\n      this.UpdateProperty();\n    }\n  }\n\n  Update ()\n  {\n    super.Update();\n    //Update the value every frame in the inspector\n\n    this.UpdateTextFromValue();\n  }\n\n  UpdateTextFromValue ()\n  {  \n    //this.value is checked since it may be removed (e.g. when downsizing an array)\n    if (this.value != undefined && this.owner[this.prop.name] != undefined && this.value != this.owner[this.prop.name])\n    {\n      this.value = this.owner[this.prop.name];\n      this.valueInput.text = this.value;\n    }\n  }\n}"
                            },
                            {
                                "NumberInspector.ts": "//script:NumberInspector\nclass NumberInspector extends TextInspector {\n\n  mouseAdjustSensitivity: number = 0.01;\n\n  pointerObserver: BABYLON.Observer<any>;\n\n\n  public Init() {\n    super.Init();\n    if (this.valueInput.text == \"\") {\n      this.valueInput.text = \"0\";\n    }\n    this.valueInput.width = \"30px\";\n\n    this.onPointerEnterObservable.add((ev) => {\n      Engine.cursor = \"ew-resize\";\n      this.isOverThisControl = true;\n    });\n    this.onPointerOutObservable.add((ev) => {\n      Engine.cursor = \"default\";\n      this.isOverThisControl = false;\n    });\n\n    this.pointerObserver = Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.isOverThisControl) {\n            this.isAdjustingByMouse = true;\n            Engine.current.enterPointerlock();\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERUP:\n          if (this.isAdjustingByMouse) {\n            this.isAdjustingByMouse = false;\n            Engine.current.exitPointerlock();\n            //If adjusted, this should send a propertyUpdate\n            this.UpdateProperty();\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n          if (this.isAdjustingByMouse) {\n            this.value += pointerInfo.event.movementX * this.mouseAdjustSensitivity;\n            this.valueInput.text = this.value;\n            this.UpdateProperty(false);\n          }\n          break;\n      }\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      Engine.scene.onPointerObservable.remove(this.pointerObserver);\n    })\n  }\n\n  UpdateTextFromValue() {\n    super.UpdateTextFromValue();\n\n  }\n\n\n  //Convert the text into a number\n\n  UpdateValueFromText() {\n    \n    if (this.value !== +this.valueInput.text) {\n      var x = +this.valueInput.text;\n      if (Number.isNaN(x)) {\n        this.valueInput.text = \"0\";\n        x = 0;\n      }\n\n      this.value = x;\n      this.UpdateProperty();\n    }\n  }\n\n}"
                            },
                            {
                                "ArrayInspector.ts": "class ArrayInspector extends PropertyInspector {\n\n  collapseButton: BABYLON.GUI.Button;\n  arrayList: BABYLON.GUI.StackPanel;\n\n  Init() {\n    super.Init();\n\n    this.collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n    this.collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.collapseButton.width = \"20px\";\n    this.collapseButton.color = UnionEditor.style.backgroundColor.toHexString();\n    this.collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    //Remove and re-add to place the collapse button in front of the name.\n    this.removeControl(this.nameField);\n    this.addControl(this.collapseButton);\n    this.addControl(this.nameField);\n\n    //Size field\n    this.valueInput = new BABYLON.GUI.InputText();\n    var vInput: BABYLON.GUI.InputText = this.valueInput;\n\n    vInput.style = UnionEditor.fontStyle;\n    vInput.paddingLeftInPixels = 10;\n    vInput.paddingRightInPixels = 2;\n    vInput.margin = \"2px\";\n    vInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    vInput.width = \"100px\";\n    vInput.height = \"20px\";\n    vInput.color = UnionEditor.style.textColor.toHexString();\n\n    vInput.onFocusSelectAll = true;\n\n    this.UpdateTextFromValue();\n    //When inspector inputfield is changed, update value\n    vInput.onBlurObservable.add((ev) => {\n      this.UpdateValueFromText();\n    });\n\n    this.addControl(this.valueInput);\n\n    this.collapseButton.onPointerUpObservable.add((evt) => {\n      if (this.arrayList) {\n        this.arrayList.dispose();\n        this.arrayList = null;\n      } else {\n        this.RefreshArrayList();\n      }\n      this.collapseButton.textBlock.text = this.arrayList ? \"v\" : \">\";\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      this.collapseButton.onPointerUpObservable.clear();\n    })\n  }\n\n  RefreshArrayList() {\n    //We remove this so it doesn't get desotryyed\n    this.arrayList?.dispose();\n\n    this.arrayList = new BABYLON.GUI.StackPanel();\n    this.arrayList.isVertical = true;\n    this.arrayList.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.arrayList.heightInPixels = (this.value.length + 1) * 20;\n\n    for (var i = 0; i < this.value.length; i++) {\n      var v = this.value[i];\n      //Null values get converted into empty strings\n      if (!v)\n        v = \"\";\n      this.arrayList.addControl(PropertyInspector.Create(this.value, {name: i.toString(), propType : null} , v));\n    }\n\n    if (this.parent) {\n      this.parent.addControl(this.arrayList);\n      this.arrayList.widthInPixels = this.parent.widthInPixels;\n    }\n  }\n\n  GetDefaultValue ()\n  {\n    if (this.value.length > 0)\n    {\n      var v = this.value[this.value.length-1];\n      if (v)\n        return v;\n    }\n    return \"\";\n  }\n\n  UpdateTextFromValue() {\n    this.valueInput.text = this.value.length;\n  }\n\n  UpdateValueFromText() {\n    if (this.value.length != +this.valueInput.text) {\n      var x = +this.valueInput.text;\n      \n      if (Number.isNaN(x)) {\n        this.UpdateTextFromValue();\n        return;\n      }\n\n      this.arrayList?.dispose();\n      \n      while (this.value.length > x) { this.value.pop(); }\n      while (this.value.length < x) { this.value.push(this.GetDefaultValue()); }\n\n      this.RefreshArrayList();\n\n      this.UpdateProperty();\n    }\n  }\n}\n"
                            },
                            {
                                "ColorInspector.ts": "class ColorInspector extends PropertyInspector {\n\ncurrentPicker : BABYLON.GUI.ColorPicker;\n\nInit()\n  {\n    super.Init();\n\n    var colorButton : BABYLON.GUI.Button = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \"\");\n    \n    colorButton.paddingLeftInPixels = 2;\n    colorButton.paddingRightInPixels = 2;\n    colorButton.width = \"15px\";\n    colorButton.height = \"10px\";\n    colorButton.color = \"white\";\n\n    var c : BABYLON.Color3 = new BABYLON.Color3();\n    Color.UtoB(this.value, c);\n    \n    colorButton.background = c.toHexString();    \n    colorButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.addControl(colorButton);\n\n    colorButton.onPointerClickObservable.add((ev) => {  \n      this.TryDisposeColorPicker();\n      this.currentPicker = new BABYLON.GUI.ColorPicker(\"Color Picker\");\n      this.currentPicker.value = c;\n      this.currentPicker.onValueChangedObservable.add(() => {\n        Color.BtoU(this.currentPicker.value, this.value);\n        this.UpdateProperty();\n        colorButton.background = this.currentPicker.value.toHexString();        \n      });\n      this.currentPicker.onPointerEnterObservable.add((ev) => {\n        EditorUI.SetPointerOverEditor(this.currentPicker);\n      })\n      this.currentPicker.onPointerOutObservable.add((ev) => {\n        EditorUI.RemovePointerOverEditor(this.currentPicker);\n      })\n      UnionEditor.editorUI.addControl(this.currentPicker);\n    });\n\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP) {        \n        this.TryDisposeColorPicker();\n      }\n    });\n\n    \n\n    this.onDisposeObservable.add(() => {\n      this.TryDisposeColorPicker();\n    });\n    /*\n    this.valueInput.color = this.value;\n    this.valueInput.onValueChangedObservable.add(() => {\n      this.value = this.valueInput.color;\n      this.UpdateProperty();\n    });\n    \n    //Update the value every frame in the inspector\n    Engine.scene.onBeforeRenderObservable.add(() =>\n    {\n      if (this.valueInput.color != this.value)\n      {\n        SceneManager.MarkSceneAsDirty();\n        this.valueInput.color = this.value;\n      }\n        \n    });\n    */\n  }\n\n  TryDisposeColorPicker () \n  {\n    if (this.currentPicker)\n      {\n        this.currentPicker.dispose();\n        this.currentPicker = null;\n        return;\n      }\n  }\n\n}\n"
                            },
                            {
                                "BoolInspector.ts": "class BoolInspector extends PropertyInspector\n{\n  Init()\n  {\n    super.Init();\n\n    var cBox = UnionEditor.CreateCheckbox();\n    this.valueInput = cBox;\n\n    this.addControl(this.valueInput);\n    \n    cBox.isChecked = this.value;\n    cBox.onIsCheckedChangedObservable.add(() => {\n      this.value = cBox.isChecked;\n      this.UpdateProperty();\n    });\n    \n    //Update the value every frame in the inspector\n    Engine.editorScene.onBeforeRenderObservable.add(() =>\n    {\n      if (cBox.isChecked != this.value)\n      {\n        cBox.isChecked = this.value;\n        SceneManager.MarkSceneAsDirty();\n      }\n        \n    });\n    \n  }\n\n  \n}"
                            },
                            {
                                "Vector3Inspector.ts": "//script:Vector3Inspector\nclass Vector3Inspector extends PropertyInspector\n{\n  inspectors : PropertyInspector[];\n\n  Init ()\n  {\n    super.Init();\n    this.inspectors = new Array();\n    Serializer.GetPropValues(this.value, true).forEach((value: any, key: SerializedProperty) => {      \n      var prop = PropertyInspector.Create(this.value, key, value);\n      prop.nameField.widthInPixels = 20;\n      this.inspectors.push(prop);\n      this.addControl(prop);\n    });\n  }\n\n  Update()\n  {\n  }\n\n}\n"
                            },
                            {
                                "MaterialInspector.ts": "class MaterialInspector extends BABYLON.GUI.StackPanel {\n\n  material : Material;\n\n  propertiesPanel : BABYLON.GUI.StackPanel;\n\n  materialName : string;\n\n constructor(materialName : string) {\n    super()\n    \n    this.materialName = materialName;\n\n    var material = Material.Get(materialName);\n\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    \n    this.material = material;\n    \n    this.propertiesPanel = new BABYLON.GUI.StackPanel();\n    this.propertiesPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.propertiesPanel.isVisible = true;\n    \n    this.addControl(this.propertiesPanel);  \n\n    Serializer.GetPropValues(material, false).forEach((value: any, key: SerializedProperty) => {\n      var propInspector: PropertyInspector = PropertyInspector.Create(material, key, value);      \n      this.propertiesPanel.addControl(propInspector);\n      propInspector.onValueChanged.add((ev) => {\n        Material.SaveToJSON(this.materialName);\n      });\n    });\n   \n }\n\n \n}\n"
                            },
                            {
                                "ComponentInspector.ts": "//script:ComponentInspector\n\nclass ComponentInspector extends BABYLON.GUI.StackPanel {\n\n  propertiesPanel: BABYLON.GUI.StackPanel;\n\n  constructor(parent: InspectorWindow, c: Component) {\n    super()\n    this.width = \"100%\";\n\n    this.AddLine(this, 2, UnionEditor.style.backgroundColor);\n    this.AddLine(this, 1, UnionEditor.style.darkLineColor);\n    this.AddLine(this, 2, UnionEditor.style.backgroundColor);\n\n    var topBar = new BABYLON.GUI.Container(\"ComponentTopBar\");\n    topBar.heightInPixels = 20;\n    topBar.width = \"100%\";\n    topBar.background = UnionEditor.style.componentBackgroundColor.toHexString();\n    this.addControl(topBar);\n\n    var namePanel = new BABYLON.GUI.StackPanel();\n\n    namePanel.isVertical = false;\n    topBar.addControl(namePanel);\n\n    var collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n    collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    collapseButton.width = \"20px\";\n    collapseButton.color = UnionEditor.style.backgroundColor.toHexString();\n    collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    namePanel.addControl(collapseButton);\n\n    collapseButton.onPointerUpObservable.add((evt) => {\n      this.propertiesPanel.isVisible = !this.propertiesPanel.isVisible;\n      collapseButton.textBlock.text = this.propertiesPanel.isVisible ? \"v\" : \">\";\n    });\n\n\n    var nameField = new BABYLON.GUI.TextBlock(\"\", c.constructor.name);\n\n    nameField.paddingLeft = \"5px\";\n    nameField.style = UnionEditor.fontStyleBold;\n    nameField.color = UnionEditor.style.textColor.toHexString();\n    nameField.width = \"140px\";\n    nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    namePanel.addControl(nameField);\n    namePanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.propertiesPanel = new BABYLON.GUI.StackPanel();\n    this.propertiesPanel.isVisible = true;\n\n    this.AddLine(this.propertiesPanel, 1, UnionEditor.style.semiDarkLineColor);\n    this.AddLine(this.propertiesPanel, 2, UnionEditor.style.backgroundColor);\n    this.addControl(this.propertiesPanel);\n\n    Serializer.GetPropValues(c, false).forEach((value: any, key: SerializedProperty) => {\n      var propInspector: PropertyInspector = PropertyInspector.Create(c, key, value);\n\n      this.propertiesPanel.addControl(propInspector);\n    });\n\n\n    if (c.GetType() == \"Transform\") {\n      //TODO DRY this up\n      this.propertiesPanel.isVisible = true;\n\n    } else {\n      //Transforms can't be removed\n      var deleteButton = BABYLON.GUI.Button.CreateSimpleButton(\"deleteButton\", \"x\");\n      deleteButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n      deleteButton.width = \"20px\";\n      deleteButton.color = UnionEditor.style.darkLineColor.toHexString();\n      deleteButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n      topBar.addControl(deleteButton);\n\n      deleteButton.onPointerUpObservable.add((evt) => {\n        var go: GameObject = c.gameObject;\n        Destroy(c);\n        parent.RefreshGOInspector(go);\n        /*\n        var dropDown = new Dropdown();\n          dropDown.AddOption(\"Remove Component\");\n          dropDown.linkOffsetXInPixels = 50;\n          UnionEditor.editorUI.addControl(dropDown);\n          dropDown.onSelect.add((selected: string) =>\n          {\n            if (selected == \"Remove Component\")\n            {\n              \n            }\n            \n          });       \n          */\n      });\n\n    }\n\n    collapseButton.textBlock.text = this.propertiesPanel.isVisible ? \"v\" : \">\";\n\n  }\n\n  AddLine(parent : BABYLON.GUI.Container, height: number, color: BABYLON.Color3) {\n    var topLine = new BABYLON.GUI.Rectangle(\"TopLine\");\n    topLine.heightInPixels = height;\n    topLine.thickness = 0;\n    topLine.background = color.toHexString();\n    parent.addControl(topLine);\n  }\n}"
                            },
                            {
                                "InspectorWindow.ts": "class InspectorWindow extends EditorWindow {\n  static current: InspectorWindow;\n  currentGameObject: GameObject;\n\n  constructor() {\n    super()\n    InspectorWindow.current = this;\n    EditorSelection.onSelected.add((data: SelectionData) => {\n\n      if (data.isSelected) {\n        this.RefreshGOInspector(data.obj as GameObject);\n      } else {\n        this.Refresh();\n      }\n    });\n\n    PixelPADEvents.onAssetClicked.add((asset: string[]) => {\n      this.Refresh();\n      switch (asset[0]) {\n        case \"material\":\n          EditorSelection.SetSelectedGameObject(null);\n          this.main.addControl(new MaterialInspector(asset[1]));\n          break;\n        case \"prefab\":\n          this.Refresh();\n          this.main.addControl(new PrefabInspector(asset[1]));\n          break;\n        case \"model\":\n          this.main.addControl(new FileViewer(asset[1]));\n          break;\n        case \"texture\":\n          this.main.addControl(new FileViewer(asset[1]));\n          break;\n        case \"sound\":\n          break;\n      }\n\n    });\n\n  }\n\n  OnViewModel() {\n    this.Refresh();\n  }\n\n  OnGUI() {\n    //When a GO is about to be deleted, we should clear the inspector\n    if (this.currentGameObject && this.currentGameObject.markedForDestroy) {\n      this.Refresh();\n    }\n  }\n\n  RefreshGOInspector(go: GameObject) {\n    this.Refresh();\n    this.currentGameObject = go;\n\n    var topLine = new BABYLON.GUI.StackPanel(\"GoTopLine\");\n    topLine.isVertical = false;\n    topLine.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    topLine.height = \"20px\";\n    this.main.addControl(topLine);\n\n    var cBox = UnionEditor.CreateCheckbox(\"GoIsActiveBox\");\n    cBox.isChecked = go.activeSelf;\n    cBox.onIsCheckedChangedObservable.add(() => {\n      go.SetActive(cBox.isChecked);\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    //Update the value every frame in the inspector\n    Engine.editorScene.onBeforeRenderObservable.add(() => {\n      if (cBox.isChecked != go.activeSelf) {\n        cBox.isChecked = go.activeSelf;\n        SceneManager.MarkSceneAsDirty();\n      }\n    });\n\n    topLine.addControl(cBox);\n\n    var vInput = UnionEditor.CreateInputText(\"GoNameInput\");\n    vInput.width = \"150px\";\n    vInput.text = go.name;\n    //When inspector inputfield is changed, update value\n    vInput.onBlurObservable.add((ev) => {\n      go.name = ev.text;\n    });\n\n    topLine.addControl(vInput);\n\n    let staticText = new BABYLON.GUI.TextBlock(\"staticText\", \"Static\");\n    staticText.paddingLeft = \"5px\";\n    staticText.widthInPixels = 45;\n    staticText.color = UnionEditor.style.textColor.toHexString();\n    staticText.style = UnionEditor.fontStyle;\n    staticText.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n\n    var sBox = UnionEditor.CreateCheckbox(\"GoIsStaticeBox\");\n    sBox.isChecked = go.isStatic;\n    sBox.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    sBox.onIsCheckedChangedObservable.add(() => {\n      go.isStatic = sBox.isChecked;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    //Update the value every frame in the inspector\n    Engine.editorScene.onBeforeRenderObservable.add(() => {\n      if (sBox.isChecked != go.isStatic) {\n        sBox.isChecked = go.isStatic;\n        SceneManager.MarkSceneAsDirty();\n      }\n    });\n\n    topLine.addControl(staticText);\n    topLine.addControl(sBox);\n\n    go.components.forEach((c: Component) => {\n      if (!c.markedForDestroy) {\n        this.main.addControl(new ComponentInspector(this, c));\n      }\n    });\n\n    var addButton = BABYLON.GUI.Button.CreateSimpleButton(\"\", \"Add Component\");\n    addButton.width = \"80%\";\n    addButton.height = \"25px\";\n    addButton.background = UnionEditor.style.buttonColor.toHexString();\n    addButton.color = UnionEditor.style.darkLineColor.toHexString();\n    addButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    this.main.addControl(addButton);\n    addButton.onPointerClickObservable.add(() => {\n      var dropDown = new Dropdown(3);\n      dropDown.isSearchable = true;\n\n      dropDown.SetOptions(this.GetAvailableComponents());\n      this.main.addControl(dropDown);\n      dropDown.onSelect.add((selected: string) => {\n        go.AddComponent(selected);\n        this.RefreshGOInspector(go);\n      });\n    });\n\n    //Can't edit prefabs directly.\n    if (go.prefabParent && go.prefabParent != go) {\n      let coverPanel = new BABYLON.GUI.Rectangle();\n      coverPanel.widthInPixels = this.background.widthInPixels;\n      coverPanel.heightInPixels = this.background.heightInPixels;\n      coverPanel.background = UnionEditor.style.backgroundColor.toHexString() + \"88\";\n      this.background.addControl(coverPanel);\n    }\n  }\n\n  //TODO reconsider the hackiness of this.\n  //Can be done through Serializable Fields\n  GetAvailableComponents(): string[] {\n    var components: string[] = new Array();\n    var scripts: string[] = Engine.scripts;\n    scripts.forEach((script: string) => {\n      try {\n        script = script.replace(\".ts\", \"\");\n        if (eval(script + \".isc\") == true) {\n          components.push(script);\n        }\n      } catch (e) {\n\n      }\n    });\n    return components;\n  }\n\n\n  Refresh() {\n    this.currentGameObject = null;\n    super.Refresh();\n  }\n\n}"
                            },
                            {
                                "PrefabInspector.ts": "class PrefabInspector extends BABYLON.GUI.StackPanel {\n\n   propertiesPanel: BABYLON.GUI.StackPanel;\n\n   name: string;\n\n   constructor(prefabName: string) {\n      super()\n\n      this.name = prefabName;\n\n      var prefab = Prefab.Get(prefabName);\n\n      this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n      var nameField = new BABYLON.GUI.TextBlock(\"\", prefabName);\n\n      nameField.paddingLeft = \"5px\";\n      nameField.style = UnionEditor.fontStyleBold;\n      nameField.color =  UnionEditor.style.textColor.toHexString();\n      nameField.width = \"160px\";\n      nameField.heightInPixels = 25;\n      nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n      nameField.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n      \n      this.heightInPixels = 400;\n      this.paddingTopInPixels = 3;\n      this.paddingBottomInPixels = 5;\n\n      this.propertiesPanel = new BABYLON.GUI.StackPanel();\n      this.propertiesPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n      this.propertiesPanel.isVisible = true;\n      \n      this.addControl(this.propertiesPanel);\n\n      this.propertiesPanel.addControl(nameField);\n\n      var createPrefabButton = UnionEditor.CreateButton(\"Create\");\n      createPrefabButton.widthInPixels = 100;\n      this.propertiesPanel.addControl(createPrefabButton);\n      createPrefabButton.onPointerClickObservable.add((ev) => {\n         Prefab.Create(prefabName);\n      });\n\n      /*\n      var savePrefabButton = UnionEditor.CreateButton(\"Save Selection\");\n      this.propertiesPanel.addControl(savePrefabButton);\n      savePrefabButton.onPointerClickObservable.add((ev) => {\n         if (!EditorSelection.currentSelectedGameObject)\n         {\n            Debug.Log(\"Select a GameObject to save\");\n         } else {\n            var prefabJson = Serializer.ToJSON(EditorSelection.currentSelectedGameObject);\n            savePrefab(prefabName, prefabJson);\n         }\n      });\n      */\n\n      var openPrefabButton = UnionEditor.CreateButton(\"Open Prefab\");\n      this.propertiesPanel.addControl(openPrefabButton);\n      openPrefabButton.onPointerClickObservable.add((ev) => {\n         if (SceneManager.GetActiveScene().isDirty)\n         {\n            alert(\"Save scene first you dumb dumb!\");\n         } else {\n            SceneManager.LoadPrefab(prefabName);\n         }\n      });\n   }\n\n\n}\n"
                            },
                            {
                                "FileViewer.ts": "class FileViewer extends BABYLON.GUI.StackPanel {\n\n  img: BABYLON.GUI.Image;\n\n  valueInput: BABYLON.GUI.InputText;\n\n  isValidFile: boolean = false;\n  url: string;\n\n  fileType: FileType = FileType.Texture;\n\n  constructor(fileName: string) {\n    super()\n\n    var downloadButton = UnionEditor.CreateButton(\"Download\");\n    downloadButton.paddingTopInPixels = 10;\n    downloadButton.heightInPixels = 30;\n    this.addControl(downloadButton);\n\n    var urlButton = UnionEditor.CreateButton(\"Print URL\");\n    urlButton.paddingTopInPixels = 10;\n\n    urlButton.heightInPixels = 30;\n    this.addControl(urlButton);\n\n    urlButton.onPointerClickObservable.add(ev => {\n      //if (this.isValidFile) {\n      print(this.url);\n      //}\n    });\n\n    downloadButton.onPointerClickObservable.add(ev => {\n      // if (this.isValidFile) {\n      window.open(this.url);\n      //}\n    });\n\n    this.url = \"\";\n    if (fileName.endsWith(\".obj\")\n      || fileName.endsWith(\".gltf\")\n      || fileName.endsWith(\".glb\")\n      || fileName.endsWith(\".babylon\")) {\n\n      this.fileType = FileType.Model;\n\n\n      var scene = new BABYLON.Scene(Engine.current);\n      scene.autoClear = false;\n      scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);\n\n      this.onDisposeObservable.add(e => {\n        scene.dispose();\n      });\n\n      var cam = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);\n      cam.position = new BABYLON.Vector3(0, 0, -25);\n      cam.wheelPrecision = 10;\n      scene.activeCamera = cam;\n\n      var bg = BABYLON.Mesh.CreatePlane(\"Background\", 100000, scene);\n      bg.rotate(new BABYLON.Vector3(0, 0, 1), Math.PI * 0.5);\n      bg.position.z = 500;\n      var m = new BABYLON.StandardMaterial(\"BackgroundMat\", scene);\n      m.disableLighting = true;\n      bg.material = m;\n      //Parented so it follows when the camera zooms/rotates\n      bg.setParent(cam);\n\n      var light = new BABYLON.DirectionalLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\n      light.intensity = .7;\n\n      this.url = getModel(fileName);\n\n      //Load the model\n      var urlObj = URLResult.Create(fileName, FileType.Model);\n      var viewedObject = new BABYLON.TransformNode(\"ViewedObject\", scene);\n\n      BABYLON.SceneLoader.ImportMesh(\"\", urlObj.baseUrl, urlObj.fullName, scene, (meshes) => {\n        meshes.forEach(m => {\n          m.setParent(viewedObject);\n        });\n        viewedObject.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n      });\n\n\n      this.RecreateTextureImage();\n\n      var isAttached = false;\n\n      this.img.onPointerEnterObservable.add(e => {\n        if (!isAttached) {\n          cam.attachControl(Engine.canvas, false);\n          isAttached = true;\n        }\n      });\n\n      this.img.onPointerOutObservable.add(e => {\n        if (isAttached)\n        {\n          cam.detachControl(Engine.canvas);\n          isAttached = false;\n        }\n      });\n      //Render \n      Engine.editorScene.onAfterRenderObservable.add(e => {\n        light.setDirectionToTarget(bg.absolutePosition);\n        //Map Camera to the texture\n        EditorHelpers.MapCamToGUIContainer(cam, this.img);\n        scene.render();\n      });\n\n\n    } else if (fileName.endsWith(\".png\") || fileName.endsWith(\".jpg\")) {\n      this.fileType = FileType.Texture;\n\n      this.RecreateTextureImage();\n\n      this.url = getTexture(fileName);\n\n      //Load the texture\n      this.img.source = this.url;\n\n    } else {\n      Debug.Log(\"Unrecognized file-format.\");\n      return;\n    }\n    if (!this.url) {\n      Debug.Log(\"Unrecognized filename\");\n      return;\n    }\n  }\n\n  RecreateTextureImage() {\n    this.img?.dispose();\n    this.img = new BABYLON.GUI.Image(\"TextureViewer\");\n    this.img.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.img.width = \"150px\";\n    this.img.height = \"150px\";\n    this.img.paddingTop = \"10px\";\n    this.img.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM;\n    this.addControl(this.img);\n  }\n\n\n}\n"
                            }
                        ]
                    },
                    {
                        "EditorInputText.ts": "class EditorInputText extends BABYLON.GUI.InputText {\n\n  constructor ()\n  {\n    super(\"EditorInputText\");\n    this.style = UnionEditor.fontStyle;\n    this.paddingLeftInPixels = 2;\n    this.paddingRightInPixels = 2;\n    this.margin = \"2px\";\n    this.width = \"150px\"\n    this.height = \"20px\";\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.color = \"white\";\n  }\n}\n"
                    },
                    {
                        "HierarchyList.ts": "class HierarchyList extends BABYLON.GUI.StackPanel {\n\n  tabSize: number = 10;\n  parentItem: HierarchyItem\n  items: HierarchyItem[];\n\n  constructor(objs: GameObject[], offset: number, parentItem: HierarchyItem) {\n    super(\"HierarchyList\");\n\n    this.parentItem = parentItem;\n    this.leftInPixels = offset;\n\n\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    var i: number = 0;\n    this.items = new Array();\n\n    objs.forEach((obj: GameObject) => {\n      if (!obj)\n        return;\n\n\n      var splitItem = new HierarchySplitItem(this, i);\n      this.addControl(splitItem.background);\n      i++;\n\n      var item = new HierarchyItem(this, obj);\n      this.items.push(item);\n      this.addControl(item.p);\n\n      item.onSelect.add(() => {\n        if (Input.GetKey(KeyCode.Control)) {\n          EditorSelection.ToggleSelectedGameObject(obj);\n\n        } else if (Input.GetKey(KeyCode.Shift)) {\n          if (EditorSelection.HasSelection()) {\n            var sel = EditorSelection.GetSelection();\n            var lastSelectedObject = sel[sel.length - 1];\n\n            this.state = 0;\n            this.GoThroughSelection(SceneManager.GetActiveScene().rootObjs, lastSelectedObject, item.obj);\n          }\n        } else {\n          EditorSelection.SetSelectedGameObject(obj);\n        }\n\n\n      });\n\n      //Slighly hacky way to ensure the newly created object is selected.\n      /*\n      if (obj == EditorSelection.currentSelectedGameObject) {\n        EditorSelection.SetSelectedGameObject(null);\n        EditorSelection.SetSelectedGameObject(obj);\n      }\n      */\n    });\n\n    //One split item at the bottom\n    var splitItem = new HierarchySplitItem(this, i);\n    this.addControl(splitItem.background);\n  }\n\n  state: number = 0;\n\n  GoThroughSelection(siblings: GameObject[], go1: GameObject, go2: GameObject) {\n\n    //state starts at 0: which means don't select items\n    //when it hits either GameObject, start selecting\n    //when it hits the next GameObject, stop everything.\n\n    //We collapse all children before we collapse a parent\n    siblings.forEach(item => {\n      if (item == null)\n        return;\n\n      if (this.state > 1)\n        return;\n\n      if (item === go1 || item === go2) {\n        EditorSelection.AddSelectedGameObject(item);\n        this.state++;\n      }\n\n      if (this.state == 1) {\n        EditorSelection.AddSelectedGameObject(item);\n      }\n\n      //When shift-selecting it shouldn't select children of collapsed items\n      let collapsed = HierarchyWindow.idToCollapse[item.transform.uniqueId];\n      if (collapsed === undefined)\n        collapsed = true;\n      if (collapsed === false) {\n        this.GoThroughSelection(item.transform.ser_children, go1, go2);\n      }\n\n\n\n\n    });\n  }\n}\n\n"
                    },
                    {
                        "Undo.ts": "class Undo {\n\n  public static isUndoing: boolean;\n  private static scores: Map<string, UndoData> = new Map();\n\n  public static disableRecording = false;\n  public static framesBeforeEnableRecording = 0;\n\n  private static recordStateThisFrame = false;\n\n  public static Init() {\n    Engine.scene.onKeyboardObservable.add((keybrd) => {\n      if (Engine.isPlaying || SceneManager.isReloading) {\n        return;\n      }\n      if (keybrd.type == BABYLON.KeyboardEventTypes.KEYDOWN) {\n        if (keybrd.event.ctrlKey || keybrd.event.metaKey) {\n          keybrd.event.preventDefault();\n          if (keybrd.event.key === \"z\") {\n            Undo.PerformUndo();\n          } else if (keybrd.event.key === \"y\") {\n            Undo.PerformRedo();\n          }\n        }\n      }\n\n    });\n\n  }\n\n  public static Update() {\n    if (Undo.disableRecording) {\n      Undo.framesBeforeEnableRecording--;\n      if (Undo.framesBeforeEnableRecording === 0) {\n        Undo.disableRecording = false;\n      }\n      return;\n    }\n\n    if (Undo.recordStateThisFrame) {\n      Undo.RecordState();\n      Undo.recordStateThisFrame = false;\n    }\n\n  }\n\n  private static Disable() {\n    //We HAVE TO wait two frames, since the scene reloads and marks things as dirty after 2 frames\n    //To avoid this triggering another 'MarkToRecordState', we just disable it all together\n    Undo.framesBeforeEnableRecording = 2;\n    Undo.disableRecording = true;\n  }\n\n  private static RecordState() {\n    Undo.Disable();\n    let history = Undo.GetHistory();\n    let sceneData = Serializer.ToJSON(SceneManager.GetActiveScene(), false);\n    //We slice the list off, in case some actions were undone, and then we continue working\n    history.actionList = history.actionList.slice(0, history.index + 1);\n    history.actionList.push(new UndoActionData(UndoType.Action, sceneData));\n    history.index = history.actionList.length - 1;\n   // Debug.Log(\"Saving: \" + history.index, false);\n  }\n\n  public static MarkToRecordState() {\n\n    if (Engine.isPlaying || SceneManager.isReloading || Undo.disableRecording) {\n      return;\n    }\n\n    Undo.recordStateThisFrame = true;\n  }\n\n  @MenuItem(\"Edit/Undo\")\n  public static PerformUndo() {\n\n    if (Engine.isPlaying || SceneManager.isReloading || Undo.disableRecording) {\n      return;\n    }\n    Undo.Disable();\n    let history = Undo.GetHistory();\n\n   // Debug.Log(\"Loading: \" + history.index);\n\n\n    if (history.index > 0) {\n      history.index--;\n    }\n\n    Undo.LoadScene();\n  }\n\n  @MenuItem(\"Edit/Redo\")\n  public static PerformRedo() {\n    if (Engine.isPlaying || SceneManager.isReloading || Undo.disableRecording) {\n      return;\n    }\n\n    Undo.Disable();\n    let history = Undo.GetHistory();\n    if (history.index < history.actionList.length - 1) {\n      history.index++;\n    }\n\n    Undo.LoadScene();\n  }\n\n  private static LoadScene() {\n    if (Engine.isPlaying || SceneManager.isReloading) {\n      return;\n    }\n\n    let history = Undo.GetHistory();\n\n    SceneManager.LoadSceneData(history.actionList[history.index].undoData);\n  }\n\n  private static GetHistory(): UndoData {\n    let sceneName = SceneManager.GetActiveScene().name;\n    let history: UndoData;\n    if (Undo.scores.has(sceneName)) {\n      history = Undo.scores.get(sceneName);\n    } else {\n      history = new UndoData();\n      Undo.scores.set(sceneName, history);\n    }\n\n    return history;\n  }\n\n\n\n}\n\nclass UndoData {\n  index: number = 0;\n  actionList: UndoActionData[] = new Array();\n}\n\nclass UndoActionData {\n  constructor(undoType: UndoType, undoData: string) {\n    this.undoType = undoType;\n    this.undoData = undoData;\n  }\n\n  undoType: UndoType;\n  undoData: string;\n}\n\nenum UndoType {\n  Action,\n  Selection\n}\n"
                    }
                ]
            },
            {
                "Physics": [
                    {
                        "Ray.ts": "class Ray\n{\n  public origin : Vector3 = new Vector3();\n  public direction : Vector3 = new Vector3();\n\n  constructor (origin : Vector3, direction : Vector3)\n  {\n    this.origin = origin;\n    this.direction = direction;\n  }\n}\n\nclass RaycastHit\n{\n  collider : Collider;\n}"
                    },
                    {
                        "Physics.ts": "//script:Physics\nenum TriggerOption {\n  Enter,\n  Stay,\n  Exit\n}\n\nclass Physics {\n  public static gravity: BABYLON.Vector3 = new BABYLON.Vector3(0, -98.1, 0);\n\n\n  static Init() {\n    Engine.scene.onBeforeStepObservable.add(() => {\n      Physics.BeforePhysicsUpdate();\n    });\n  }\n\n  public static GetOp(obj: BABYLON.IPhysicsEnabledObject): ObjectPhysics {\n    var x = obj as BABYLON.AbstractMesh;\n    var go: GameObject = Engine.meshToObject[x.uniqueId];\n    return go.objectPhysics;    \n  }\n\n  public static Raycast (ray : Ray, hitInfo : RaycastHit, length : number) : boolean {\n    var babRay = new BABYLON.Ray(Vector3.VtoB(ray.origin), Vector3.VtoB(ray.direction), length);\n    var hit = Engine.scene.pickWithRay(babRay);\n    if (hit.pickedMesh)\n    {\n      Debug.Log(hit.pickedPoint);\n      if (Engine.meshToObject[hit.pickedMesh.uniqueId])\n      {\n        hitInfo.collider = Engine.meshToObject[hit.pickedMesh.uniqueId].GetComponent(Collider);\n\n      }\n    }\n    \n    return hit.pickedMesh != null;\n  }\n\n  private static BeforePhysicsUpdate() {\n\n    var imposters = Engine.scene._physicsEngine.getImpostors();\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = this.GetOp(imposters[i].object);\n\n      //We need this for it to recompute positions!\n      op.go.transform.Translate(0, 0, 0);\n\n      //We reset all trigger bools\n      op?.triggerMap?.forEach((value: boolean, key: number) => {\n        op.triggerMap.set(key, false);\n      });\n    }\n\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = this.GetOp(imposters[i].object);\n\n      //Gravity\n      if (op?.rb) {\n        if (op.rb.useGravity) {\n          try {\n            //let pe= Engine.scene.getPhysicsEngine();\n            //pe.setSubTimeStep(10/6);\n            //let mp = pe.getSubTimeStep();\n            let gravity = Physics.gravity.clone();\n            //Adjust to mass\n            gravity.scaleInPlace(imposters[i].mass);\n            //Adjust to timescale\n            //Times an arbitrary '50' to make the physics realistic based on earth\n            // gravity.scaleInPlace(50);\n            imposters[i].applyForce(gravity, imposters[i].getObjectCenter());\n          } catch (e) {\n\n          } \n        }\n      }\n\n      if (op?.parentRb) {\n        for (var j = 0; j < imposters.length; j++) {\n          var op2 = this.GetOp(imposters[j].object);\n          if (op?.coll?.hasStarted && op2?.coll?.hasStarted && op.coll.boundsMesh.uniqueId != op2.coll.boundsMesh.uniqueId) {\n\n            if (op.coll.isTrigger || op2.coll.isTrigger) {\n              if (this.Intersects(op, op2)) {\n                //Avoid double triggering of two rigidbodies\n                if (!op2.triggerMap.get(op.coll.boundsMesh.uniqueId)) {\n                  //If was already triggering...\n                  if (op.triggerMap.has(op2.coll.boundsMesh.uniqueId)) {\n                    Physics.CallTrigger(TriggerOption.Stay, op.coll.gameObject, op2.coll);\n                    Physics.CallTrigger(TriggerOption.Stay, op2.coll.gameObject, op.coll);\n                  } else {\n                    Physics.CallTrigger(TriggerOption.Enter, op.coll.gameObject, op2.coll);\n                    Physics.CallTrigger(TriggerOption.Enter, op2.coll.gameObject, op.coll);\n                  }\n                  op.triggerMap.set(op2.coll.boundsMesh.uniqueId, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = this.GetOp(imposters[i].object);\n      op?.triggerMap?.forEach((value: boolean, key: number) => {\n        //If it was not set to true, it means it did not trigger this frame\n        if (!value) {\n\n          if (ObjectPhysics.colliderMap.has(key)) {\n            var otherCollider = ObjectPhysics.colliderMap.get(key);\n            //otherCollider is null when the PhysicsImpostor is not set up yet\n            if (otherCollider) {\n              Physics.CallTrigger(TriggerOption.Exit, op.coll.gameObject, otherCollider);\n              Physics.CallTrigger(TriggerOption.Exit, otherCollider.gameObject, op.coll);\n              op.triggerMap.delete(key);\n            }\n          }\n        }\n      });\n    }\n  }\n\n  private static CallTrigger(f: TriggerOption, go: GameObject, coll: Collider) {\n    Physics.CallTriggerSub(f, go, coll);\n    let rb = go.objectPhysics.rb?.gameObject;\n    if (rb && rb != go)\n      Physics.CallTriggerSub(f, rb, coll);\n  }\n\n\n  private static CallTriggerSub(f: TriggerOption, go: GameObject, coll: Collider) {\n    try {\n      switch (f) {\n        case TriggerOption.Enter:\n          go.OnTriggerEnter(coll);\n          break;\n        case TriggerOption.Stay:\n          go.OnTriggerStay(coll);\n          break;\n        case TriggerOption.Exit:\n          go.OnTriggerExit(coll);\n          break;\n      }\n    } catch (e) { Debug.Log(e); }\n  }\n\n  private static Intersects(op: ObjectPhysics, op2: ObjectPhysics): boolean {\n\n    var box: number = BABYLON.PhysicsImpostor.BoxImpostor;\n    var sphere: number = BABYLON.PhysicsImpostor.SphereImpostor;\n\n    if (op.coll.GetImpostor() == box && op2.coll.GetImpostor() == box) {\n      //return (op.mesh.intersectsMesh(op2.mesh, true));\n      return this.OBBToOBB(op, op2);\n    }\n\n    if (op.coll.GetImpostor() == box && op2.coll.GetImpostor() == sphere) {\n      return this.BoxSphereIntersects(op, op2);\n    }\n\n    if (op.coll.GetImpostor() == sphere && op2.coll.GetImpostor() == box) {\n      return this.BoxSphereIntersects(op2, op);\n    }\n\n    if (op.coll.GetImpostor() == sphere && op2.coll.GetImpostor() == sphere) {\n      return this.SphereToSphere(op2.mesh.absolutePosition, this.GetSphereRadius(op2), op.mesh.absolutePosition, this.GetSphereRadius(op));\n    }\n\n    return false;\n  }\n\n\n  private static OBBToOBB(c1: ObjectPhysics, c2: ObjectPhysics): boolean {\n    //This is an optimization so most objects won't even be compared.\n    let pos1 = BABYLON.Vector3.TransformCoordinates(Vector3.VtoB(c1.coll.center), c1.go.transform.transformNode.getWorldMatrix());\n    let pos2 = BABYLON.Vector3.TransformCoordinates(Vector3.VtoB(c2.coll.center), c2.go.transform.transformNode.getWorldMatrix());\n\n    let d1 = c1.coll.bounds.maximum.lengthSquared();\n    let d2 = c2.coll.bounds.maximum.lengthSquared();\n\n    if (BABYLON.Vector3.DistanceSquared(pos1, pos2) > d1 + d2) {\n      return false;\n    }\n\n\n\n    let sides = new Array();\n    //Instead of using the normals we can just use the sides (sides are eachothers normals)\n    sides.push(Vector3.BtoV(c1.go.transform.transformNode.right));\n    sides.push(Vector3.BtoV(c1.go.transform.transformNode.up));\n    sides.push(Vector3.BtoV(c1.go.transform.transformNode.forward));\n    sides.push(Vector3.BtoV(c2.go.transform.transformNode.right));\n    sides.push(Vector3.BtoV(c2.go.transform.transformNode.up));\n    sides.push(Vector3.BtoV(c2.go.transform.transformNode.forward));\n    //For 3D Collision, we also need to check the CROSS PRODUCT\n    sides.push(Vector3.Cross(sides[0], sides[3]));\n    sides.push(Vector3.Cross(sides[0], sides[4]));\n    sides.push(Vector3.Cross(sides[0], sides[5]));\n    sides.push(Vector3.Cross(sides[1], sides[3]));\n    sides.push(Vector3.Cross(sides[1], sides[4]));\n    sides.push(Vector3.Cross(sides[1], sides[5]));\n    sides.push(Vector3.Cross(sides[2], sides[3]));\n    sides.push(Vector3.Cross(sides[1], sides[4]));\n    sides.push(Vector3.Cross(sides[1], sides[5]));\n\n    let points1 = this.GetVertexPoints(c1.coll as BoxCollider);\n    let points2 = this.GetVertexPoints(c2.coll as BoxCollider);\n\n    let overlap = this.CheckPointsOverlap(sides, points1, points2);\n    return overlap;\n  }\n\n  private static CheckPointsOverlap(sides: Vector3[], points1: Vector3[], points2: Vector3[]) {\n    let o = true;\n    for (let i = 0; i < sides.length; i++) {\n      let side = sides[i];\n\n      if (side.sqrMagnitude < 0.001) {\n        continue;\n      }\n\n      let b1Min = Number.MAX_VALUE;\n      let b1Max = -Number.MAX_VALUE;\n      for (let j = 0; j < points1.length; j++) {\n        let t = Vector3.Dot(points1[j], side);\n        if (t < b1Min) {\n          b1Min = t;\n        }\n        if (t > b1Max) {\n          b1Max = t;\n        }\n      }\n\n      let b2Min = Number.MAX_VALUE;\n      let b2Max = -Number.MAX_VALUE;\n      for (let j = 0; j < points2.length; j++) {\n        let t = Vector3.Dot(points2[j], side);\n        if (t < b2Min) {\n          b2Min = t;\n        }\n        if (t > b2Max) {\n          b2Max = t;\n        }\n      }\n\n      /*\n      Gizmos.color = new Color(1, 1, 1);\n      Gizmos.DrawLine(side.scale(-50), side.scale(50))\n      Gizmos.color = new Color(1, 0, 0);\n      Gizmos.DrawLine(side.scale(b2Min), side.scale(b2Max));\n      Gizmos.color = new Color(0, 1, 0);\n      Gizmos.DrawLine(side.scale(b1Min), side.scale(b1Max));\n      */\n\n      if ((b2Min > b1Min && b2Min < b1Max) ||\n        (b2Max > b1Min && b2Max < b1Max) ||\n        (b1Min > b2Min && b1Min < b2Max) ||\n        (b1Max > b2Min && b1Max < b2Max)) {\n\n      } else {\n        o = false;\n        return o;\n      }\n    }\n    return o;\n  }\n\n  private static GetVertexPoints(coll: BoxCollider): Vector3[] {\n    let matrix = coll.transform.transformNode.getWorldMatrix();\n\n    let min = coll.bounds.minimum.add(Vector3.VtoB(coll.center));\n    let max = coll.bounds.maximum.add(Vector3.VtoB(coll.center));\n\n    let points = [\n      this.ToWorld(matrix, min),\n      this.ToWorld(matrix, max),\n      this.ToWorld(matrix, new BABYLON.Vector3(min.x, min.y, max.z)),\n      this.ToWorld(matrix, new BABYLON.Vector3(min.x, max.y, min.z)),\n      this.ToWorld(matrix, new BABYLON.Vector3(max.x, min.y, min.z)),\n      this.ToWorld(matrix, new BABYLON.Vector3(max.x, max.y, min.z)),\n      this.ToWorld(matrix, new BABYLON.Vector3(max.x, min.y, max.z)),\n      this.ToWorld(matrix, new BABYLON.Vector3(min.x, max.y, max.z)),\n    ];\n\n    return points;\n  }\n\n  private static ToWorld(matrix, v: BABYLON.Vector3) {\n    return Vector3.BtoV(BABYLON.Vector3.TransformCoordinates(v, matrix));\n  }\n\n  private static BoxSphereIntersects(op: ObjectPhysics, op2: ObjectPhysics): boolean {\n    //We get the maxScale of the sphere, since we only allow the sphere to be perfectly round\n    var radius = this.GetSphereRadius(op2);\n\n    return this.SphereToOBB(op2.mesh.absolutePosition, radius, op.mesh);\n  }\n\n  private static SphereToOBB(position: BABYLON.Vector3, radius: number, box: BABYLON.AbstractMesh): boolean {\n    //Make the position relative to the box\n    var p = position.subtract(box.absolutePosition);\n\n    //Rotate the resulting Vector by the inverted box rotation (to make the comparison axis aligned)\n    p.rotateByQuaternionToRef(BABYLON.Quaternion.Inverse(box.absoluteRotationQuaternion), p);\n\n    var s = box.absoluteScaling;\n\n    //Getting the closest point is easy since it's axis aligned\n    var closesPoint = new BABYLON.Vector3(\n      Mathf.Clamp(p.x, -s.x * 0.5, s.x * 0.5),\n      Mathf.Clamp(p.y, -s.y * 0.5, s.y * 0.5),\n      Mathf.Clamp(p.z, -s.z * 0.5, s.z * 0.5));\n\n\n    var dSqrd = BABYLON.Vector3.DistanceSquared(p, closesPoint);\n\n    return radius * radius > dSqrd;\n  }\n\n  private static SphereToSphere(p1: BABYLON.Vector3, r1: number, p2: BABYLON.Vector3, r2: number): boolean {\n    return BABYLON.Vector3.DistanceSquared(p1, p2) < (r1 + r2) * (r1 + r2);\n  }\n\n  public static OverlapSphere(position: Vector3, radius: number): Collider[] {\n    var imposters = Engine.scene._physicsEngine.getImpostors();\n\n    var colliders: Collider[] = new Array();\n\n    var box: number = BABYLON.PhysicsImpostor.BoxImpostor;\n    var sphere: number = BABYLON.PhysicsImpostor.SphereImpostor;\n\n    for (var j = 0; j < imposters.length; j++) {\n      var op = this.GetOp(imposters[j].object);\n      if (op.coll != null) {\n        if (op.coll.GetImpostor() == box) {\n          if (this.SphereToOBB(Vector3.VtoB(position, new BABYLON.Vector3()), radius, op.mesh)) {\n            colliders.push(op.coll);\n          }\n        } else if (op.coll.GetImpostor() == sphere) {\n          if (this.SphereToSphere(Vector3.VtoB(position, new BABYLON.Vector3()), radius, op.mesh.absolutePosition, this.GetSphereRadius(op))) {\n            colliders.push(op.coll);\n          }\n        }\n      }\n    }\n\n    return colliders;\n  }\n\n  private static GetSphereRadius(op: ObjectPhysics) {\n    let sphereColl = op.coll as SphereCollider;\n    let r = sphereColl ? sphereColl.radius : 1;\n    let s = op.go.transform.lossyScale;\n    return Math.max(s.x, s.y, s.z) * r * 0.5;\n  }\n\n\n\n\n}"
                    },
                    {
                        "Rigidbody.ts": "@RegisterAsComponent\nclass Rigidbody extends Component {\n\n\n  private _vel: Vector3 = new Vector3();\n  private _angularVel: Vector3 = new Vector3();\n\n  private get objectPhysics(): ObjectPhysics {\n    return this.gameObject.objectPhysics;\n  }\n\n  //region mass\n  public get mass(): number {\n    return this._mass;\n  }\n\n  public set mass(value: number) {\n    //Setting the mass to 0 will break the physics\n    if (value === 0) {\n      value = 0.00001;\n    }\n\n    this._mass = value;\n    this.UpdateMass();\n  }\n\n  public set freezeRotation(value: boolean) {\n\n    this.objectPhysics.physicsImpostor.executeNativeFunction(function (world, body) {\n      if (body.fixedRotation !== value) {\n        body.fixedRotation = value;\n        body.updateMassProperties();\n      }\n    });\n  }\n\n  public get freezeRotation(): boolean {\n    return this._freezeRotation;\n  }\n\n\n  get velocity(): Vector3 {\n    if (this.objectPhysics.physicsImpostor) {\n      Vector3.BtoV(this.objectPhysics.physicsImpostor.getLinearVelocity(), this._vel);\n    }\n    return this._vel;\n  }\n\n  set velocity(value: Vector3) {\n\n    this._vel = value;\n    this._vel.onChange.add(() => {\n      if (this.objectPhysics.physicsImpostor) {\n        this.objectPhysics.physicsImpostor.setLinearVelocity(Vector3.VtoB(this._vel, new BABYLON.Vector3()));\n      }\n    });\n\n    this._vel.onChange.notifyObservers(null);\n  }\n\n  get angularVelocity(): Vector3 {\n    if (this.objectPhysics.physicsImpostor) {\n      Vector3.BtoV(this.objectPhysics.physicsImpostor.getAngularVelocity(), this._angularVel);\n    }\n    return this._angularVel;\n  }\n\n  set angularVelocity(value: Vector3) {\n\n    this._angularVel = value;\n    this._angularVel.onChange.add(() => {\n      if (this.objectPhysics.physicsImpostor) {\n        this.objectPhysics.physicsImpostor.setAngularVelocity(Vector3.VtoB(this._angularVel, new BABYLON.Vector3()));\n      }\n    });\n    this._angularVel.onChange.notifyObservers(null);\n  }\n\n  @SerializeField\n  private _mass: number = 10;\n  //endregion\n\n  //region restitution\n\n  public get restitution(): number {\n    return this._restitution;\n  }\n\n  public set restitution(value: number) {\n    if (this.objectPhysics.physicsImpostor && this.objectPhysics.physicsImpostor.restitution != value) {\n      this.objectPhysics.physicsImpostor.restitution = value;\n    }\n    this._restitution = value;\n  }\n\n  @SerializeField\n  private _restitution: number = 0.5;\n\n  //endregion\n\n  //region friction\n  public get friction(): number {\n    return this._friction;\n  }\n\n  public set friction(value: number) {\n    //Multiply by 10 to have similar numbers as before.\n    if (this.objectPhysics.physicsImpostor != null) {\n      this.objectPhysics.physicsImpostor.friction = value * 10;\n\n    }\n    this._friction = value;\n  }\n\n  @SerializeField\n  private _friction: number = 0.5;\n  //endregion\n\n  //region isKinematic\n  public get isKinematic(): boolean {\n    return this._isKinematic;\n  }\n\n  public set isKinematic(value: boolean) {\n\n    //Only update when changed.\n    //We need a wasKinematic since isKinematic is the serialized value\n    if (this._wasKinematic != value) {\n      this._wasKinematic = value;\n      this._isKinematic = value;\n\n      //We check for the impostor since the setter in objectPhysics needs it\n      if (this.objectPhysics.physicsImpostor) {\n        this.UpdateMass();\n\n        this.objectPhysics.MarkForUpdate();\n      }\n    }\n\n  }\n\n  @SerializeField\n  private _isKinematic: boolean = false;\n  \n  @SerializeField\n  private _freezeRotation: boolean = false;\n\n  private _wasKinematic: boolean = false;\n  //endregion\n\n  UpdateMass() {\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.mass = this.isKinematic ? 0 : this._mass;\n    }\n  }\n\n  //Works! Cannon.js had to be modified to not calculate friction based on gravity\n  useGravity: boolean = true;\n\n\n  Awake() {\n    this.objectPhysics.MarkForUpdate();\n\n  }\n\n  OnEnable() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n  }\n\n  OnDisable() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n  }\n\n  FixedUpdate() {\n    //Force setter\n    if (this._isKinematic != this._wasKinematic) {\n      this.isKinematic = this._isKinematic;\n    }\n    this.restitution = this.restitution;\n    this.friction = this.friction;\n    this.freezeRotation = this.freezeRotation;\n  }\n\n  OnDestroy() {\n\n    this.objectPhysics.MarkForUpdate();\n\n  }\n\n  //When the mesh changes, we need to recreate the Impostor\n  //With a Rigidbody, we only need to change some values.\n  UpdateValuesToImpostor() {\n    //force setters\n    this.mass = this.mass;\n    this.restitution = this.restitution;\n\n    this.friction = this.friction;\n    this.isKinematic = this.isKinematic;\n    this.freezeRotation = this.freezeRotation;\n  }\n}\n"
                    },
                    {
                        "Collider.ts": "class Collider extends Component {\n  //Only used for it's uniqueId\n  public boundsMesh: BABYLON.TransformNode;\n\n  public bounds: BABYLON.BoundingInfo;\n\n  recenterObserver: BABYLON.Observer<any>;\n\n  protected get objectPhysics(): ObjectPhysics {\n    return this.gameObject.objectPhysics;\n  }\n\n  //Overridden by Specific Colliders (e.g. BoxCollider)\n  public GetImpostor(): number {\n    return -1;\n  }\n\n  public get isTrigger(): boolean {\n    return this._isTrigger;\n  }\n\n  public set isTrigger(value: boolean) {\n    this._isTrigger = value;\n    if (this.objectPhysics.physicsImpostor?.physicsBody) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionResponse = this.isTrigger ? 0 : this.layer;\n    }\n  }\n\n  @SerializeField\n  _isTrigger = false;\n\n  wasTrigger = false;\n\n  @SerializeField\n  _center: Vector3 = new Vector3(0, 0, 0);\n\n  get center(): Vector3 {\n    return this._center;\n  }\n\n  set center(value: Vector3) {\n    this._center?.onChange.remove(this.recenterObserver);\n\n    this._center = value;\n    this.recenterObserver = this._center.onChange.add(() => {\n      this.ReconstructMeshLines();\n    });\n    this._center.onChange.notifyObservers(null);\n  }\n\n  public get layer(): number {\n    return this._layer;\n  }\n\n  public set layer(value: number) {\n    this._layer = value;\n    if (this.objectPhysics.physicsImpostor?.physicsBody) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionFilterGroup = value;\n    }\n  }\n\n  @SerializeField\n  _layer: number = 1;\n\n  public get layerMask(): number {\n    return this._layerMask;\n  }\n\n  public set layerMask(value: number) {\n    this._layerMask = value;\n    if (this.objectPhysics.physicsImpostor?.physicsBody) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionFilterMask = value;\n    }\n  }\n\n  @SerializeField\n  _layerMask: number = 1;\n\n\n  Awake() {\n    this.boundsMesh = new BABYLON.TransformNode(\"BoundsMesh\", Engine.scene);\n\n    var min = new BABYLON.Vector3(-0.5, -0.5, -0.5);\n    var max = new BABYLON.Vector3(0.5, 0.5, 0.5);\n    this.bounds = new BABYLON.BoundingInfo(min, max);\n    //We make it a child to it scales along with transform\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n    if (Engine.isPlaying) {\n      \n      this.objectPhysics.MarkForUpdate();\n\n      //Scaling is not supported by PhysicsImpostors. Every time the scale changes we should update it\n      this.transform.localScale.onChange.add((i: number) => {\n        //TODO should be MarkForUpdate?\n        this.objectPhysics.MarkForUpdate();\n      });\n    }\n  }\n\n  OnEnable() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n    this.ReconstructMeshLines();\n  }\n\n  public GetGizmoCenter(): Vector3 {\n    let c: Vector3 = new Vector3();\n    //If the engine is not playing (and we have no physics impostor), we have to do some manual math.\n  //  if (!Engine.isPlaying) {\n      let m = new BABYLON.Matrix();\n      this.transform.transformNode.rotationQuaternion.toRotationMatrix(m);\n      //Scale\n      let bavB = Vector3.VtoB(this.center).multiplyByFloats(this.transform.lossyScale.x, this.transform.lossyScale.y, this.transform.lossyScale.z);\n      //Rotate\n      c = Vector3.BtoV(BABYLON.Vector3.TransformCoordinates(bavB, m));\n   // } \n   //else {\n   //   c = this.center;\n   // }\n    return c;\n  }\n\n  OnDisable() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n    this.ReconstructMeshLines();\n  }\n\n  ReconstructMeshLines() {\n    //Implemented by inheriting scripts\n\n  }\n\n\n  FixedUpdate() {\n    if (Engine.isPlaying) {\n      //Pretty hacky solution to allow for Inspector Updates.\n      if (this._isTrigger != this.wasTrigger) {\n        this.isTrigger = this._isTrigger;\n        this.wasTrigger = this._isTrigger;\n      }\n      this.layer = this.layer;\n      //this.layerMask = this.layerMask;      \n    }\n    \n  }\n\n  Update ()\n  {\n    //This is necessary for the collider gizmos to properly update...\n    //Probably gonna lead to some other issues?... We'll see\n    this.transform.Translate(0,0,0);\n  }\n\n  OnDestroy() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n\n    this.boundsMesh?.dispose();\n  }\n\n  //When the mesh changes, we need to recreate the Impostor\n  //With a Rigidbody, we only need to change some values.\n  UpdateValuesToImpostor() {\n    this.objectPhysics.physicsImpostor.type = this.GetImpostor();\n    this.isTrigger = this.isTrigger;\n    this.layer = this.layer;\n    this.layerMask = this.layerMask;\n    this.objectPhysics.physicsImpostor.setDeltaPosition(new BABYLON.Vector3(-this.center.x, -this.center.y, -this.center.z));\n    //this.objectPhysics.physicsImpostor.setDeltaPosition(new BABYLON.Vector3(0,0,0));\n    \n    //if (!ENABLE_EDITOR)\n      //this.transform.Translate(-this.center.x * 0.5, -this.center.y * 0.5, -this.center.z * 0.5);\n    \n    //this.transform.transformNode.translate(new BABYLON.Vector3(this.center.x, this.center.y, this.center.z), 1, BABYLON.Space.WORLD);\n  }\n\n}"
                    },
                    {
                        "BoxCollider.ts": "//script:BoxCollider\n@ExecuteInEditMode\n@RegisterAsComponent\nclass BoxCollider extends Collider {\n\n  @SerializeField\n  _size: Vector3 = new Vector3(1, 1, 1);\n\n  resizeObserver: BABYLON.Observer<any>;\n\n  get size(): Vector3 {\n    return this._size;\n  }\n\n  set size(value: Vector3) {\n    this._size?.onChange.remove(this.resizeObserver);\n    this._size = value;\n    this.resizeObserver = this._size.onChange.add(() => {\n      this.ReconstructMeshLines();\n    });\n    this._size.onChange.notifyObservers(null);\n  }\n\n\n\n  ReconstructMeshLines() {\n    this.bounds.reConstruct(\n      new BABYLON.Vector3(this.size.x * -0.5, this.size.y * -0.5, this.size.z * -0.5),\n      new BABYLON.Vector3(this.size.x * 0.5, this.size.y * 0.5, this.size.z * 0.5));\n\n    //Updating the bounding info so the physics impostor uses this info\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n\n  }\n\n  OnDrawGizmosSelected() {\n    Gizmos.color = new Color(0, 1, 0);\n    \n    let c = this.GetGizmoCenter();\n    \n    Gizmos.DrawCube(this.transform.position.clone().add(c), this.transform.lossyScale.clone().scale(this.size), this.transform.rotation);\n    Gizmos.color = new Color(1, 1, 1);\n  }\n\n  Awake() {\n    super.Awake();\n    this.size = this._size ? this._size.clone() : Vector3.One();\n    this.center = this._center ? this._center.clone() : Vector3.Zero();\n  }\n\n  public GetImpostor(): number {\n    return BABYLON.PhysicsImpostor.BoxImpostor;\n  }\n\n  FixedUpdate() {\n    super.FixedUpdate();\n    //Simple setter for SerializeField\n    this.size;\n    this.center;\n    \n  }\n\n  OnDestroy() {\n    this._size?.onChange.remove(this.resizeObserver);\n    this._center?.onChange.remove(this.recenterObserver);\n    super.OnDestroy();\n  }\n\n}"
                    },
                    {
                        "Joint.ts": "class Joint extends Component {\n\n  //TODO We need a way to drag and drop GameObjects\n  @SerializeField\n  nameOfConnectedObject: string = \"\";\n\n  @SerializeField\n  mainPivot: Vector3 = new Vector3();\n\n  @SerializeField\n  connectedPivot: Vector3 = new Vector3();\n\n  @SerializeField\n  mainAxis: Vector3 = new Vector3(0, 0, 1);\n\n  @SerializeField\n  connectedAxis: Vector3 = new Vector3(0, 0, 1);\n\n  @SerializeField\n  maxDistance: number = 0;\n\n  private joint: BABYLON.MotorEnabledJoint;\n  private jointData: BABYLON.DistanceJointData;\n\n  public get connectedBody(): ObjectPhysics {\n    if (!this._connectedBody) {\n      this._connectedBody = GameObject.Find(this.nameOfConnectedObject)?.objectPhysics;\n    }\n    return this._connectedBody;\n  }\n\n  private _connectedBody: ObjectPhysics;\n\n  private connectedImpostor: BABYLON.PhysicsImpostor;\n  private mainImpostor: BABYLON.PhysicsImpostor;\n\n  Awake() {\n\n  }\n\n  Regenerate(): BABYLON.PhysicsJoint {\n    if (this.joint) {\n      this.Clear();\n    }\n\n    this.mainImpostor = this.gameObject.objectPhysics?.physicsImpostor;\n    this.connectedImpostor = this.connectedBody?.physicsImpostor;\n\n    //If we can't generate - don't do anything.\n    if (!this.mainImpostor || !this.connectedImpostor) {\n      return;\n    }\n    this.jointData = {\n      mainPivot: Vector3.VtoB(this.mainPivot),\n      connectedPivot: Vector3.VtoB(this.connectedPivot),\n      mainAxis: Vector3.VtoB(this.mainAxis),\n      connectedAxis: Vector3.VtoB(this.connectedAxis),\n      maxDistance: this.maxDistance\n    };\n\n   // print(this.jointData.mainPivot);\n\n    this.joint = new BABYLON.MotorEnabledJoint(BABYLON.PhysicsJoint.HingeJoint,  this.jointData);\n\n    this.connectedImpostor.addJoint(this.mainImpostor, this.joint);\n    this.joint.setMotor(10);\n    return this.joint;\n  }\n\n  FixedUpdate() {\n    if (!this.mainImpostor || !this.connectedImpostor) {\n\n      this.Regenerate();\n    }\n  }\n\n  OnDestroy() {\n    if (Engine.isPlaying) {\n      this.gameObject.objectPhysics.MarkForUpdate();\n    }\n  }\n\n  Clear() {\n    Engine.scene.getPhysicsEngine().removeJoint(this.mainImpostor, this.connectedImpostor, this.joint);\n  }\n\n}\n\n"
                    },
                    {
                        "SphereCollider.ts": "@ExecuteInEditMode\n@RegisterAsComponent\nclass SphereCollider extends Collider {\n\n  @SerializeField\n  radius: number = 1;\n  private prevRadius: number = 0;\n\n  //Increase to get more round gizmos\n  //private gizmoPrecision = 150;\n\n  //This is a magical number to allow for the drawn gizmos to be the same as the radius in engine\n  //private radiusMultiplier = 75;\n\n  public GetImpostor(): number {\n    return BABYLON.PhysicsImpostor.SphereImpostor;\n  }\n\n  FixedUpdate() {\n    if (this.radius != this.prevRadius) {\n      this.prevRadius = this.radius;\n      this.ReconstructMeshLines();\n    }\n    super.FixedUpdate();\n  }\n\n  OnDrawGizmosSelected() {\n    Gizmos.color = new Color(0,1,0);\n    \n    let v= this.transform.lossyScale;    \n    \n    let c = this.GetGizmoCenter();\n\n    Gizmos.DrawSphere(this.transform.position.add(c), this.radius * Mathf.Max(Mathf.Max(v.x, v.y), v.z));\n    Gizmos.color = new Color(1,1,1);\n  }\n\n  ReconstructMeshLines() {\n    this.bounds.reConstruct(\n      new BABYLON.Vector3(-this.radius * 0.5, -this.radius * 0.5, -this.radius * 0.5),\n      new BABYLON.Vector3(this.radius * 0.5, this.radius * 0.5, this.radius * 0.5));\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n  }\n}"
                    },
                    {
                        "ObjectPhysics.ts": "\n//ObjectPhysics handling the connection of Colliders & Rigidbodies.\n//Because Babylon combines all of that in a PhysicsImpostor, both colliders and rigidbodies affect the same ObjectPhysics\nclass ObjectPhysics /*implements BABYLON.IPhysicsEnabledObject */ {\n\n  public static colliderMap: Map<number, Collider> = new Map();\n  public triggerMap: Map<number, boolean> = new Map();\n\n  public get isKinematic(): boolean {\n    return this._isKinematic;\n  }\n\n  public set isKinematic(value: boolean) {\n    this._isKinematic = value;\n  }\n\n  private _isKinematic: boolean;\n\n  public go: GameObject;\n\n  public get physicsImpostor(): BABYLON.PhysicsImpostor {\n    return this.go.transform?.transformNode.physicsImpostor;\n  };\n\n  public set physicsImpostor(value: BABYLON.PhysicsImpostor) {\n    if (this.go.transform)\n      this.go.transform.transformNode.physicsImpostor = value;\n  };\n\n  private refresh: boolean = false;\n  private justRefreshed: boolean = false;\n\n  public get rb(): Rigidbody {\n    if (this._rb == null || this._rb.markedForDestroy) {\n      this._rb = this.go.GetComponent(Rigidbody);\n    }\n    return this._rb;\n  }\n\n  private _rb: Rigidbody;\n\n  public get parentRb(): Rigidbody {\n    if (this._parentRb == null || this._parentRb.markedForDestroy) {\n      this._parentRb = this.go.GetComponentInParent(Rigidbody);\n    }\n    return this._parentRb;\n  }\n\n  private _parentRb: Rigidbody;\n\n  public get coll(): Collider {\n    if (this._coll == null || this._coll.markedForDestroy) {\n      this._coll = this.go.GetComponent(Collider);\n    }\n    return this._coll;\n  }\n\n  private _coll: Collider;\n\n  private collidingImpostors: BABYLON.PhysicsImpostor[];\n\n  private afterStepObserver: BABYLON.Observer<any>;\n  private beforeStepObserver: BABYLON.Observer<any>;\n\n  private joint: Joint;\n\n  Init(go: GameObject) {\n    this.go = go;\n    //beforeStepObservable runs every timeStep\n    //beforePhysicsObservable runs every subTimeStep\n    this.beforeStepObserver = Engine.scene.onBeforeStepObservable.add(() => {\n\n      if (this.refresh) {\n        this.UpdatePhysicsImpostor();\n      }\n    });\n    this.afterStepObserver = Engine.scene.onAfterStepObservable.add(() => {\n\n      if (this.justRefreshed && this.rb) {\n        //This might look insane, but(!) due to the multiple generated object physics objects,\n        //Objects tend to shoot away at the start. To avoid this from happening, we reset the velocity for one frame\n        //We don't set it to 0, in case the developer already set the velocity themselves\n        //@ts-ignore\n        this.rb.velocity = this.rb._vel;\n        //@ts-ignore\n        this.rb.angularVelocity = this.rb._angularVel;\n        this.justRefreshed = false;\n      }\n    });\n\n  }\n\n  public MarkForUpdate() {\n\n    this.refresh = true;\n    // this.TryDisposePhysicsImpostor();\n  }\n\n  TryDisposePhysicsImpostor() {\n    //We have to remove the old physicsImposter\n    if (this.physicsImpostor) {\n\n      if (this.coll) {\n        this.physicsImpostor.setDeltaPosition(Vector3.VtoB(this.coll.center));\n\n        //Setting this to a trigger just to avoid it colliding with anything as it's being destroyed\n        if (this.physicsImpostor.physicsBody) {\n          this.physicsImpostor.physicsBody.collisionResponse = 0;\n        }\n\n        ObjectPhysics.colliderMap.delete(this.coll.boundsMesh.uniqueId);\n      }\n      try {\n        this.physicsImpostor.dispose();\n      } catch (e) {\n        Debug.Log(e)\n\n        //Had to try catch this because of some internal Babylon error where it can't remove event listeners for parented objects\n      }\n      this.physicsImpostor = null;\n    }\n  }\n\n  private GetImpostorType() {\n    //Justs a Rigidbody collides with nothing\n    let imposterType = BABYLON.PhysicsImpostor.NoImpostor;\n    //If it's compound, the imposterType is NoImpostor, which automatically grabs the child Colliders\n    if (this.rb?.isActiveAndEnabled) {\n      //This is a rigidbody...\n      let childrenColliders = this.go.GetComponentsInChildren(Collider);\n      //If it has no collider itself, update the children colliders first\n      if (!this.coll?.isActiveAndEnabled) {\n        childrenColliders.forEach((c: Collider) => {\n          if (c !== this.coll) {\n\n            //We update the children colliders BEFORE the Rigidbody.\n            c.gameObject.objectPhysics.UpdatePhysicsImpostor();\n          }\n        });\n        return imposterType;\n      }\n    }\n    return this.coll.GetImpostor();\n  }\n\n  UpdatePhysicsImpostor() {\n    this.TryDisposePhysicsImpostor();\n    this.refresh = false;\n\n\n\n    //This is usually just when the GameObject is being Destroyed.\n    if (this.go.markedForDestroy || this.go.transform == null) {\n      return;\n    }\n\n    if (!(this.coll?.isActiveAndEnabled || this.rb?.isActiveAndEnabled)) {\n      return;\n    }\n\n\n    let imposterType = this.GetImpostorType();\n\n    //Debug.Log(\"Setting up \" + this.go.name);\n\n    let mass = 0;\n    if (this.rb && !this.rb.isKinematic) {\n      mass = this.rb.mass;\n    }\n\n    //We unparent before creating the physics impostor\n    //This is because of a bug where the parents rotation is not considered properly when creating a physics impostor\n    var prevParent = this.go.transform.parent;\n\n    this.go.transform.SetParent(null, true);\n    //We store these since it seems like the PhysicsImpostor can sometimes move/rotate the physics body for no reason.\n    let prevPosition = this.go.transform.localPosition.clone();\n    let prevRotation = this.go.transform.localEulerAngles.clone();\n\n    //Reset the rotation before creating the physics impostor.\n    //This is because rotated colliders confuse the physicsimpostor creation, specifically for compound collider\n    this.go.transform.localEulerAngles = new Vector3();\n\n    this.physicsImpostor = new BABYLON.PhysicsImpostor(this.go.transform.transformNode,\n      imposterType,\n      //Set to mass here so setMass(0) actually updates\n      //ignoreParent is set to false -  must be false for compound colliders \n      //With it set to false, the child rigidbody is just ignored.\n      { mass: mass, restitution: 1, ignoreParent: false },\n      Engine.scene);\n\n    //We have to call this setter once in order for friction to work...\n    this.physicsImpostor.friction = 0.5;\n\n    if (this.rb?.isActiveAndEnabled) {\n      this.collidingImpostors = Engine.scene._physicsEngine.getImpostors();\n      this.physicsImpostor.registerOnPhysicsCollide(this.collidingImpostors, (main, collided) => {\n        this.InternalOnCollide(collided);\n      });\n    }\n\n\n    if (this.rb?.isActiveAndEnabled) {\n      this.rb.UpdateValuesToImpostor();\n    }\n\n    if (this.coll?.isActiveAndEnabled) {\n      this.coll.UpdateValuesToImpostor();\n      ObjectPhysics.colliderMap.set(this.coll.boundsMesh.uniqueId, this.coll);\n    }\n\n\n    this.go.transform.localPosition = prevPosition;\n\n    this.go.transform.localEulerAngles = prevRotation;\n\n    this.go.transform.SetParent(prevParent, true);\n\n\n\n\n\n    this.RegenerateJoints();\n    this.justRefreshed = true;\n  }\n\n  RegenerateJoints() {\n\n    let joints = this.go.GetComponents(Joint);\n    if (!joints)\n      return;\n\n    joints.forEach(joint => {\n      joint.Regenerate();\n    });\n\n  }\n\n  InternalOnCollide(collided: BABYLON.PhysicsImpostor) {\n    var otherObjPhysics = Physics.GetOp(collided.object);\n    var otherCollider: Collider = otherObjPhysics.coll;\n    if (!this.coll || !otherObjPhysics.coll)\n      return;\n\n    if (this.coll.isTrigger || otherCollider.isTrigger) {\n      //OnTriggerEvents are handled in the Physics class\n    }\n    else {\n      var c1 = new Collision();\n      c1.collider = otherCollider;\n      c1.gameObject = otherCollider.gameObject;\n      c1.transform = otherCollider.transform;\n      c1.rigidbody = otherCollider.GetComponent(Rigidbody);\n\n      var myVel = this.rb ? this.rb.velocity : new Vector3();\n      var theirVel = c1.rigidbody ? c1.rigidbody.velocity : new Vector3();\n      c1.relativeVelocity = new Vector3(myVel.x - theirVel.x, myVel.y - theirVel.y, myVel.z - theirVel.z);\n\n      var c2 = new Collision();\n      c2.collider = this.coll;\n      c2.gameObject = this.go;\n      c2.transform = this.go.transform;\n      c2.rigidbody = this.rb;\n      c2.relativeVelocity = new Vector3(-c1.relativeVelocity.x, -c1.relativeVelocity.y, -c1.relativeVelocity.z);\n      try {\n        this.go.OnCollisionEnter(c1);\n      } catch (e) {\n        Debug.Log(e);\n      }\n      try {\n        otherCollider.gameObject.OnCollisionEnter(c2);\n      } catch (e) {\n        Debug.Log(e);\n      }\n    }\n  }\n\n  OnDestroy() {\n    this.TryDisposePhysicsImpostor();\n\n    Engine.scene.onBeforeStepObservable.remove(this.beforeStepObserver);\n    Engine.scene.onAfterStepObservable.remove(this.afterStepObserver);\n\n  }\n\n  get mesh(): BABYLON.AbstractMesh {\n    return this.go.transform.transformNode;\n  }\n  /*\n    get position(): BABYLON.Vector3 {\n      return this.mesh.position;\n    }\n  \n    set position(value: BABYLON.Vector3) {\n      this.mesh.position = value;\n    }\n  \n    get rotationQuaternion(): BABYLON.Quaternion {\n      return this.mesh.rotationQuaternion;\n    }\n  \n    set rotationQuaternion(value: BABYLON.Quaternion) {\n      this.mesh.rotationQuaternion = value;\n    }\n  \n    get scaling(): BABYLON.Vector3 {\n      return this.mesh.scaling;\n    }\n  \n    set scaling(value: BABYLON.Vector3) {\n      this.mesh.scaling = value;\n    }\n  \n    getBoundingInfo(): BABYLON.BoundingInfo {\n      var b = this.mesh.getBoundingInfo();\n      return b;\n    }\n  \n    computeWorldMatrix(force?: boolean): BABYLON.Matrix {\n      return this.mesh.computeWorldMatrix(true);\n    }\n  \n    getVerticesData(kind: string): BABYLON.FloatArray {\n      return this.mesh.getVerticesData(kind);\n    }\n  \n    getAbsolutePivotPoint(): BABYLON.Vector3 {\n      return this.mesh.getAbsolutePivotPoint();\n    }\n  \n    getAbsolutePosition(): BABYLON.Vector3 {\n      return this.mesh.getAbsolutePosition();\n    }\n  \n    rotate(axis: BABYLON.Vector3, amount: number, space?: BABYLON.Space): BABYLON.TransformNode {\n      return this.mesh.rotate(axis, amount, space);\n    }\n  \n    translate(axis: BABYLON.Vector3, distance: number, space?: BABYLON.Space): BABYLON.TransformNode {\n      return this.mesh.translate(axis, distance, space);\n    }\n  \n    setAbsolutePosition(absolutePosition: BABYLON.Vector3): BABYLON.TransformNode {\n      return this.mesh.setAbsolutePosition(absolutePosition);\n    }\n  \n    getClassName(): string {\n      return this.mesh.getClassName();\n    }\n    */\n}\n\nclass Collision {\n  collider: Collider;\n  rigidbody: Rigidbody;\n  transform: Transform;\n  gameObject: GameObject;\n  relativeVelocity: Vector3;\n}"
                    }
                ]
            },
            {
                "UserSystems": [
                    {
                        "Time.ts": "class Time {\n    static timeStarted: number = 0;\n    \n    static get fixedTimeStep ()\n    {\n        return 0.0016667;\n    };\n\n    //static set fixedTimeStep (value : number )\n  //  {\n        //Engine.scene.getPhysicsEngine().setSubTimeStep(value* 1000);\n //   }\n\n    private static date: Date;\n\n    private static lastFrameTime;\n\n    private static _deltaTime;\n\n    static Init() {\n        this.date = new Date();\n        this.timeStarted = this.date.getTime();\n      //  Time.fixedTimeStep = 0.02;\n    }\n\n    static get deltaTime() {\n        return this._deltaTime;\n    }\n\n    static get time() {\n        return (new Date().getTime() - this.timeStarted) * 0.001;\n    }\n\n    static Update() {\n        this._deltaTime = this.time - this.lastFrameTime;\n        this.lastFrameTime = Time.time;\n    }\n}"
                    },
                    {
                        "Input.ts": "class Input {\n    private static codeToKeyState: Record<number, number>\n\n    private static nameToKeyState: Record<string, number>\n\n    private static indexToMouseButtonState: Record<number, number>\n\n    private static mouseDelta: BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static keyAxisRaw: BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static keyAxis: BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static sensitivity: number = 0.1;\n\n    private static mouseSensitivity = 0.1;\n\n\n\n\n    static Init() {\n        //Stores all input keys\n        //0 = down, 1 = held, 2 = up, 3 = none\n        Input.codeToKeyState = {};\n        Input.nameToKeyState = {};\n        Input.indexToMouseButtonState = {}\n\n        Engine.scene.actionManager = new BABYLON.ActionManager(Engine.scene);\n\n        Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {\n            if (Input.codeToKeyState[evt.sourceEvent.keyCode] != 1) {\n                Input.codeToKeyState[evt.sourceEvent.keyCode] = 0;\n                Input.nameToKeyState[evt.sourceEvent.key] = 0;\n            }\n        }));\n\n        Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {\n            Input.codeToKeyState[evt.sourceEvent.keyCode] = 2;\n            Input.nameToKeyState[evt.sourceEvent.key] = 2;\n        }));\n\n        Engine.scene.onPointerObservable.add((pointerInfo) => {\n\n            switch (pointerInfo.type) {\n                case BABYLON.PointerEventTypes.POINTERMOVE:\n                    this.mouseDelta.x = pointerInfo.event.movementX * this.mouseSensitivity;\n                    this.mouseDelta.y = pointerInfo.event.movementY * this.mouseSensitivity;\n                    break;\n\n                case BABYLON.PointerEventTypes.POINTERDOWN:\n                    if (Input.indexToMouseButtonState[pointerInfo.event.button] != 1) {\n                        Input.indexToMouseButtonState[pointerInfo.event.button] = 0;\n                    }\n                    break;\n\n                case BABYLON.PointerEventTypes.POINTERUP:\n                    Input.indexToMouseButtonState[pointerInfo.event.button] = 2;\n\n                    break;\n            }\n        });\n\n\n    }\n\n    static Update() {\n\n        this.ProcessAxes();\n\n        for (let k in Input.codeToKeyState) {\n            if (Input.codeToKeyState[k] == 0 || Input.codeToKeyState[k] == 2) {\n                Input.codeToKeyState[k]++;\n            }\n        }\n\n        for (let k in Input.nameToKeyState) {\n            if (Input.nameToKeyState[k] == 0 || Input.nameToKeyState[k] == 2) {\n                Input.nameToKeyState[k]++;\n            }\n        }\n\n        for (let k in Input.indexToMouseButtonState) {\n            if (Input.indexToMouseButtonState[k] == 0 || Input.indexToMouseButtonState[k] == 2) {\n                Input.indexToMouseButtonState[k]++;\n            }\n        }\n    }\n\n    static LateUpdate() {\n        //We reset this every frame because pointermove does not call when not moving\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n\n    static ProcessAxes() {\n        this.keyAxisRaw.x = 0;\n        this.keyAxisRaw.y = 0;\n\n        if (this.GetKey(KeyCode.LeftArrow) || this.GetKey(KeyCode.A)) {\n            this.keyAxisRaw.x -= 1;\n        }\n        if (this.GetKey(KeyCode.RightArrow) || this.GetKey(KeyCode.D)) {\n            this.keyAxisRaw.x += 1;\n        }\n\n        if (this.GetKey(KeyCode.UpArrow) || this.GetKey(KeyCode.W)) {\n            this.keyAxisRaw.y += 1;\n        }\n        if (this.GetKey(KeyCode.DownArrow) || this.GetKey(KeyCode.S)) {\n            this.keyAxisRaw.y -= 1;\n        }\n\n        this.keyAxis.x = Mathf.MoveTowards(this.keyAxis.x, this.keyAxisRaw.x, this.sensitivity);\n        this.keyAxis.y = Mathf.MoveTowards(this.keyAxis.y, this.keyAxisRaw.y, this.sensitivity);\n    }\n\n    static GetMouseButton(button: number): boolean {\n        return Input.indexToMouseButtonState[button] == 0 || Input.indexToMouseButtonState[button] == 1;;\n    }\n\n    static GetMouseButtonDown(button: number): boolean {\n        return Input.indexToMouseButtonState[button] == 0;\n    }\n\n    static GetMouseButtonUp(button: number): boolean {\n        return Input.indexToMouseButtonState[button] == 2;\n    }\n\n    static GetKey(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 0 || Input.nameToKeyState[key] == 1;\n        }\n        return Input.codeToKeyState[key] == 0 || Input.codeToKeyState[key] == 1;\n    }\n\n    static GetKeyDown(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 0;\n        }\n        return Input.codeToKeyState[key] == 0;\n    }\n\n    static GetKeyUp(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 2;\n        }\n        return Input.codeToKeyState[key] == 2;\n    }\n\n    static GetAxis(axisName: string): number {\n        switch (axisName) {\n            case \"Mouse X\":\n                return this.mouseDelta.x;\n            case \"Mouse Y\":\n                return this.mouseDelta.y;\n            case \"Horizontal\":\n                return this.keyAxis.x;\n            case \"Vertical\":\n                return this.keyAxis.y;\n            default:\n                Debug.Log(`Axisname ${axisName} does not exist! Currently the only options are Mouse X, Mouse Y, Horizontal & Vertical`);\n                break;\n        }\n    }\n\n}\n\nenum KeyCode {\n    Break = 3,\n    Backspace = 8,\n    Tab = 9,\n    Clear = 12,\n    Enter = 13,\n    Shift = 16,\n    Control = 17,\n    Alt = 18,\n    Pause = 19,\n    CapsLock = 20,\n    Hangul = 21,\n    Hanja = 25,\n    Escape = 27,\n    Conversion = 28,\n    NonConversion = 29,\n    Space = 32,\n    PageUp = 33,\n    PageDown = 34,\n    End = 35,\n    Home = 36,\n    LeftArrow = 37,\n    UpArrow = 38,\n    RightArrow = 39,\n    DownArrow = 40,\n    Select = 41,\n    Print = 42,\n    Execute = 43,\n    PrintScreen = 44,\n    Insert = 45,\n    Delete = 46,\n    Help = 47,\n    Alpha0 = 48,\n    Alpha1 = 49,\n    Alpha2 = 50,\n    Alpha3 = 51,\n    Alpha4 = 52,\n    Alpha5 = 53,\n    Alpha6 = 54,\n    Alpah7 = 55,\n    Alpha8 = 56,\n    Alpha9 = 57,\n    Colon = 58,\n    Semicolon = 59,\n    LessThan = 60,\n    Equals = 61,\n    Beta = 63,\n    CommercialAt = 64,\n    A = 65,\n    B = 66,\n    C = 67,\n    D = 68,\n    E = 69,\n    F = 70,\n    G = 71,\n    H = 72,\n    I = 73,\n    J = 74,\n    K = 75,\n    L = 76,\n    M = 77,\n    N = 78,\n    O = 79,\n    P = 80,\n    Q = 81,\n    R = 82,\n    S = 83,\n    T = 84,\n    U = 85,\n    V = 86,\n    W = 87,\n    X = 88,\n    Y = 89,\n    Z = 90,\n    WindowsKey = 91,\n    LeftCommand = 91,\n    RightWindow = 92,\n    RightCommand = 93,\n    Sleep = 95,\n    Keypad0 = 96,\n    Keypad1 = 97,\n    Keypad2 = 98,\n    Keypad3 = 99,\n    Keypad4 = 100,\n    Keypad5 = 101,\n    Keypad6 = 102,\n    Keypad7 = 103,\n    Keypad8 = 104,\n    Keypad9 = 105,\n    KeypadMultiply = 106,\n    KeypadAdd = 107,\n    KeypadPeriod = 108,\n    KeypadSubtract = 109,\n    DecimalPoint = 110,\n    KeypadDivide = 111,\n    F1 = 112,\n    F2 = 113,\n    F3 = 114,\n    F4 = 115,\n    F5 = 116,\n    F6 = 117,\n    F7 = 118,\n    F8 = 119,\n    F9 = 120,\n    F10 = 121,\n    F11 = 122,\n    F12 = 123,\n    F13 = 124,\n    F14 = 125,\n    F15 = 126,\n    F16 = 127,\n    F17 = 128,\n    F18 = 129,\n    F19 = 130,\n    F20 = 131,\n    F21 = 132,\n    F22 = 133,\n    F23 = 134,\n    F24 = 135,\n    F25 = 136,\n    F26 = 137,\n    F27 = 138,\n    F28 = 139,\n    F29 = 140,\n    F30 = 141,\n    F31 = 142,\n    F32 = 143,\n    NumLock = 144,\n    ScrollLock = 145,\n    AirplaneMode = 151,\n    CircumFlex = 160,\n    ExclamationMark = 161,\n    ArabicSemicolon = 162,\n    Hash = 163,\n    DollarSign = 164,\n    PageBackward = 166,\n    PageForward = 167,\n    Refresh = 168,\n    Asterisk = 170,\n}"
                    },
                    {
                        "Random.ts": "/**\nThe Random class can give you random values\n */\nclass Random {\n    static get seed(): number {\n        return this._seed;\n    }\n\n    static set seed(value: number) {\n        this._seed = value;\n        this._internalSeed = value;\n    }\n\n    private static _seed: number;\n    private static _internalSeed: number;\n\n    static Init() {\n        //We Initialize random with a Random seed, so if it's not set, it's unpredictable\n        Random.seed = Math.random();\n        //We call Random.Range once because for some reason the first call always returns a very small number...\n        Random.Range(0,1);\n    }\n\n    static get value() {\n        var modulus = 2 ** 32;\n        var a = 1664525;\n        var c = 1013904223;\n\n        var returnVal = Random._internalSeed / modulus;\n        Random._internalSeed = (a * Random._internalSeed + c) % modulus;\n        return returnVal;\n    }\n\n    static Range(min: number, max: number, wholeNumber: boolean = false) {      \n\n        var r: number = (Random.value * (max - min)) + min;\n\n        if (wholeNumber) {\n            return Math.floor(r);\n        }\n        return r;\n    }\n}"
                    },
                    {
                        "Mathf.ts": "class Mathf\n{\n  //TODO Optimize?\n  static get Rad2Deg () : number\n  {\n    return 180 / Math.PI;\n  }\n\n\n  static get Deg2Rad () : number\n  {\n        return Math.PI / 180;\n  }\n\n  static Lerp(v1: number, v2: number, value: number): number {\n    return Mathf.Clamp(this.LerpUnclamped(v1, v2, value), v1, v2);\n  }\n\n  static LerpUnclamped(v1: number, v2: number, value: number): number {\n\n    return v1 + ((v2 - v1) * value);\n  }\n\n  static Clamp (value : number, min : number, max : number) : number\n  {\n    if (min > max)\n    {\n      var t = max;\n      max = min;\n      min = t;\n    }\n    return Math.min(Math.max(value, min), max);\n  }\n\n  static Min (value : number, min : number) : number\n  {\n    return Math.min(value, min);\n  }\n\n  static Max (value : number, max : number) : number\n  {\n    return Math.max(value, max);    \n  }\n\n  static MoveTowards (current : number, target : number, maxDelta : number) : number\n  {\n    if (current < target - maxDelta)\n    {\n      return current + maxDelta;\n    } else if (current > target + maxDelta)\n    {\n      return current - maxDelta;\n    }\n    return target;\n  }\n  \n}\n\n\n"
                    },
                    {
                        "Debug.ts": "class Debug\n{\n  public static includeStackTraceByDefault : boolean = false;\n\n  static Log (info : any, includeStackTrace? : boolean)\n  {\n    if (!includeStackTrace)\n      includeStackTrace = Debug.includeStackTraceByDefault;\n      \n    var msg = (Time.time.toFixed(3).toString() + \": \" + info);\n    if (includeStackTrace)\n    {\n      consolelog(new Error(msg).stack);\n    } else {\n      consolelog(msg);\n    }\n  }\n}"
                    },
                    {
                        "SceneManager.ts": "//TODO rewrite this into a proper scene system\nclass SceneManager {\n\n    public static onSceneLoaded: BABYLON.Observable<Scene> = new BABYLON.Observable();\n    public static onPreSceneLoaded: BABYLON.Observable<Scene> = new BABYLON.Observable();\n\n    public static GetActiveScene(): Scene {\n        return this.activeScene;\n    }\n\n    private static activeScene: Scene;\n\n    static isReloading: boolean;\n\n    private static activeSceneName: string;\n\n    public static prefabLoaded: boolean;\n\n    public static sceneJSONData: string\n\n    public static justReloaded = false;\n\n    public static recordStateAfterReload: boolean = false;\n\n    private static selectedGameObjects: string[];\n\n    public static SaveCurrentScene() {\n        if (Engine.isPlaying) {\n            print(\"Can't save during playmode\");\n        } else {\n            this.activeScene.Save();\n        }\n    }\n\n    static Init() {\n        PixelPADEvents.onSceneClicked.add(name => {\n            if (SceneManager.activeScene) {\n                SceneManager.activeScene.Unload();\n            }\n            SceneManager.LoadScene(name);\n        });\n\n        PixelPADEvents.onSaveClicked.add(ev => {\n            SceneManager.SaveCurrentScene();\n        });\n    }\n\n    static ReloadCurrentScene() {\n\n        if (this.activeScene != null) {\n            var newName = this.activeScene.name;\n            this.LoadScene(newName);\n        }\n        else {\n            Debug.Log(\"No scene is currently loaded\")\n        }\n    }\n\n    public static LoadPrefab(name: string) {\n        this.LoadSceneOrPrefab(name);\n    }\n\n    public static LoadScene(name: string) {\n        this.LoadSceneOrPrefab(name);\n    }\n\n    /** Helper function to load a scene based on JSON Data */\n    public static LoadSceneData(data: string) {\n        if (ENABLE_EDITOR) {\n            SceneManager.selectedGameObjects = new Array();\n\n\n            EditorSelection.GetSelection().forEach(e => {\n                SceneManager.selectedGameObjects.push(e.transform.uniqueId);\n            });\n            EditorSelection.SetSelectedGameObject(null);\n        }\n        if (this.activeScene != null) {\n            this.activeScene.Unload();\n        }\n\n        this.sceneJSONData = data;\n\n        //Using this bool so Scenes are only reloaded at the very end of a frame\n        SceneManager.isReloading = true;\n    }\n\n    public static LoadSceneOrPrefab(name: string) {\n        //One day we should do this better.\n        this.prefabLoaded = !name.endsWith(\".scn\");\n\n        if (SceneManager.isReloading) {\n            return;\n        }\n\n        this.activeSceneName = name;\n        if (ENABLE_EDITOR) {\n            UnionEditor.SetTitle(name);\n        }\n        if (!Engine.isPlaying) {\n            Project.data.loadedSceneOrPrefab = name;\n        }\n\n        if (this.prefabLoaded) {\n            this.LoadSceneData(getPrefab(name));\n        } else {\n            this.LoadSceneData(getScene(name));\n        }\n\n        this.recordStateAfterReload = true;\n\n    }\n\n    private static LoadSceneImmdiate() {\n\n        SceneManager.isReloading = true;\n        this.activeScene = new Scene();\n        this.activeScene.name = this.activeSceneName;\n\n        SceneManager.onPreSceneLoaded.notifyObservers(this.activeScene);\n\n        //This loads all objects into the activeScene\n        Serializer.FromJSON(this.sceneJSONData, false);\n        /*\n        //If the sceneData is null, this is probably an empty scene/prefab\n        if (this.prefabLoaded && (!sceneData || sceneData.rootObjs.length == 0))\n        {\n            this.activeScene.rootObj = new GameObject();\n            this.activeScene.name = Prefab.SimpleName(name);\n        } else {\n            this.activeScene.rootObj = sceneData.rootObjs[0];\n        }        \n        */\n        if (ENABLE_EDITOR) {\n            SceneManager.selectedGameObjects.forEach(sGoId => {\n                this.activeScene.objs.forEach(obj => {\n                    if (obj.transform.uniqueId === sGoId) {\n\n                        this.justReloaded = true;\n                        EditorSelection.AddSelectedGameObject(obj as GameObject);\n                    }\n                });\n            });\n        }\n\n        SceneManager.isReloading = false;\n        SceneManager.onSceneLoaded.notifyObservers(this.activeScene);\n\n\n\n        if (this.recordStateAfterReload) {\n            Undo.MarkToRecordState();\n            this.recordStateAfterReload = false;\n        }\n    }\n\n    public static MarkSceneAsDirty() {\n        if (!Engine.isPlaying && !SceneManager.isReloading) {\n            Undo.MarkToRecordState();\n            markSceneDirty();\n        }\n    }\n\n\n    static Update() {\n        if (SceneManager.isReloading) {\n            this.LoadSceneImmdiate();\n        }\n        if (SceneManager.justReloaded) {\n            SceneManager.justReloaded = false;\n\n        }\n    }\n}"
                    },
                    {
                        "PlayerPrefs.ts": "//script:Serializer\n\nclass PlayerPrefs {\n\n\n  public static Save(jsonData: string) {\n\n    Engine.current.getHostDocument().cookie = jsonData + \"|||\";\n  }\n\n  public static Load(): string {\n    var cookie: string = Engine.current.getHostDocument().cookie;\n\n    if (cookie.startsWith(\"{\")) {\n      cookie = cookie.split(\"|||\")[0];\n      return cookie;\n    }\n    return null;\n  }\n\n  public static Clear() {\n    this.Save(\"{}\");\n\n  }\n}\n\nclass Project {\n  public static data: ProjectData;\n\n  public static Init() {\n    this.data = JSON.parse(PlayerPrefs.Load()) as ProjectData;\n    if (!this.data)\n      this.data = new ProjectData();\n  }\n\n  public static Save() {\n   // PlayerPrefs.Save(JSON.stringify(this.data));\n  }\n}\n\nclass ProjectData {\n\n  get loadedSceneOrPrefab(): string {\n    return this._loadedSceneOrPrefab;\n  };\n\n  set loadedSceneOrPrefab(value: string) {\n    this._loadedSceneOrPrefab = value;\n    Project.Save();\n  };\n\n  _loadedSceneOrPrefab: string = \"\";\n\n}"
                    },
                    {
                        "Lighting.ts": "class Lighting {\n\n  public static mainLight : BABYLON.Light;\n\n  private static shadowGenerators : BABYLON.ShadowGenerator[] = new Array();\n\n  private static casters : BABYLON.Mesh[] = new Array();\n\n  public static RemoveCastingMesh (m : BABYLON.Mesh)\n  {    \n    const index = this.casters.indexOf(m);\n    if (index > -1) {\n     \n      var removedMesh = this.casters.splice(index, 1)[0];\n      this.shadowGenerators.forEach((gen) => {\n        gen.removeShadowCaster(removedMesh);\n      });\n    }\n  }\n\n  public static AddCastingMesh(m : BABYLON.Mesh)\n  {\n    const index = this.casters.indexOf(m);\n    if (index == -1) {\n      this.casters.push(m);\n      this.shadowGenerators.forEach((gen) => {\n        gen.addShadowCaster(m, true);\n      });\n    }\n  }\n\n  public static AddLight (l : Light)\n  {\n    var generator = new BABYLON.ShadowGenerator(1024, l.light, true);\n    generator.useExponentialShadowMap = true;  \n    this.shadowGenerators.push(generator);\n    //We add all previous casters to our new light\n    this.casters.forEach((m : BABYLON.Mesh) => {\n      generator.addShadowCaster(m, true);\n    });\n  }\n\n  public static RemoveLight (l : Light)\n  {\n    let index = -1;\n    this.shadowGenerators.forEach((gen) => {\n      if (gen.getLight() == l.light)\n      {\n        index = this.shadowGenerators.indexOf(gen);\n        gen.dispose();\n      }\n    });\n\n    //Remove the generator from our array\n    if (index > -1) {\n      this.shadowGenerators.splice(index, 1);\n    }\n  }\n\n  //Start is called before the first frame update\n  static Init() {\n    \n    //Create main light\n    Lighting.mainLight = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), Engine.scene);\n    Lighting.mainLight.intensity = .3;\n\n    SceneManager.onPreSceneLoaded.add(scene => {\n     \n    });\n  }\n}\n"
                    },
                    {
                        "Cursor.ts": "class Cursor {\n\n  static Init ()\n  {\n     \n    Engine.scene.onPrePointerObservable.add((ev) => {\n      //When the cursor is unlocked somehow, we reset it to none here      \n      if (!Engine.current.isPointerLock && Cursor.lockState == CursorLockMode.Locked)\n      {\n        Cursor.lockState = CursorLockMode.None;\n      }\n\n      //We avoid moving the mouse when it's locked.\n      if (Cursor.lockState == CursorLockMode.Locked)\n      {\n        if (ev.type == BABYLON.PointerEventTypes.POINTERMOVE)\n        {\n          //Disabled this since it prevented mouse movement?\n          //ev.skipOnPointerObservable = true;\n        }\n      }\n    });\n  }\n\n\n  static get lockState (): CursorLockMode{\n    return this._lockState;\n  }\n\n  static set lockState(value:CursorLockMode)\n  {\n    Cursor._lockState = value;\n    switch(value)\n    {\n      case CursorLockMode.Locked:\n        Engine.current.enterPointerlock();\n      break;\n      case CursorLockMode.None:\n        Engine.current.exitPointerlock();\n      break;\n      case CursorLockMode.Confined:\n        Debug.Log(\"Confined lockmode is currently not supported\")\n    }\n  }\n\n  private static _lockState : CursorLockMode;\n}\n\nenum CursorLockMode\n{\n  Locked,\n  Confined,\n  None\n}"
                    }
                ]
            },
            {
                "InternalSystems": [
                    {
                        "PixelPADEvents.ts": "/*\nAll External events coming from the PixelPAD website go through this wrapper\nThe only exception is the stop button - since this is handled directly in the engine.\n*/\n\n//TODO Clean this up into objects of a PixePADEventListenerClass\nclass PixelPADEvents {\n\n  public static onSceneClicked: BABYLON.Observable<string>;\n  public static onSaveClicked: BABYLON.Observable<string>;\n  public static onAssetClicked: BABYLON.Observable<string[]>;\n\n  //Start is called before the first frame update\n  static AddAllListeners() {\n    PixelPADEvents.onSceneClicked = new BABYLON.Observable();\n    PixelPADEvents.onSaveClicked = new BABYLON.Observable();\n    PixelPADEvents.onAssetClicked = new BABYLON.Observable();\n\n    document.addEventListener(\"saveClicked\", this.OnSaveClicked);\n    document.addEventListener(\"assetClicked\", this.OnAssetClicked);\n  }\n\n  static ClearAllListeners() {\n    document.removeEventListener(\"saveClicked\", this.OnSaveClicked);\n    document.removeEventListener(\"assetClicked\", this.OnAssetClicked);\n\n\n    PixelPADEvents.onSceneClicked.clear();\n    PixelPADEvents.onSaveClicked.clear();\n    PixelPADEvents.onAssetClicked.clear();\n  }\n\n  private static OnResize (e : any)\n  {\n    print(1)\n  }\n\n  private static OnAssetClicked(e: CustomEvent) {\n    switch (e.detail.assetType) {\n      case \"scene\":\n        PixelPADEvents.onSceneClicked.notifyObservers(e.detail.assetName);\n        break;\n        //Ignore scripts\n      case \"script\":\n        break;       \n      default:\n        PixelPADEvents.onAssetClicked.notifyObservers([e.detail.assetType, e.detail.assetName]);\n        break;\n\n    }\n  }\n\n  private static OnSaveClicked(e: CustomEvent) {\n    PixelPADEvents.onSaveClicked.notifyObservers(null);\n  }\n\n}\n\n"
                    },
                    {
                        "TextureSystem.ts": "class TextureSystem\n{\n    //TODO This should be cached\n    public static GetSprite(shortName : string) : BABYLON.Texture\n    {\n        var url = getTexture(shortName);\n        if (!url)\n        {\n            return null;\n        }\n        var texture = new BABYLON.Texture(url, Engine.scene);\n        \n        return texture;\n    }\n}"
                    },
                    {
                        "MeshLoader.ts": "//Helps loading and caches meshes\nclass MeshLoader {\n    static enableLogging: boolean = true;\n    private static assetContainers: Map<string, BABYLON.AssetContainer>;\n    private static finishCallbacks: Map<string, { (data: BABYLON.InstantiatedEntries): void; }[]>;\n\n    //TODO move into base class\n    static Log(msg) {\n        if (MeshLoader.enableLogging) {\n            print(msg)\n        }\n    }\n\n    static Init() {\n        MeshLoader.assetContainers = new Map();\n        MeshLoader.finishCallbacks = new Map();\n    }\n\n    //** Cached way of loading meshes*/\n    public static Load(name: string, onLoaded: (models: BABYLON.InstantiatedEntries) => void) {\n        if (MeshLoader.assetContainers.has(name)) {\n\n            let container = MeshLoader.assetContainers.get(name);\n            if (container) {\n                //If the container was already loaded, this is simple\n                //Creates a clone\n                onLoaded(container.instantiateModelsToScene());\n                return;\n            }\n        } else {\n            //For unloaded meshes - load from cache\n            let modelUrl = URLResult.Create(name, FileType.Model);\n            if (modelUrl.baseUrl == null) {\n                print(\"Could not load mesh \" + name + \". Are you sure it exists?\");\n                return;\n            }\n            MeshLoader.assetContainers.set(name, null);\n            MeshLoader.finishCallbacks.set(name, []);\n            //Using a container allows us to load the asset before adding to a scene\n            //In this case, it prevents a single frame flicker where the mesh would show up\n            BABYLON.SceneLoader.LoadAssetContainer(modelUrl.baseUrl, modelUrl.fullName, Engine.scene, (container) => {\n\n                MeshLoader.assetContainers.set(name, container);\n                for (var i = 0; i < container.animationGroups.length; i++) {\n                    container.animationGroups[i].pause();\n                }\n\n                //When the file is actually loaded, all requests will receive a loaded update at the same time\n                MeshLoader.finishCallbacks.get(name).forEach(fCb => {\n                    fCb(MeshLoader.assetContainers.get(name).instantiateModelsToScene());\n                });\n                MeshLoader.finishCallbacks[name] = [];\n            });\n        }\n        //This could happen if I request a mesh that is currnetly being loaded.\n        //We push this to the list of finishcallbacks\n        MeshLoader.finishCallbacks.get(name).push(onLoaded);\n    }\n\n    /*\n    //Tries and gets the mesh for the different objects\n    static GetMesh(name) {\n        //Bit hacky\n        if (name === \"box\" || name === \"sphere\") {\n            var defaultMesh = [];\n            if (name == \"box\") {\n                defaultMesh.push(BABYLON.Mesh.CreateBox(name, 1, Engine.scene));\n            } else {\n                defaultMesh.push(BABYLON.Mesh.CreateSphere(name, 8, 1, Engine.scene));\n            }\n            return defaultMesh;\n        }\n\n\n        //meshTaskToMap has a list of all loading/loading meshes\n        //If it's not in there, it should be loaded at that time.\n        var meshTask: BABYLON.MeshAssetTask = MeshLoader.assetContainers[name];\n\n        if (meshTask == null) {\n            this.LoadMesh(name);\n            return null;\n        }\n\n        if (!meshTask.isCompleted) {\n            return null;\n        }\n\n        //If the mesh has been loaded, we return a copy of it.\n        //This ensures the mesh is only loaded once!\n        var meshes = [...MeshLoader.meshTaskMap[name].loadedMeshes];\n        for (var i = 0; i < meshes.length; i++) {\n            meshes[i] = meshes[i].clone(\"Clone_\" + i, null);\n        }\n\n        return meshes;\n    }\n    */\n}\n\n"
                    }
                ]
            },
            {
                "UI": [
                    {
                        "RectTransform.ts": "enum HorizontalAlignment {\n  Left,\n  Center,\n  Right\n}\n\nenum VerticalAlignment {\n  Top,\n  Middle,\n  Bottom\n}\n\n\n@ExecuteInEditMode\nclass RectTransform extends Transform {\n\n  @SerializeEnumField(HorizontalAlignment)\n  horAlignment = HorizontalAlignment.Center;\n\n  @SerializeEnumField(VerticalAlignment)\n  verAlignment = VerticalAlignment.Middle;\n\n  @SerializeField\n  width = 100;\n\n  @SerializeField\n  isPercentageWidth = false;\n\n  @SerializeField\n  height = 100;\n\n\n  @SerializeField\n  isPercentageHeight = false;\n\n  private static wireFrameMat: BABYLON.Material;\n\n  //TODO this shouldn't be accessible by users\n  public babContainers: BABYLON.GUI.Container[];\n\n  //TODO this shouldn't be accessible by users\n  public pickMesh: BABYLON.Mesh;\n\n  private _canvas: NewCanvas;\n\n  private posChangeObserver: BABYLON.Observer<Vector3>;\n\n  private _firstFrame: boolean = true;\n  private isUpdatingPosFromUI = false;\n\n  private get canvasRatio() {\n    return this._canvas.height / this._canvas.width;\n  }\n\n  PreAwake() {\n    //The order is essential here.\n    if (!RectTransform.wireFrameMat) {\n      RectTransform.wireFrameMat = new BABYLON.Material(\"UIWireFrame\", Engine.scene);\n    }\n    this.babContainers = new Array();\n\n\n    this.transformNode = new BABYLON.Mesh(this.gameObject.name, Engine.scene);\n\n    this.pickMesh = BABYLON.Mesh.CreatePlane(\"PickMesh\", 1, Engine.scene);\n    this.pickMesh.setParent(this.transformNode);\n    this.pickMesh.layerMask = 4;\n    this.pickMesh.material = RectTransform.wireFrameMat;\n\n    super.PreAwake();\n  }\n\n  InternalAwake(go) {\n    //TODO we SHOULDN't use InternalAwake here! \n    //Hotfix: entirely in a try catch...\n    try {\n\n      if (this.markedForDestroy)\n        return;\n\n      let myPoints = [\n        new BABYLON.Vector3(-0.5, -0.5, 0),\n        new BABYLON.Vector3(-0.5, 0.5, 0),\n        new BABYLON.Vector3(0.5, 0.5, 0),\n        new BABYLON.Vector3(0.5, -0.5, 0),\n        new BABYLON.Vector3(-0.5, -0.5, 0)\n      ];\n\n      let boundingBoxLines = BABYLON.MeshBuilder.CreateLines(\"lines\", { points: myPoints }, Engine.scene);\n      boundingBoxLines.setParent(this.pickMesh);\n      boundingBoxLines.color = BABYLON.Color3.White();\n      boundingBoxLines.position = BABYLON.Vector3.Zero();\n      boundingBoxLines.rotation = BABYLON.Vector3.Zero();\n      boundingBoxLines.scaling = BABYLON.Vector3.One();\n      boundingBoxLines.layerMask = 4;\n\n      super.InternalAwake(go);\n\n\n      if (this.transform !== this) {\n        this.localPosition = this.transform.localPosition.clone();\n        this.localEulerAngles = this.transform.localEulerAngles.clone();\n        this.localScale = this.transform.localScale.clone();\n        var parent = this.transform.parent;\n\n        //We Destroy the transform, but also set the parent to null, to avoid it creating a 'ghost' object\n        Destroy(this.transform);\n        this.transform.SetParent(null);\n\n        //Place RectTransform as first component\n        this.gameObject.components.unshift(this.gameObject.components.pop());\n        this.SetParent(parent, true);\n\n      }\n\n\n      this._canvas = this.GetComponentInParent(NewCanvas);\n      if (!this._canvas) {\n        this._canvas = GameObject.FindObjectOfType(NewCanvas);\n      }\n      if (!this._canvas) {\n        this._canvas = Instantiate(NewCanvas);\n        this._canvas.name = \"Canvas\";\n      }\n\n      if (!this._canvas.canvasTextures)\n      {\n        Debug.Log(\"Error finding canvastextures. This happens when a canvas is disabled and needs to be fixed!!!\");\n        return;\n      }\n\n      this._canvas.canvasTextures.forEach((advancedTexture) => {\n        var babContainer = new BABYLON.GUI.Container(this.gameObject.name);\n        babContainer.isPointerBlocker = false;\n        babContainer.clipChildren = true;\n        babContainer.clipContent = true;\n\n        babContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n        this.babContainers.push(babContainer);\n        advancedTexture.addControl(babContainer);\n      });\n\n      this.UpdateAlignment();\n    } catch (e) {\n      Debug.Log(e, true);\n    }\n  }\n\n  OnEnable() {\n    this.babContainers.forEach(babControl => {\n      babControl.isVisible = true;\n    });\n  }\n\n  OnDisable() {\n\n    this.babContainers.forEach(babControl => {\n      babControl.isVisible = false;\n    });\n  }\n\n  Start() {\n    super.Start();\n\n    this.posChangeObserver = this.onPositionChange.add((pos) => {\n      this.UpdateUIFromPos(pos);\n    });\n  }\n\n  public SetParent(parent: Transform, worldPositionStays: boolean = true) {\n\n    if (parent === this.transform)\n      return;\n\n    //Remove old parent\n    for (var i = 0; i < this.babContainers.length; i++) {\n      this.babContainers[i].parent?.removeControl(this.babContainers[i]);\n    }\n\n    super.SetParent(parent, worldPositionStays);\n\n    /*\n    UI hierarchy explained\n    AdvancedDynamicTexture\n      BabContainer\n        Image\n      BabContainer\n        Text <- Text can not be a BabContainer\n        BabContainer\n          Text\n      BabContainer\n        Button <- The Button is a BabContainer itself!\n          BabContainer\n            Text\n    */\n\n    //Set new parent\n    //For some reason .parent does not work for GUI\n    for (var i = 0; i < this.babContainers.length; i++) {\n      var rectParent = parent as RectTransform;\n      if (rectParent && rectParent.babContainers) {\n        var newParent = rectParent.babContainers[i];\n        //Buttons require children to be parented to the button\n        //This is so that if you add an image to a button, it does not block it.\n        var button = parent.GetComponent(Button);\n        if (button != null) {\n          let guiButton = button._babControls[i];\n          if (guiButton instanceof BABYLON.GUI.Button) {\n            newParent = guiButton;\n          } else {\n            Debug.Log(\"Something is wrong herre...\", true);\n          }\n        }\n\n        newParent.addControl(this.babContainers[i]);\n      } else {\n        this._canvas.canvasTextures[i].addControl(this.babContainers[i]);\n      }\n    }\n  }\n\n  frames = 0;\n\n  Update() {\n    super.Update();\n    this.transform.localScale = Vector3.One();\n    this.UpdateAlignment();\n    this.frames++;\n\n    if (this._firstFrame) {\n\n      this._firstFrame = false;\n      //Do we need this??\n      this.SetParent(this.transform.parent);\n    }\n\n    this.UpdateUIFromPos(this.localPosition);\n\n    this.UpdateScale();\n  }\n\n\n  UpdateUIFromPos(pos: Vector3) {\n\n    this.babContainers.forEach(babContainer => {\n      babContainer.leftInPixels = (pos.x) * this._canvas.scaleFactor;\n      //print(babControl.leftInPixels)\n      babContainer.topInPixels = (-pos.y * this._canvas.width / this._canvas.height) * this._canvas.scaleFactor;\n    });\n\n    let babContainer = this.babContainers[0];\n    let pickPos = new BABYLON.Vector3();\n    while (babContainer) {\n      let po = this.AnchorOffset(babContainer, true);\n      let bo = this.AnchorOffset(babContainer, false);\n      pickPos.addInPlaceFromFloats(po.x - bo.x, po.y - bo.y, 0);\n      babContainer = this.GetBabParent(babContainer);\n    }\n\n    this.pickMesh.position = pickPos;\n  }\n\n  private GetBabParent(babContainer: BABYLON.GUI.Container) {\n    let parentContainer = babContainer.parent;\n    //Because buttons are the containers of their childrne\n    if (parentContainer instanceof BABYLON.GUI.Button) {\n      parentContainer = babContainer.parent.parent;\n    }\n    return parentContainer;\n  }\n\n  AnchorOffset(babContainer: BABYLON.GUI.Container, useParentSize = false): Vector2 {\n\n    let v = new Vector2();\n    if (babContainer.parent || !useParentSize) {\n      v.x = useParentSize ? babContainer.parent.widthInPixels : babContainer.widthInPixels;\n      v.y = (useParentSize ? babContainer.parent.heightInPixels : babContainer.heightInPixels) * this.canvasRatio;\n    }\n\n    switch (babContainer.horizontalAlignment) {\n      case BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT:\n        v.x *= -0.5;\n        break;\n      case BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER:\n        v.x *= 0;\n        break;\n      case BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT:\n        v.x *= 0.5;\n        break;\n      default:\n        break;\n    }\n\n    switch (babContainer.verticalAlignment) {\n      case BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP:\n        v.y *= 0.5;\n        break;\n      case BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER:\n        v.y *= 0;\n        break;\n      case BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM:\n        v.y *= -0.5;\n        break;\n      default:\n        break;\n    }\n\n    return v;\n  }\n\n  prevHorAlignment = -1;\n  prevVerAlignment = -1;\n\n  UpdateAlignment() {\n    if (this.horAlignment !== this.prevHorAlignment) {\n      this.prevHorAlignment = this.horAlignment;\n\n      this.babContainers.forEach(babContainer => {\n        switch (this.horAlignment) {\n          case HorizontalAlignment.Left:\n            babContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n            break;\n          case HorizontalAlignment.Center:\n            babContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n            break;\n          case HorizontalAlignment.Right:\n            babContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n            break;\n          default:\n            break;\n        }\n\n      });\n      this.UpdateUIFromPos(this.localPosition);\n\n    }\n\n    if (this.verAlignment !== this.prevVerAlignment) {\n      this.prevVerAlignment = this.verAlignment;\n\n      this.babContainers.forEach(babContainer => {\n        switch (this.verAlignment) {\n          case VerticalAlignment.Top:\n            babContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n            break;\n          case VerticalAlignment.Middle:\n            babContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n            break;\n          case VerticalAlignment.Bottom:\n            babContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n            break;\n          default:\n            break;\n        }\n      });\n      this.UpdateUIFromPos(this.localPosition);\n\n    }\n  }\n\n  UpdateScale() {\n    this.babContainers.forEach(babContainer => {\n\n      babContainer.width = this.width.toString() + (this.isPercentageWidth ? \"%\" : \"px\");\n      babContainer.height = this.height.toString() + (this.isPercentageHeight ? \"%\" : \"px\");\n\n      this.pickMesh.scaling = new BABYLON.Vector3(babContainer.widthInPixels * this._canvas.scaleFactor, babContainer.heightInPixels * this.canvasRatio * this._canvas.scaleFactor, 1);\n\n    });\n  }\n\n  OnDestroy() {\n    super.OnDestroy();\n    this.pickMesh?.dispose();\n    this.babContainers.forEach(babControl => {\n      babControl?.dispose();\n    });\n    this.onPositionChange.remove(this.posChangeObserver);\n  }\n\n}\n"
                    },
                    {
                        "TextLabel.ts": "class TextLabel extends MonoBehaviour\n{\n  //MUST HAVE A DEFAULT VALUE OR MIGHT CRASH!\n  public text : string = \"\";\n\n  private label : BABYLON.GUI.TextBlock;\n\n  Awake ()\n  {\n    this.label = new BABYLON.GUI.TextBlock();\n    this.label.color = \"white\";\n    this.label.fontSize = 30;\n    this.label.outlineColor = \"black\";\n    this.label.outlineWidth = 3;\n    this.label.shadowColor = \"black\";\n    this.label.shadowOffsetX = 2;\n    this.label.shadowOffsetY = 2;\n\n    CanvasOld.main.addControl(this.label);\n    this.label.linkWithMesh(this.renderer.GetMesh());\n  }\n\n  Update ()\n  {\n    this.label.text = this.text;\n    \n  }\n}"
                    },
                    {
                        "NewCanvas.ts": "@ExecuteInEditMode\nclass NewCanvas extends MonoBehaviour {\n\n  boundingBoxLines: BABYLON.LinesMesh;\n\n  //One day I will solve this.\n  public scaleFactor = 1;\n\n  public get changedSize ()\n  {\n    return this._changedSize;\n  }\n\n  private _changedSize = true;\n\n  private prevWidth: number = 0;\n  private prevHeight: number = 0;\n\n  //Singleton pattern\n  public static get instance(): NewCanvas {\n    if (NewCanvas._instance == null || NewCanvas._instance == undefined) {\n      NewCanvas._instance = Instantiate(NewCanvas);\n    }\n    return NewCanvas._instance;\n  }\n\n  private static _instance: NewCanvas;\n\n  public get canvasTextures(): BABYLON.GUI.AdvancedDynamicTexture[] {\n    return this._canvasTextures;\n  }\n\n  private _canvasTextures: BABYLON.GUI.AdvancedDynamicTexture[];\n\n  public get editorRenderPlane(): BABYLON.Mesh {\n    return this._editorRenderPlane;\n  }\n\n  private _editorCanvas: BABYLON.GUI.AdvancedDynamicTexture;\n  private _editorRenderPlane: BABYLON.Mesh;\n  private _canvasBlocker: BABYLON.GUI.Rectangle;\n\n  public get width() {\n    if (ENABLE_EDITOR) {\n      return UnionEditor.gameView.background.widthInPixels;\n    } else {\n      return Engine.canvas.width;\n    }\n  }\n\n  public get height() {\n    if (ENABLE_EDITOR) {\n      return UnionEditor.gameView.background.heightInPixels;\n    } else {\n      return Engine.canvas.height;\n    }\n  }\n\n  Awake() {\n    this._canvasTextures = new Array();\n\n\n    //2D scene Canvas\n    var canvas = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"Canvas\", true, Engine.scene);\n    canvas.layer.layerMask = 3;\n    this._canvasTextures.push(canvas);\n\n    if (ENABLE_EDITOR) {\n\n      //Blocking this canvas to avoid any button clicks\n      this._canvasBlocker = new BABYLON.GUI.Rectangle();\n      this._canvasBlocker.width = \"100%\";\n      this._canvasBlocker.height = \"100%\";\n      this._canvasBlocker.zIndex = 99999;\n      this._canvasBlocker.alpha = 0;\n      canvas.addControl(this._canvasBlocker);\n\n      //Editor Canvas\n      this._editorRenderPlane = BABYLON.Mesh.CreatePlane(\"plane\", 1 / this.scaleFactor, Engine.scene);\n      this._editorRenderPlane.layerMask = 4;\n      this._editorRenderPlane.isPickable = false;\n\n      this._editorCanvas = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(this._editorRenderPlane, 10, 10, false);\n      this._canvasTextures.push(this._editorCanvas);\n    }\n\n  }\n\n  Update() {\n    if (ENABLE_EDITOR) {\n      this.editorRenderPlane.position = this.transform.transformNode.position.clone();\n      this.editorRenderPlane.rotationQuaternion = this.transform.transformNode.rotationQuaternion.clone();\n    }\n\n    this.transform.localScale = new Vector3((1 / this.scaleFactor) / this.width, (1 / this.scaleFactor) / this.height, 1);\n\n    this._changedSize = (Math.abs(this.width - this.prevWidth) + Math.abs(this.height - this.prevHeight)) > 0.1;\n\n    if (this._changedSize) {\n      this.prevWidth = this.width;\n      this.prevHeight = this.height;\n\n      if (ENABLE_EDITOR) {\n        var ratio = this.height / this.width;\n        this._editorRenderPlane.scaling = new BABYLON.Vector3(1, ratio, 1);\n      }\n\n      this._canvasTextures.forEach(canvas => {\n        canvas.scaleTo(this.width, this.height);\n        canvas.markAsDirty();\n      });\n    }\n\n    if (ENABLE_EDITOR) {\n      this.RedrawOutline();\n\n      if (EditorUI.GetPointerOverEditor() === UnionEditor.gameView) {\n        this._canvasBlocker.isEnabled = false;\n        if (Engine.isPlaying) {\n          if (Camera.main) {\n            Engine.scene.cameraToUseForPointers = Camera.main.bCam;\n          } else {\n            Debug.Log(\"The UI needs at least 1 camera active in your scene!\")\n          }\n        }\n      } else {\n        this._canvasBlocker.isEnabled = true;\n      }\n    }\n  }\n\n  //TODO Optimize\n  RedrawOutline() {\n    var b = this._editorRenderPlane.getBoundingInfo().boundingBox;\n\n    var myPoints = [\n      b.minimum,\n      new BABYLON.Vector3(b.minimum.x, b.maximum.y, 0),\n      b.maximum,\n      new BABYLON.Vector3(b.maximum.x, b.minimum.y, 0),\n      b.minimum\n    ];\n\n    if (this.boundingBoxLines)\n      this.boundingBoxLines.dispose();\n\n    this.boundingBoxLines = BABYLON.MeshBuilder.CreateLines(\"lines\", { points: myPoints }, Engine.scene);\n    this.boundingBoxLines.setParent(this._editorRenderPlane);\n    this.boundingBoxLines.color = BABYLON.Color3.White();\n    this.boundingBoxLines.position = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.rotation = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.scaling = BABYLON.Vector3.One();\n    this.boundingBoxLines.layerMask = 4;\n  }\n\n\n\n  OnDestroy() {\n    this._canvasTextures.forEach(canvas => {\n      canvas.dispose();\n    });\n\n    if (ENABLE_EDITOR) {\n      this.boundingBoxLines?.dispose();\n      this._editorRenderPlane?.dispose();\n    }\n\n    NewCanvas._instance = null;\n  }\n}\n"
                    },
                    {
                        "_UGUIElement.ts": "@ExecuteInEditMode\nclass UGUIElement extends MonoBehaviour {\n\n  protected get rectTransform(): RectTransform {\n    return this.transform as RectTransform;\n  }\n  \n  public _babControls: BABYLON.GUI.Control[];\n  \n  Awake() {\n    if (!this.GetComponent(RectTransform))\n    {\n      this.gameObject.AddComponent(RectTransform);\n    }\n    this._babControls = new Array();\n  }\n\n  //Start is called before the first frame update\n  Start() {\n    //this.CreateBabGUI();\n    this.rectTransform.babContainers.forEach(babContainer => {\n      var babControl = this.CreateBabGUI();\n      this._babControls.push(babControl);\n      babContainer.addControl(babControl);\n      babControl.width = \"100%\";\n      babControl.height = \"100%\";\n      babControl.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    });\n  }\n\n  CreateBabGUI(): BABYLON.GUI.Control\n  {\n    return null;\n  }\n\n  OnDestroy()\n  {\n    this._babControls.forEach(babControl => {\n      babControl.dispose();\n    });\n  }\n \n}\n"
                    },
                    {
                        "UIImage.ts": "@RegisterAsComponent\n@ExecuteInEditMode\nclass UIImage extends UGUIElement {\n\n  @SerializeField\n  link: string = \"\";\n\n  @SerializeField\n  keepAspectRatio = true;\n\n  private lastLink: string = \"\";\n\n  CreateBabGUI(): BABYLON.GUI.Control {\n    var image = new BABYLON.GUI.Image(\"BabImage\");\n    return image;\n  }\n\n  Update() {\n    super.Update();\n    this.CheckForSpriteUpdate();\n\n    this._babControls.forEach(b => {\n      var image = b as BABYLON.GUI.Image;\n      if (this.keepAspectRatio) {\n        image.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM;\n      } else {\n        image.stretch = BABYLON.GUI.Image.STRETCH_NONE;\n      }\n    });\n  }\n\n  CheckForSpriteUpdate() {\n    //If it was deserialized the meshName is set but LoadMesh is never called.\n    if (this.link != this.lastLink) {\n      this.lastLink = this.link;\n      if (this.link) {\n        let url = getTexture(this.link);\n\n        this._babControls.forEach(b => {\n          let image = b as BABYLON.GUI.Image;\n          image.source = url;\n          image.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM;\n        });\n      } else {\n        this._babControls.forEach(b => {\n          let image = b as BABYLON.GUI.Image;\n          image.source = \"\";\n        });\n      }\n    }\n\n\n  }\n\n\n\n}\n\n\n"
                    },
                    {
                        "Button.ts": "@ExecuteInEditMode\nclass Button extends UGUIElement {\n\n\n\n  private _buttonClicks: BABYLON.Observer<any>[] = new Array();\n\n  Start() {\n    super.Start();\n    this.rectTransform.ser_children.forEach(child => {\n      var rectTransform = child.transform as RectTransform;\n      if (rectTransform) {\n        for (var i = 0; i < rectTransform.ser_children.length; i++) {\n          let c = rectTransform.ser_children[i];\n          c.transform.SetParent(this.transform);\n        }\n      }\n    });\n  }\n\n  CreateBabGUI(): BABYLON.GUI.Control {\n    var button = new BABYLON.GUI.Button(\"Button\");\n    //Buttons are transparent themselves, but can have an image component\n    button.background = new BABYLON.Color4(1,1,1,0).toHexString();\n    this._buttonClicks.push(button.onPointerClickObservable.add((ev) => this.OnButtonClickInternal()));\n    return button;\n  }\n\n  OnButtonClickInternal() {\n    this._babControls.forEach(babControl => {\n      let button = babControl as BABYLON.GUI.Button;\n    });\n    this.gameObject.GetComponents(MonoBehaviour).forEach(c => {\n     \n      try {\n         //@ts-ignore\n        c.OnButtonClick();\n      }\n      catch(e)\n      {\n        Debug.Log(e);\n      }\n    });\n  }\n\n  OnDestroy() {\n    let j = 0;\n    this._babControls.forEach(babControl => {\n      let button = babControl as BABYLON.GUI.Button;\n      button.onPointerClickObservable.remove(this._buttonClicks[j]);\n\n      //Before the button is destroyed, we pass the children on to the parent.\n      for (let i = button.children.length - 1; i >= 0; i--) {\n        let child = button.children[i];\n        button.removeControl(child);\n        button.parent.addControl(child);\n      };\n      j++;\n    });\n    super.OnDestroy();\n\n  }\n\n}\n"
                    },
                    {
                        "Label.ts": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Label extends UGUIElement {\n\n  @SerializeField\n  public text: string = \"\";\n\n  @SerializeField\n  public color = new Color(0, 0, 0);\n\n  //Start is called before the first frame update\n  Start() {\n    super.Start();\n  }\n\n  //Update is called once per frame\n  Update() {\n    super.Update();\n    this._babControls.forEach(babControl => {\n      let textBlock = babControl as BABYLON.GUI.TextBlock;\n      textBlock.text = this.text;\n      textBlock.color = Color.UtoB(this.color, new BABYLON.Color3()).toHexString();\n    });\n  }\n\n  CreateBabGUI(): BABYLON.GUI.Control {\n    var textBlock = new BABYLON.GUI.TextBlock(\"BabTextBlock\");\n    return textBlock;\n  }\n\n\n\n}\n"
                    },
                    {
                        "Canvas.ts": "//script:GUITest\n\nclass CanvasOld extends MonoBehaviour\n{\n  //Singleton pattern\n  public static get instance (): CanvasOld\n  {\n    if (CanvasOld._instance == null || CanvasOld._instance == undefined)\n    {\n      CanvasOld._instance = Instantiate(CanvasOld);      \n    }\n    return CanvasOld._instance;\n  }\n\n  private static _instance: CanvasOld;  \n\n  public static get main (): BABYLON.GUI.AdvancedDynamicTexture\n  {\n    return CanvasOld.instance.main;\n  }\n\n  private main : BABYLON.GUI.AdvancedDynamicTexture;\n\n  Awake ()\n  {\n    this.main = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"Main\", true, Engine.scene);\n    this.main.layer.layerMask = 3;\n    \n  }\n\n  Update ()\n  {\n\n  }\n\n  OnDestroy ()\n  {\n    this.main?.dispose();\n    CanvasOld._instance = null;\n  }\n}"
                    }
                ]
            },
            {
                "FileTypes": [
                    {
                        "Prefab.ts": "class Prefab {\n\n  public static Get(name: string): string {\n    return getPrefab(name);\n  }\n\n  public static SimpleName(name: string) {\n    return name.slice(0, -7);\n  }\n\n  public static Create(name: string, goParent: GameObject = null): GameObject {\n    var prefabJson = getPrefab(name);\n\n    var parent = goParent ? goParent : new GameObject();\n    parent.name = this.SimpleName(name) + \" (Clone)\";\n    parent.prefabParent = parent;\n    parent.prefabName = name;\n    var clone: Scene = Serializer.FromJSON(prefabJson);\n    clone.rootObjs.forEach((go: GameObject) => {\n      go.transform.SetParent(parent.transform, false);\n    });\n\n    this.SetPrefabParent(clone.rootObjs, parent);\n\n    return parent;\n  }\n\n  private static SetPrefabParent(gos: GameObject[], prefab: GameObject) {\n    gos.forEach(go => {\n      if (go) {\n        go.prefabParent = prefab;\n        this.SetPrefabParent(go.transform.ser_children, prefab);\n      }\n    });\n  }\n}\n"
                    },
                    {
                        "Material.ts": "class Material {\n\n  public static maxLightsPerMaterial = 10;\n\n  @SerializeField\n  isPBR: boolean = false;\n\n  onChange: BABYLON.Observable<string>;\n\n  private wasPBR: boolean;\n\n  private static activeMaterials : Material[] = new Array();\n\n  constructor(name: string) {\n    this.onChange = new BABYLON.Observable<string>();\n    this.UpdateShader();\n  }\n\n  private UpdateShader() {\n    if (this.isPBR) {\n      var pm = new BABYLON.PBRMaterial(name, Engine.scene);\n      pm.maxSimultaneousLights = Material.maxLightsPerMaterial;\n      this.shader = pm;\n    } else {\n      var sm = new BABYLON.StandardMaterial(name, Engine.scene);\n      sm.maxSimultaneousLights = Material.maxLightsPerMaterial;\n      this.shader = sm;\n    }\n    this.wasPBR = this.isPBR;\n    this._lastTexture = \"\";\n    this._lastNormalTexture = \"\";\n\n    this.onChange.notifyObservers(this.isPBR ? \"PBR\" : \"Standard\");\n  }\n\n  shader: BABYLON.PushMaterial;\n\n  @SerializeField\n  mainColor: Color = new Color();\n\n  @SerializeField\n  mainTexture: string = \"\";\n  _lastTexture: string = \"\";\n\n  @SerializeField\n  alpha: number = 1;\n\n  @SerializeField\n  normalTexture: string = \"\";\n  _lastNormalTexture: string = \"\";\n\n  @SerializeField uScale: number = 1;\n  @SerializeField vScale: number = 1;\n  @SerializeField uOffset: number = 1;\n  @SerializeField vOffset: number = 1;\n\n  @SerializeField\n  specularColor: Color = new Color(0, 0, 0);\n\n  @SerializeField\n  specularPower: number = 0;\n\n  @SerializeField\n  roughness: number = 0;\n\n  @SerializeField\n  alphaMode: number = 0;\n\n  @SerializeField\n  hasAlpha : boolean = false;\n\n  private Update() {\n    if (this.isPBR != this.wasPBR) {\n      this.UpdateShader();\n    }\n\n    this.shader.alphaMode = this.alphaMode;\n\n    if (this.isPBR) {\n      var pMat = this.shader as BABYLON.PBRMaterial;\n      Color.UtoB(this.mainColor, pMat.albedoColor);\n      Color.UtoB(this.specularColor, pMat.reflectionColor);\n\n      pMat.specularIntensity = this.specularPower;\n      pMat.alpha = this.alpha;\n      pMat.roughness = this.roughness;\n\n      if (this.mainTexture && this.mainTexture != this._lastTexture) {\n        pMat.albedoTexture = TextureSystem.GetSprite(this.mainTexture);\n        this._lastTexture = this.mainTexture;\n      }\n      if (this.normalTexture && this.normalTexture != this._lastNormalTexture) {\n        pMat.bumpTexture = TextureSystem.GetSprite(this.normalTexture);\n        this._lastNormalTexture = this.normalTexture;\n\n      }\n\n      var t = pMat.albedoTexture as BABYLON.Texture;\n\n      if (t) {\n        t.uScale = this.uScale;\n        t.vScale = this.vScale;\n        t.uOffset = this.uOffset;\n        t.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n\n      var b = pMat.bumpTexture as BABYLON.Texture;\n      if (b) {\n        b.uScale = this.uScale;\n        b.vScale = this.vScale;\n        b.uOffset = this.uOffset;\n        b.vOffset = this.vOffset;\n        b.hasAlpha = this.hasAlpha;\n      }\n\n    } else {\n      var mat = this.shader as BABYLON.StandardMaterial;\n      Color.UtoB(this.mainColor, mat.diffuseColor);\n      Color.UtoB(this.specularColor, mat.specularColor);\n\n\n      mat.specularPower = this.specularPower;\n      mat.alpha = this.alpha;\n      mat.roughness = this.roughness;\n\n      if (this.mainTexture && this.mainTexture != this._lastTexture) {\n        mat.diffuseTexture = TextureSystem.GetSprite(this.mainTexture);\n        this._lastTexture = this.mainTexture;\n      }\n      if (this.normalTexture && this.normalTexture != this._lastNormalTexture) {\n        mat.bumpTexture = TextureSystem.GetSprite(this.normalTexture);\n        this._lastNormalTexture = this.normalTexture;\n\n      }\n\n      var t = mat.diffuseTexture as BABYLON.Texture;\n\n      if (t) {\n        t.uScale = this.uScale;\n        t.vScale = this.vScale;\n        t.uOffset = this.uOffset;\n        t.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n\n      var b = mat.bumpTexture as BABYLON.Texture;\n      if (b) {\n        b.uScale = this.uScale;\n        b.vScale = this.vScale;\n        b.uOffset = this.uOffset;\n        b.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n    }\n\n  }\n\n  public Clone(): Material {\n    var matJson = Serializer.ToJSON(this);\n    var newMat = Serializer.FromJSON(matJson, false);;\n    Material.activeMaterials.push(newMat);\n    return newMat;\n  }\n\n  public Destroy ()\n  {\n    var i = Material.activeMaterials.indexOf(this);\n    if (i > -1)\n    {\n      Material.activeMaterials.splice(i, 1);\n    }\n  }\n\n\n  // #region static\n  public static Get(name: string): Material {\n    //Not in array or null?\n    if (!this.nameToMat.has(name) || !this.nameToMat.get(name)) {\n      //If no name is added, we just use default\n      if (name) {\n        var matJson = getMaterial(name);\n      }\n\n      var material: Material = null;\n      //If we we used a non-existent material matJson would not be there.\n      if (matJson) {\n        material = Serializer.FromJSON(matJson, false);\n      }\n\n      if (!material) {\n        material = new Material(name);\n      }\n\n      this.nameToMat.set(name, material);\n      this.activeMaterials.push(material);\n    }\n\n    return this.nameToMat.get(name);\n  }\n\n\n  public static SaveToJSON(name: string) {\n    //Not in array or null?\n    if (!this.nameToMat.has(name) || !this.nameToMat.get(name)) {\n      Debug.Log(\"Error saving material \" + name + \". This material does not exist!\");\n      return;\n    }\n    var matJson = Serializer.ToJSON(this.nameToMat.get(name));\n    saveMaterial(name, matJson);\n  }\n\n  public static nameToMat: Map<string, Material>;\n\n  public static Init() {\n    this.nameToMat = new Map<string, Material>();\n\n  }\n\n  public static Update() {\n    //We run an update method on all active materials \n    this.activeMaterials.forEach((value: Material) => {\n      value.Update();\n    });\n  }\n  // #endregion\n}\n"
                    },
                    {
                        "Scene.ts": "//script:Scene\nclass Scene {\n  public name: string;\n\n  public objs: GameObject[];\n\n  //Null for scenes, the single root object for prefabs\n  public rootObj: GameObject;\n\n  //The objects that have no parent\n  @SerializeField\n  public rootObjs: GameObject[] = new Array();\n\n  //Any newly created GameObjects or Components\n  public newObjs: SceneObject[]\n\n  private loaded: boolean = false;\n\n  public constructor() {\n    this.objs = new Array();\n    this.newObjs = new Array();\n    this.isPrefabScene = SceneManager.prefabLoaded;\n\n    this.loaded = true;\n  }\n\n  public isDirty: boolean;\n\n  isPrefabScene: boolean;\n\n  public Save() {\n    var jsonData = Serializer.ToJSON(this, false);\n    if (this.isPrefabScene) {\n      savePrefab(this.name, jsonData);\n    } else {\n      saveScene(this.name, jsonData);\n\n    }\n\n    this.isDirty = false;\n  }\n\n  public Unload(): void {\n    if (!this.loaded) {\n      return;\n    }\n    this.loaded = false;\n    //A prefab auto-saves when we leave to a scene\n    if (this.isPrefabScene && !Engine.isPlaying) {\n      this.Save();\n    }\n    for (var i = this.rootObjs.length - 1; i >= 0; i--) {\n      if (Engine.isPlaying) {\n        GameObject.Destroy(this.rootObjs[i]);\n      } else {\n        GameObject.DestroyImmediate(this.rootObjs[i]);\n      }\n    }\n  }\n}"
                    }
                ]
            },
            {
                "Objects": [
                    {
                        "Color.ts": "class Color  {\n\n    constructor (r :number = 1, g :number = 1, b : number = 1)\n    {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n\n    @SerializeField\n    public r : number;\n    @SerializeField\n    public g : number;\n    @SerializeField\n    public b : number;\n\n\n    public static UtoB (u: Color, b? : BABYLON.Color3) : BABYLON.Color3\n    {\n        if (b === undefined)\n        {\n            b = new BABYLON.Color3();\n        }\n        b.r = u.r;\n        b.g = u.g;\n        b.b = u.b\n        return b;\n    }\n\n    public static BtoU  (b : BABYLON.Color3, u? : Color) : Color\n    {\n        if (u === undefined)\n        {\n            u = new Color();\n        }\n        u.r = b.r;\n        u.g = b.g;\n        u.b = b.b;\n        return u;\n    }\n}\n"
                    },
                    {
                        "Vector3.ts": "class Vector2 extends BABYLON.Vector2{\n\n}\n\nclass Vector3 {\n  public onChange: BABYLON.Observable<number>;\n\n  constructor(x?: number, y?: number, z?: number) {\n    this.onChange = new BABYLON.Observable();\n    this.x = x ? x : 0;\n    this.y = y ? y : 0;\n    this.z = z ? z : 0;\n  }\n\n  _x: number;\n  _y: number;\n  _z: number;\n\n  @SerializeField\n  get x(): number {\n    return this._x;\n  }\n\n  set x(value: number) {\n    this._x = value\n    this.onChange.notifyObservers(0);\n  }\n\n  @SerializeField\n  get y(): number {\n    return this._y;\n  }\n\n  set y(value: number) {\n    this._y = value;\n    this.onChange.notifyObservers(1);\n  }\n\n  @SerializeField\n  get z(): number {\n    return this._z;\n  }\n\n  set z(value: number) {\n    this._z = value;\n    this.onChange.notifyObservers(2);\n  }\n\n  public addInPlace(v: Vector3): Vector3 {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n\n  public add(v: Vector3): Vector3 {\n    let v2 = this.clone();\n    v2.addInPlace(v);\n    return v2;\n  }\n\n   public negateInPlace(): Vector3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  public negate(): Vector3 {\n    let v2 = this.clone();\n    v2.negateInPlace();\n    return v2;\n  }\n\n  public subtractInPlace(v: Vector3): Vector3 {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n\n  public subtract(v: Vector3): Vector3 {\n    let v2 = this.clone();\n    v2.subtractInPlace(v);\n    return v2;\n  }\n\n  public scaleInPlace(v: Vector3 | number): Vector3 {\n    if (typeof v === \"number\") {\n      this.x *= v;\n      this.y *= v;\n      this.z *= v;\n    } else {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n    }\n\n    return this;\n  }\n\n  public scale(v: Vector3 | number): Vector3 {\n    let v2 = this.clone();\n    v2.scaleInPlace(v);\n    return v2;\n  }\n\n  public static get forward ()\n  {\n    return new Vector3(0,0,1);\n  }\n\n  public Equals (v : Vector3) : boolean\n  {\n    return Math.abs(this.x - v.x) < Number.EPSILON &&  \n    Math.abs(this.y - v.y) < Number.EPSILON && \n    Math.abs(this.z - v.z) < Number.EPSILON;\n  }\n\n\n\n  static One(): Vector3 {\n    return new Vector3(1.0, 1.0, 1.0);\n  }\n\n  static Zero(): Vector3 {\n    return new Vector3(0.0, 0.0, 0.0);\n  }\n\n  /**Returns a copy of vector with its magnitude clamped to maxLength.*/\n  public static ClampMagnitude(vector: Vector3, maxLength: number): Vector3 {\n    let scaleFactor = 1;\n    let sqrMagnitude = vector.sqrMagnitude;\n    if (sqrMagnitude > 0 && maxLength * maxLength < sqrMagnitude) {\n      scaleFactor = maxLength / vector.magnitude;\n    }\n    return vector.scale(scaleFactor);\n  }\n\n  public static Lerp(a: Vector3, b: Vector3, l: number): Vector3 {\n    var v: Vector3 = a.clone();\n    v.x = v.x + l * (b.x - v.x);\n    v.y = v.y + l * (b.y - v.y);\n    v.z = v.z + l * (b.z - v.z);\n    return v;\n  }\n\n  clone(): Vector3 {\n    return new Vector3(this.x, this.y, this.z);\n  }\n\n  public static VtoB(v: Vector3, b?: BABYLON.Vector3): BABYLON.Vector3 {\n    if (b === undefined) {\n      b = new BABYLON.Vector3();\n    }\n    b.x = v.x;\n    b.y = v.y;\n    b.z = v.z;\n    return b;\n  }\n\n  public static BtoV(b: BABYLON.Vector3, v?: Vector3): Vector3 {\n    if (v === undefined) {\n      v = new Vector3();\n    }\n    v._x = b.x;\n    v._y = b.y;\n    v._z = b.z;\n    return v;\n  }\n\n  toString() {\n    return \"Vector3(\" + this.x + \",\" + this.y + \",\" + this.z + \")\";\n  }\n\n  public get magnitude(): number {\n    return Math.sqrt(this.sqrMagnitude);\n  }\n\n  public get sqrMagnitude(): number {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n\n  public get normalized(): Vector3 {\n    var m = 1.0 / this.magnitude;\n    return new Vector3(this.x * m, this.y * m, this.z * m);\n  }\n\n  /**Dot Product of two vectors. */\n  public static Dot(lhs: Vector3, rhs: Vector3): number {\n    return (lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z);\n  }\n\n  /**Cross Product of two vectors. */\n  public static Cross(lhs: Vector3, rhs: Vector3): Vector3 {\n    let v = new Vector3();\n    v.x = lhs.y * rhs.z - lhs.z * rhs.y;\n    v.y = lhs.z * rhs.x - lhs.x * rhs.z;\n    v.z = lhs.x * rhs.y - lhs.y * rhs.x;    \n    return v;\n  }\n\n}"
                    },
                    {
                        "Quaternion.ts": "class Quaternion {\n\n\n    public static LookRotation(forward: Vector3, up: Vector3): Quaternion {\n        if (forward.Equals(Vector3.Zero())) {\n            Debug.Log(\"Zero direction in MyLookRotation\");\n            return new Quaternion();\n        }\n\n        if (!up.Equals(forward)) {\n            up = up.normalized;\n            let v = forward.add(up.scale(-Vector3.Dot(up, forward)));\n            let q = Quaternion.FromToRotation(Vector3.forward, v);\n            return Quaternion.FromToRotation(v, forward).multiply(q);\n        }\n        else {\n            return Quaternion.FromToRotation(Vector3.forward, forward);\n        }\n    }\n\n    /**Creates a rotation which rotates from fromDirection to toDirection.*/\n    public static FromToRotation(fromDirection: Vector3, toDirection: Vector3): Quaternion {\n        let a = fromDirection.x;\n        let b = fromDirection.y;\n        let c = fromDirection.z;\n\n        let x = toDirection.x;\n        let y = toDirection.y;\n        let z = toDirection.z;\n\n        let dot = a * x + b * y + c * z;\n        let w1 = b * z - c * y;\n        let w2 = c * x - a * z;\n        let w3 = a * y - b * x;\n\n        return new Quaternion(            \n            w1,\n            w2,\n            w3, \n            dot + Math.sqrt(dot * dot + w1 * w1 + w2 * w2 + w3 * w3)\n        ).normalized;\n    }\n\n    public get normalized(): Quaternion {\n        let w = this.w;\n        let x = this.x;\n        let y = this.y;\n        let z = this.z;\n\n        let norm = Math.sqrt(w * w + x * x + y * y + z * z);\n\n        if (norm < Number.EPSILON) {\n            return new Quaternion();\n        }\n\n        norm = 1 / norm;\n        return new Quaternion(x * norm, y * norm, z * norm, w * norm);\n    }\n\n    public multiply (q : Quaternion)\n    {\n      \n      var x1 = this.x;\n      var y1 = this.y;\n      var z1 = this.z;\n      var w1 = this.w;\n\n      var x2 = q.x;\n      var y2 = q.y;\n      var z2 = q.z;\n      var w2 = q.w;\n\n      return new Quaternion(              \n              w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,\n              w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,\n              w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,\n              w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2);\n    }\n\n\n    public onChange: BABYLON.Observable<number>;\n\n    constructor(x?: number, y?: number, z?: number, w?: number) {\n        this.onChange = new BABYLON.Observable();\n        this.x = x ? x : 0;\n        this.y = y ? y : 0;\n        this.z = z ? z : 0;\n        this.w = w ? w : 0;\n    }\n\n    _x: number;\n    _y: number;\n    _z: number;\n    _w: number;\n\n    @SerializeField\n    get x(): number {\n        return this._x;\n    }\n\n    set x(value: number) {\n        this._x = value\n        this.onChange.notifyObservers(0);\n    }\n\n    @SerializeField\n    get y(): number {\n        return this._y;\n    }\n\n    set y(value: number) {\n        this._y = value;\n        this.onChange.notifyObservers(1);\n    }\n\n    @SerializeField\n    get z(): number {\n        return this._z;\n    }\n\n    set z(value: number) {\n        this._z = value;\n        this.onChange.notifyObservers(2);\n    }\n\n    @SerializeField\n    get w(): number {\n        return this._w;\n    }\n\n    set w(value: number) {\n        this._w = value;\n        this.onChange.notifyObservers(3);\n    }\n\n    clone(): Quaternion {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n\n    toString() {\n        return \"Quaternion(\" + this._x + \",\" + this._y + \",\" + this._z + \",\" + this._w + \")\";\n    }\n\n    public static QtoB(v: Quaternion, b: BABYLON.Quaternion): BABYLON.Quaternion {\n        b.x = v._x;\n        b.y = v._y;\n        b.z = v._z;\n        b.w = v._w;\n        return b;\n    }\n\n    public static BtoQ(b: BABYLON.Quaternion, v: Quaternion): Quaternion {\n        v._x = b.x;\n        v._y = b.y;\n        v._z = b.z;\n        v._w = b.w;\n        return v;\n    }\n\n    public static Inverse(q: Quaternion) {\n        return new Quaternion(-q.x, -q.y, -q.z, -q.w);\n    }\n\n    //TODO Can we do this math without Babylon?\n    public static Euler(x: number, y: number, z: number, q?: Quaternion): Quaternion {\n        if (!q) {\n            q = new Quaternion(0, 0, 0, 0);\n        }\n\n        var newQuat = BABYLON.Quaternion.FromEulerAngles(x * Mathf.Deg2Rad, y * Mathf.Deg2Rad, z * Mathf.Deg2Rad);\n        return Quaternion.BtoQ(newQuat, q);\n    }\n\n    static ToEulerAngles(q: Quaternion, v: Vector3): Vector3 {\n        var b = new BABYLON.Quaternion();\n        Quaternion.QtoB(q, b);\n\n        var bv: BABYLON.Vector3 = b.toEulerAngles();\n        bv.x *= Mathf.Rad2Deg;\n        bv.y *= Mathf.Rad2Deg;\n        bv.z *= Mathf.Rad2Deg;\n\n        return Vector3.BtoV(bv, v);\n    }\n}\n\n"
                    }
                ]
            },
            {
                "MainGame.ts": "//*\n\n@RegisterAsComponent\nclass ComponentLogger extends MonoBehaviour {\n\n  Awake() {\n    Debug.Log(\"Awake was called on \" + this.name);    \n  }\n\n  OnEnable() {\n    Debug.Log(\"OnEnable was called on \" + this.name);\n  }\n\n  OnDisable() {\n    Debug.Log(\"OnDisable was called on \" + this.name);\n  }\n\n  Start() {\n    Debug.Log(\"Start was called on \" + this.name);\n  }\n\n  Update ()\n  {\n    if (Input.GetKeyDown(KeyCode.Space))\n    {\n      Debug.Log(Random.Range(0,100));\n    }\n  }\n\n  OnDestroy()\n  {\n    Debug.Log(\"Destroy was called on \" + this.name);\n\n  }\n\n  OnTriggerEnter(other : Collider) {\n    Debug.Log(\"OnTriggerEnter was called on \" + this.name + \" with \" + other.name);\n    //Debug.Log(this.GetComponent(Collider).bounds.boundingBox.center);\n    //Debug.Log(this.transform.position);\n  }\n\n  OnTriggerExit() {\n    Debug.Log(\"OnTriggerExit was called on \" + this.name);\n    //Debug.Log(this.transform.position);\n\n  }\n\n  FixedUpdate() {\n    //this.GetComponent(Rigidbody).velocity = new Vector3(10,0,0);\n  }\n\n}\n\n@RegisterAsComponent\nclass Mouse extends MonoBehaviour {\n  \n\n  Start() {\n   \n  }\n\n\n  Update() {\n    let hitInfo = new RaycastHit();\n    let hit = Physics.Raycast(new Ray(this.transform.position, this.transform.up.negate()), hitInfo, 10);\n    if (hit)\n    {\n     // Debug.Log(hitInfo.collider.name);\n    }\n\n  }\n}\n\n//Doozy.ts\n@RegisterAsComponent\nclass Doozy extends MonoBehaviour {\n  @SerializeField\n  speed = 5;\n\n  @SerializeField\n  stoppingDistance = 1;\n\n  anim: Animator;\n  rb: Rigidbody;\n  mouse: Mouse;\n\n  Start() {\n    this.anim = this.GetComponentInChildren(Animator);\n    this.rb = this.GetComponent(Rigidbody);\n    this.mouse = GameObject.FindObjectOfType(Mouse);\n  }\n\n  Update() {\n    let direction = this.mouse.transform.position.subtract(this.transform.position);\n    this.transform.localRotation = Quaternion.LookRotation(direction.scale(-1), new Vector3(0, 1, 0));\n    if (direction.magnitude > this.stoppingDistance) {\n      this.rb.velocity = direction.normalized.scale(this.speed);\n      this.anim.Play(\"Running\", 0.1);\n    } else {\n      this.rb.velocity = new Vector3();\n      this.anim.Play(\"Idle.001\", 0.1);\n    }\n  }\n}\n\n/*\nenum Special {\n  Wizard,\n  Archer\n}\n\n@RegisterAsComponent\nclass LightSettings extends MonoBehaviour {\n  //Start is called before the first frame update\n  Start() {\n    print(\"HJADSA\")\n  }\n}\n\n@RegisterAsComponent\n@ExecuteInEditMode\nclass ActivateObjectButton extends Button {\n\n  @SerializeField\n  objName : string = \"\";\n\n  OnButtonClick() {\n    let obj = GameObject.Find(this.objName);\n    obj.SetActive(!obj.activeInHierarchy);\n  }\n}\n\n@RegisterAsComponent\nclass ClockArm extends MonoBehaviour {\n\n  @SerializeField\n  speed: number = 1;\n\n  //Start is called before the first frame update\n  Start() {\n\n  }\n\n  //Update is called once per frame\n  Update() {\n    this.transform.Rotate(0, Time.deltaTime * this.speed, 0, BABYLON.Space.WORLD);\n  }\n\n}\n/*\n@RegisterAsComponent\nclass RotationTest extends MonoBehaviour {\n\n  @SerializeField\n  pla: number = 4;\n\n  newParent = null;\n\n  Start() {\n\n\n  }\n\n  Update() {\n        Cursor.lockState = CursorLockMode.Locked;\n\n\n    Cursor.lockState = CursorLockMode.Locked;\n\n    var mouseXInput = Input.GetAxis(\"Mouse X\");\n    var mouseYInput = Input.GetAxis(\"Mouse Y\");\n    this.transform.Rotate(mouseYInput, mouseXInput, 0);\n\n  }\n}\n\n@RegisterAsComponent\nclass Ground extends MonoBehaviour {\n  Start() {\n    this.GetComponent(BoxCollider).layerMask = 2 | 4 | 8 | 16;\n  }\n}\n\n@RegisterAsComponent\nclass MyBox extends MonoBehaviour {\n\n  @SerializeField\n  triggerTime: number = 0;\n\n  @SerializeField\n  movement: number = 0;\n\n  mat: BABYLON.StandardMaterial;\n\n  @SerializeField\n  meshOffset: Vector3 = new Vector3(0, 0, 0);\n\n  m: BABYLON.Mesh;\n\n\n  //Start is called before the first frame update\n  Start() {\n\n  }\n\n  //Update is called once per frame\n  Update() {\n    // this.transform.eulerAngles.z += 1;\n    //this.transform.position.y += this.speed;\n    //this.transform.position.x += this.movement;\n    if (!this.m) {\n      this.m = this.renderer.GetMesh();\n      // var v : BABYLON.Vector3 = new BABYLON.Vector3();\n      // Vector3.VtoB(this.meshOffset, v);\n      this.m.locallyTranslate(new BABYLON.Vector3(13, 0, 50));\n      this.m.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n    }\n\n    if (this.m) {\n\n      // this.m.translate(new BABYLON.Vector3(0,0,1), 10);\n      //);\n    }\n  }\n\n  OnTriggerEnter(coll: Collider) {\n    this.renderer.material.shader.diffuseColor = BABYLON.Color3.Green();\n  }\n\n  OnTriggerExit(coll: Collider) {\n    this.renderer.material.shader.diffuseColor = BABYLON.Color3.Red();\n  }\n\n  OnTriggerStay(coll: Collider) {\n    this.triggerTime += Time.deltaTime;\n  }\n}\n\n/* */\n\n"
            }
        ],
        "model": [
            {
                "asteroid.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.asteroid.obj"
                }
            },
            {
                "ship.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ship.obj"
                }
            },
            {
                "virus.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.virus.obj"
                }
            },
            {
                "crate.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.crate.obj"
                }
            },
            {
                "PixelHead.glb": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__ASSET__.4892.210651.1620103800.PixelHead.glb"
                }
            }
        ],
        "texture": [
            {
                "laser.png": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.laser.png"
                }
            },
            {
                "EngineTextures": [
                    {
                        "play_button.png": {
                            "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.play_button.png"
                        }
                    },
                    {
                        "pause_button.png": {
                            "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.pause_button.png"
                        }
                    }
                ]
            },
            {
                "nebula.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.nebula.jpg"
                }
            },
            {
                "asteroid.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.asteroid.jpg"
                }
            },
            {
                "ship.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ship.jpg"
                }
            },
            {
                "Grass.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Grass.jpg"
                }
            },
            {
                "Wood.png": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Wood.png"
                }
            },
            {
                "synty.png": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.synty.png"
                }
            },
            {
                "board.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.board.jpg"
                }
            },
            {
                "board_normal.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.board_normal.jpg"
                }
            }
        ],
        "sound": [],
        "library": {},
        "scene": [
            {
                "TriggerTest.scn": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"isStatic\":false,\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":15.089681625366211,\"y\":34.05119705200195,\"z\":-14.132094383239746},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":66.26989120519565,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":0,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":2,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28},{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":15.089681625366211,\"y\":34.05119705200195,\"z\":-14.132094383239746},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":66.26989120519566,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":0,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":2,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null,\"_activeSelf\":false},{\"t\":\"GameObject\",\"isStatic\":false,\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"a39a3885-efcc-4460-bbfc-ac4f25a661c2\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"a39a3885-efcc-4460-bbfc-ac4f25a661c2\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"ComponentLogger\"}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"isStatic\":false,\"name\":\"Camera\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":4.3221588134765625,\"y\":23.348262786865234,\"z\":-26.845685958862305},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":31.203309771422635,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.5199999809265137,\"y\":1.000000006288987,\"z\":1.000000006288987},\"uniqueId\":\"f088e1dc-458d-4b59-ba87-03fbf7838fbe\",\"ser_children\":[]},{\"t\":\"Camera\"},{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":4.3221588134765625,\"y\":23.348262786865234,\"z\":-26.845685958862305},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":31.203309771422635,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.5199999809265137,\"y\":1.000000006288987,\"z\":1.000000006288987},\"uniqueId\":\"f088e1dc-458d-4b59-ba87-03fbf7838fbe\",\"ser_children\":[]},{\"t\":\"Camera\"}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"isStatic\":false,\"name\":\"Canvas\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":1.9619472026824951,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.0021413276231263384,\"y\":0.0030581039755351682,\"z\":1},\"uniqueId\":\"08f700af-db89-49ee-97b9-cba763750c5f\",\"ser_children\":[{\"t\":\"GameObject\",\"isStatic\":false,\"name\":\"Button\",\"components\":[{\"t\":\"RectTransform\",\"_position\":{\"t\":\"Vector3\",\"x\":259.20045375823975,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"3942d6d5-152a-4f82-be3c-64f3ab85b23a\",\"ser_children\":[{\"t\":\"GameObject\",\"isStatic\":false,\"name\":\"Text\",\"components\":[{\"t\":\"RectTransform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"77101867-468d-49e5-ac12-5aa5652646e8\",\"ser_children\":[],\"horAlignment\":1,\"verAlignment\":1,\"width\":100,\"isPercentageWidth\":false,\"height\":100,\"isPercentageHeight\":false},{\"t\":\"Label\",\"text\":\"Click me!\",\"color\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0}}],\"prefabName\":null,\"_activeSelf\":true}],\"horAlignment\":1,\"verAlignment\":1,\"width\":100,\"isPercentageWidth\":false,\"height\":100,\"isPercentageHeight\":false},{\"t\":\"Button\"},{\"t\":\"UIImage\",\"link\":\"\",\"keepAspectRatio\":true}],\"prefabName\":null,\"_activeSelf\":true}]},{\"t\":\"NewCanvas\"}],\"prefabName\":null,\"_activeSelf\":true}]}"
            },
            {
                "Simple.scn": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":10,\"y\":14,\"z\":-10},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":44.999999999999986,\"y\":-45.00000000000002,\"z\":-4.72288274471469e-14},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b06464a1-3a70-49cb-b23c-d54bc0d201b6\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":0,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":0.7,\"range\":25,\"coneAngle\":25,\"exponent\":25,\"shadowFrustrumSize\":25,\"shadowFrustrumLength\":25}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Test\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-8.724060309475397e-16,\"y\":1.4726336783136318,\"z\":1.7127522391171233},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-42.92693784570925,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"cf246cc4-82aa-48c3-9aef-ea784d0d4b99\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":1.2376452684402466,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":2.6187119483947754,\"z\":1},\"uniqueId\":\"bc57e5bb-d361-4414-bd10-bf7a71fb7753\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":1.2700000000000056,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":2.6,\"z\":1}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false,\"_freezeRotation\":false}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Sphere\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":1.2897590398788452,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"e19b1971-8069-49d7-8ae6-d857ce8d5b85\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"sphere\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"SphereCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"radius\":1},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false,\"_freezeRotation\":false}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":-1.3315051963347282,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":20,\"y\":0.1,\"z\":20},\"uniqueId\":\"52608ce8-ca0a-4c9c-877e-8d4454fd0071\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":false,\"receiveShadows\":true,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1}}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Mouse\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":4.740970209141545,\"y\":0,\"z\":6.661338147750939e-16},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":-80.57437358943339,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"d150bea7-27db-467b-9070-56707584025a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Mesh\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-2.97975066843037e-8,\"y\":0,\"z\":-3.431936512754419e-9},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":180,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b9ae6dd5-ef6d-4216-bda8-b5d391391ff9\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"MouseMove.glb\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"Animator\",\"defaultAnim\":\"\"}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"CamPivot\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-1.502110791307132e-8,\"y\":1.411310076713562,\"z\":-9.789289379114052e-10},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"e39c8aca-42c8-4166-9e5c-fd09db2d7bd9\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Camera\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-4.060511589050293},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0c286f8d-7bb4-41e9-8e8e-414bd98cfdcf\",\"ser_children\":[]},{\"t\":\"Camera\"}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true}]},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0,\"_friction\":0,\"_isKinematic\":false,\"_freezeRotation\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.5800000000000003,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":0.35999999999999943,\"y\":1,\"z\":0.39999999999999947}}],\"prefabName\":null,\"_activeSelf\":true}]}"
            },
            {
                "Test3.scn": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"2875f25b-0d79-473c-aaf1-ca68e83222c3\",\"ser_children\":[]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Floor\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":28.245817184448242,\"y\":0.46689143776893616,\"z\":32.057926177978516},\"uniqueId\":\"aee60fd5-f89b-4905-929b-4e5a59805149\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":false,\"receiveShadows\":true,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1}}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":10,\"y\":14,\"z\":-10},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":44.999999999999986,\"y\":-45.00000000000002,\"z\":-4.72288274471469e-14},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"18bf44e6-3737-4e4b-91aa-07e8bca77e1e\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":0,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":0.7,\"range\":25,\"coneAngle\":25,\"exponent\":25,\"shadowFrustrumSize\":29.02,\"shadowFrustrumLength\":35.20000000000001}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Mouse\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.610008955001831,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"d0d25e50-4881-4f16-bd43-1feff42a96c5\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Collider\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.6,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"71ea2e3a-0a6e-49ef-849f-d76acafce96a\",\"ser_children\":[]},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":0.49999999999999956,\"y\":1.2099999999999993,\"z\":0.44999999999999957}}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Mesh\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.0840308666229248,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":-124.45100005834412,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5a9247c0-8f35-4fa3-b7bd-5b8195d52c0b\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"MouseMove.glb\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"Animator\",\"defaultAnim\":\"\"}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"CamPivot\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":1.411310076713562,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"d2330c91-ee52-499c-b106-60ea1140e11f\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Camera\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-4.060511589050293},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"8873ea62-37cd-4050-95d6-1f4e5f03319a\",\"ser_children\":[]},{\"t\":\"Camera\"}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true}]},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0,\"_friction\":0,\"_isKinematic\":true,\"_freezeRotation\":true},{\"t\":\"Mouse\"}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":2.3509938716888428,\"z\":4.419013977050781},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"9f8f471e-608c-4296-8101-d1db178bf364\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false,\"_freezeRotation\":false}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Doozy\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.8186140060424805,\"z\":2.7379701137542725},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"9f348f3e-48ae-4800-9ebb-b728b4d55820\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Model\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.2453492283821106,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"72fa4889-6701-42f5-9f23-5d9ba95a9d0d\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Doozy.glb\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"Animator\",\"defaultAnim\":\"Idle.001\"}],\"prefabName\":null,\"_activeSelf\":true}]},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0,\"_isKinematic\":true,\"_freezeRotation\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0.79,\"z\":0},\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1}},{\"t\":\"Doozy\",\"speed\":5,\"stoppingDistance\":1}],\"prefabName\":null,\"_activeSelf\":true}]}"
            }
        ],
        "material": [
            {
                "Red.mat": "{\"t\":\"Material\",\"isPBR\":true,\"mainColor\":{\"t\":\"Color\",\"r\":0.6933723709313289,\"g\":0.23562693677651975,\"b\":0.23562693677651975},\"mainTexture\":\"board.jpg\",\"alpha\":1,\"normalTexture\":\"board_normal.jpg\",\"uScale\":1,\"vScale\":1,\"uOffset\":1,\"vOffset\":1,\"specularColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"specularPower\":0.9299999999999997,\"roughness\":0.44999999999999885,\"alphaMode\":0,\"hasAlpha\":false}"
            },
            {
                "Asteroid.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"asteroid.jpg\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}"
            },
            {
                "Grass.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"Grass.jpg\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":5,\"vScale\":5,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}"
            },
            {
                "Yellow.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":0.792158236747296,\"b\":0},\"mainTexture\":\"\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}"
            },
            {
                "Synty.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"synty.png\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":9.260000000000003,\"roughness\":20.02000000000001}"
            },
            {
                "Flip.mat": "//material: Flip.mat\n\n"
            }
        ],
        "prefab": [
            {
                "Test.prefab": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.11797763309128564,\"y\":-2.3257447407301215,\"z\":1},\"uniqueId\":3168,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null,\"_activeSelf\":true}]}"
            },
            {
                "Robot.prefab": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":13009,\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"DASDas\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0.7628781795501709,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":180},\"_scale\":{\"t\":\"Vector3\",\"x\":0.35345974564552307,\"y\":-1,\"z\":1},\"uniqueId\":12985,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null,\"_activeSelf\":false},{\"t\":\"GameObject\",\"name\":\"ffg\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":180},\"_scale\":{\"t\":\"Vector3\",\"x\":0.35345974564552307,\"y\":-1,\"z\":1},\"uniqueId\":12993,\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Sphere\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-3.5557232877801497e-22,\"y\":1.9245442152023315,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":13297,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"sphere\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"SphereCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"radius\":1},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null,\"_activeSelf\":false}]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null,\"_activeSelf\":false},{\"t\":\"GameObject\",\"name\":\"dasd\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0.3695315718650818,\"y\":0.9485462307929993,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":180},\"_scale\":{\"t\":\"Vector3\",\"x\":0.35345974564552307,\"y\":-1,\"z\":1},\"uniqueId\":13001,\"ser_children\":[]},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null,\"_activeSelf\":false}]}],\"prefabName\":null,\"_activeSelf\":false}]}"
            },
            {
                "TestEnvironment.prefab": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"Environment\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.55,\"y\":0.55,\"z\":0.55},\"uniqueId\":\"b13566ed-4e63-411d-ad76-ac94f42df07a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"World\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.10000000149011612,\"y\":0.10000000149011612,\"z\":0.10000000149011612},\"uniqueId\":237,\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"BiggerRoom\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":214,\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"BWalls\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"62391a96-d561-4894-a6a9-0a800f88671f\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Room.obj\",\"materialName\":\"Room_MAT.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"DrillPress\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"6e59f25e-c789-499f-bf0c-bc42a43b0296\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"DrillMetal\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"cb663e1d-6732-404d-8f81-a0dd4921a8b2\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"DrillPUV\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"PlaySurface\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9912366271018982,\"y\":0.9912366271018982,\"z\":0.9912366271018982},\"uniqueId\":\"39825de9-266c-4532-963d-eb8e4add0097\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PlaySurface\",\"materialName\":\"Wood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"CornersPlayArea\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"a886af79-1d37-42c9-940f-0d96703f50e4\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"CornerPlayArea\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"BasePlayArea\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"e17fd7ea-3f23-4a65-9ef3-42d5ac00bc69\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BasePlayArea\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Bench\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":40,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5aca02f2-8d13-4a84-bd06-2ca73ef380ed\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontMetal\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":39.355303686403204,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999998807907104,\"y\":0.9999998807907104,\"z\":0.9999998807907104},\"uniqueId\":231,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BenchMetal1\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"SideMetal\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":39.355303686403204,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":231,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BenchMetal2\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"BenchHandleButton\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":39.355303686403204,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"3a270b24-c17a-48c4-8040-b581eb8b2657\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Handles\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Bench\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":39.355303686403204,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999998807907104,\"y\":0.9999998807907104,\"z\":0.9999998807907104},\"uniqueId\":\"25191de7-1da1-4f9a-b7c0-ce531d326c1a\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Bench\",\"materialName\":\"BenchSurface.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Computer\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":78.9227655429786,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"82f4f19f-0d3a-4a4f-8fc3-573cae2c694d\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"ComputerScreen\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":216,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"CScreen\",\"materialName\":\"ComputerScreen.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Keyboard\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":217,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"DKeyboard\",\"materialName\":\"Desktop2.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Desktop\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b57fa708-c354-4e80-bdbb-0933aaff9c78\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Dcomputer\",\"materialName\":\"Desktop2.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"e5642aee-59e7-496c-9e1c-b594a2e18947\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontFrame\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"fe5cef3d-ff58-4f98-8588-39b1c3b995a5\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PosterFrame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":65,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":225,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"NewPoster\",\"materialName\":\"Poster1.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-233.8},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"ec42bfdf-92f4-491e-8e97-7b93e9010b32\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontFrame\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"4e41cfd0-8c39-44ba-a1ee-9f5f8af7a7b5\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PosterFrame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":65,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"5582095b-3936-4ee1-8a0e-8cb88f5e838a\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"NewPoster\",\"materialName\":\"Poster1.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-468.475},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"20bf4ffe-fb04-40d5-a6fb-1c4e0c3f5d89\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontFrame\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"abadc6a2-c931-47fd-80e3-95923d89a77f\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PosterFrame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":65,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"ae963e71-f895-4735-8cac-be721c35afb1\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"NewPoster\",\"materialName\":\"Poster1.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":-1,\"y\":1,\"z\":1},\"uniqueId\":\"be6347b5-2763-4e6f-8f17-37621c77f21e\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontFrame\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"90e467e5-2e3c-4abf-aa4f-50e9712653e2\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PosterFrame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":65,\"z\":1.8000000000000016},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"59cac2ac-ff1e-4d4b-8ae7-9e615dd6241f\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"NewPoster\",\"materialName\":\"Poster1.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-233.8},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":-1,\"y\":1,\"z\":1},\"uniqueId\":\"06f4af29-39eb-4cd4-9279-89490bae0d5c\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontFrame\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"be9161a3-0c6d-452e-834e-53392f81a89a\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PosterFrame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":65,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"44048c4d-4815-44db-b674-306fa9996a45\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"NewPoster\",\"materialName\":\"Poster1.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-468.475},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":-1,\"y\":1,\"z\":1},\"uniqueId\":\"cf48bb24-ecba-4be1-a002-f376ffc6aefc\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontFrame\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"518ba3fc-3f14-412d-99b0-fb2e2d7a432b\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PosterFrame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Poster\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":65,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"b000f80f-a941-4ad8-9cf5-77fda674dfa2\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"NewPoster\",\"materialName\":\"Poster1.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Toolbox\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":80.17368266111953,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5a03b6b0-ad4e-4857-9c40-53baafbb648d\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Body\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":221,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"crate\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Whiteboard\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b0d8970d-3105-457a-8233-bf932f64cd3b\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"WhiteBoard\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":28.126418622894562,\"y\":0,\"z\":-9.748332035082058},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":229,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"WhiteboardSurface.obj\",\"materialName\":\"Whiteboard.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"FrameFront\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"628d860b-d257-47e3-a788-f7a69b816e45\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"WB_Frame\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Vice\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"7bee6d9d-92b6-4fa5-8cae-d58ee09db244\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"ViceBody\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":226,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Vise\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Printers\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":79.44736438486507,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b169a0d1-31f3-4144-b4f2-f01d01b4bdc1\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"PrinterScreen\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":233,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PrinterScreens\",\"materialName\":\"PrinterGlass.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"FramePrinter\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"691c8124-c5fd-44a5-bb5f-8e1737ff2f8a\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Printer2\",\"materialName\":\"DarkMetal2.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"FrontMPrinter\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"047b7771-eec7-4184-9af3-1c05fb624cf9\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Printer1\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Bench\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":180,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"55374520-7fe8-4821-993e-2d4e63d9e3a3\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"FrontMetal\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999998807907104,\"y\":0.9999998807907104,\"z\":0.9999998807907104},\"uniqueId\":\"e5281baa-a2f1-4b81-8880-953dbd850a91\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BenchMetal1\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"SideMetal\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"690cc0ed-7f3b-4255-98ab-bad6fa89ab30\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BenchMetal2\",\"materialName\":\"LightMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"BenchHandleButton\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"dcc45bc6-e086-489c-af70-06963ec8ae0c\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Handles\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Bench\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":180,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999998807907104,\"y\":0.9999998807907104,\"z\":0.9999998807907104},\"uniqueId\":\"5e60a584-f56a-483f-a28b-d13daecaadd3\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Bench2\",\"materialName\":\"BenchSurface.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Toolbox\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":180,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"e9bae1cc-4956-416d-81ec-1073c50064aa\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Body\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"b4063881-6d35-4cdd-9b42-b018ea7f4c7f\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"crate\",\"materialName\":\"DarkMetal.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":true,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Shelf\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"81d2e370-f397-4234-9865-e96ac3ff8aac\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Shelf\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Shelf\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-233},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"12d02f77-fedf-41f6-acd1-f0f88b1fb09e\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Shelf\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Shelf\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-468},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"1b16441d-7ab4-42a7-9e53-1373a42bcfed\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Shelf\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Shelf\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":-1,\"y\":1,\"z\":1},\"uniqueId\":\"f935c5dd-525b-43d3-871b-fbc65cb8dc94\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Shelf\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Shelf\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-233},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":-1,\"y\":1,\"z\":1},\"uniqueId\":\"8e849439-78df-472a-9d69-32c53bc2706e\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Shelf\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Shelf\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-468},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":-1,\"y\":1,\"z\":1},\"uniqueId\":\"5a44f92c-847e-49bb-be47-a745c42fb6d5\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Shelf\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Trophy\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5358d8c9-a29c-4b6c-81bc-2adc1eac0bc1\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"Trophy\",\"materialName\":\"Gears.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Panel\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"4a9562bb-a0af-49a7-a3c7-02b8bc77c23c\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"LogoPopUp\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"e9650998-274f-4634-a44e-38b28a5d13a4\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PopUpLogo\",\"materialName\":\"Whiteboard.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Panels\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"c4126d7e-65f6-4ab7-979d-96b6dd14ccff\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BackPanel\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Lights\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"67d4ce6a-bebb-4221-8988-d191c99d790e\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"SpotLight\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":34.60350036621094,\"z\":-3.934972024599841e-15},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":90,\"y\":1.9975059337330387e-30,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"bb426029-c17f-4a69-a92c-ebdf50ba4b4b\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":false,\"intensity\":1000,\"range\":17,\"coneAngle\":903.6899999999988,\"exponent\":25,\"shadowFrustrumSize\":25,\"shadowFrustrumLength\":25}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"LightSettings\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"6474f88c-8419-4ed9-8966-647af0c6594a\",\"ser_children\":[]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":26.980226516723633,\"y\":32.1333122253418,\"z\":14.154754638671875},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":35.3817499091337,\"y\":-84.82280033997608,\"z\":-17.17522600106896},\"_scale\":{\"t\":\"Vector3\",\"x\":1.0000000304206207,\"y\":0.9999999850977409,\"z\":0.9999999872695308},\"uniqueId\":\"e3f70670-c454-413b-b9ec-e24f000a0847\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":0.899515000939107,\"g\":0.8765132342848707,\"b\":0.7797110461738644},\"castShadows\":false,\"intensity\":300,\"range\":15,\"coneAngle\":304.4600000000004,\"exponent\":25,\"shadowFrustrumSize\":25,\"shadowFrustrumLength\":25}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-28.60801887512207,\"y\":33.96217727661133,\"z\":-10.333094596862793},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":36.320126602353206,\"y\":129.40663376084404,\"z\":12.199215757923646},\"_scale\":{\"t\":\"Vector3\",\"x\":1.000000004082072,\"y\":0.9999999965467162,\"z\":0.9999999732931087},\"uniqueId\":\"e3f70670-c454-413b-b9ec-e24f000a0847\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":0.8570887019638463,\"g\":0.7723375665382464,\"b\":0.41566516491732985},\"castShadows\":false,\"intensity\":300,\"range\":15,\"coneAngle\":124.3700000000001,\"exponent\":25,\"shadowFrustrumSize\":25,\"shadowFrustrumLength\":25}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true}]}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Panel\",\"components\":[],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"LogoPopUp\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.9999999403953552,\"y\":0.9999999403953552,\"z\":0.9999999403953552},\"uniqueId\":\"f67d0177-25b2-4198-a0b1-76d25ca721a1\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"PopUpLogo\",\"materialName\":\"Whiteboard.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true},{\"t\":\"GameObject\",\"name\":\"Panels\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"2adec9bb-1dce-4f5c-847b-a397a7808b46\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"BackPanel\",\"materialName\":\"DarkWood.mat\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true}],\"prefabName\":null,\"_activeSelf\":true}]}"
            },
            {
                "Flip.prefab": "{\"t\":\"Scene\",\"rootObjs\":[]}"
            }
        ]
    }
}