{
    "assets": {
        "code": {
            "main": "/*\r\nReminders for PixelPAD Union\r\n\r\n- Instance variables need to be initialized! Even basic vars such as integers/strings\r\n- There are no structs. Basic objects such as Vectors pass by reference by default\r\n- Specific Vectors like position, rotation can be set by simply setting their individual variables.\r\n    e.g. transform.position.x = 4 works\r\n- Instantiate is used to create GameObjects with a specific Component or as a prefab\r\n\r\n*/\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n\r\n*/",
            "Time": "class Time\n{\n    static timeStarted :number = 0;\n\n    private static date : Date;\n\n    static Init ()\n    {\n        this.date = new Date();\n        this.timeStarted = this.date.getTime();\n    }\n\n    static get deltaTime ()\n    {\n        return Engine.current.getDeltaTime() * 0.001;                \n    }\n\n    static get time ()\n    {\n        return (new Date().getTime() - this.timeStarted) * 0.001;\n    }\n}",
            "Debug": "class Debug\n{\n  static Log (info : any, includeStackTrace : boolean = false)\n  {\n    var msg = (Time.time.toFixed(3).toString() + \": \" + info);\n    if (includeStackTrace)\n    {\n      consolelog(new Error(msg).stack);\n    } else {\n      consolelog(msg);\n    }\n  }\n}",
            "Engine": "var ENABLE_EDITOR : boolean = false;\r\n\r\nclass Engine {   \r\n\r\n    public static current: BABYLON.Engine;\r\n    public static scene: BABYLON.Scene;\r\n    public static editorScene : BABYLON.Scene;\r\n    public static isPlaying : boolean = false;\r\n\r\n    //Can be adjusted for testing, specifically useful for testing memory leaks\r\n    public static get nFramesPerRenderLoop () : number \r\n    {\r\n        return this._nFramesPerRenderLoop;                \r\n    }\r\n\r\n    public static set nFramesPerRenderLoop (value : number)\r\n    {\r\n        Debug.Log(\"WARNING: nFramesPerRenderLoop is set to \" + value + \". This should only happen during testing!\");\r\n        this._nFramesPerRenderLoop = value;\r\n    }\r\n\r\n    private static _nFramesPerRenderLoop : number = 1;\r\n\r\n    public static canvas: HTMLCanvasElement;\r\n\r\n    public static toBeDestroyed: SceneObject[];    \r\n\r\n    public static meshToObject : Map<number, GameObject>;\r\n\r\n    public static editorTypes : string[] = new Array();\r\n\r\n    public static cursor = \"default\";\r\n\r\n    public static onUpdate : BABYLON.Observable<number>;\r\n\r\n    public static scripts : string[] = new Array();\r\n\r\n    public static IsEditorType (value : Component) : boolean\r\n    {\r\n        var isEditorType : boolean = this.editorTypes.indexOf(value.constructor.name) > -1;\r\n        return isEditorType;\r\n    }\r\n\r\n    public static isSwitchingToPlayMode : boolean;\r\n\r\n    public static SwitchToPlayMode ()\r\n    {\r\n        this.isSwitchingToPlayMode = true;\r\n    }\r\n\r\n    public static StopPlayMode ()\r\n    {\r\n        Engine.isPlaying = false;\r\n    }\r\n\r\n    public static getUrl(): string {\r\n        if (Engine.url == \"\") {\r\n            //TODO How to get the URL in the future?\r\n            var modelUrl = getModel(\"ball\");\r\n            var splits = modelUrl.split('/');\r\n            splits.pop();\r\n            Engine.url = splits.join('/') + \"/\";\r\n        }\r\n        return Engine.url;\r\n    }\r\n\r\n    static url: string = \"\";\r\n\r\n    public static getFullName(name: string, fileType: FileType) : string {\r\n        var fullUrl: string = \"\";\r\n        switch (fileType) {\r\n            case FileType.Model:\r\n                fullUrl = getModel(name);\r\n                break;\r\n            case FileType.Texture:\r\n                fullUrl = getTexture(name);\r\n                break;\r\n            case FileType.Sound:\r\n                fullUrl = getSound(name);\r\n                break;\r\n            default:\r\n                //statements; \r\n                break;\r\n        }\r\n        if (fullUrl == null || fullUrl == undefined)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        return fullUrl.split('/').pop();\r\n    }\r\n\r\n    public static ShouldRun (obj : SceneObject) : boolean\r\n    {\r\n        return Engine.isPlaying || Engine.IsEditorType(obj)\r\n    }\r\n\r\n    public static OnPlayButton (evt : CustomEvent)\r\n    {\r\n        var buttonText : string = evt.detail.buttonText;\r\n        //When the recompile button is clicked, we first remove all the old listeners\r\n        PixelPADEvents.ClearAllListeners();\r\n        document.removeEventListener(\"playClicked\", Engine.OnPlayButton);\r\n    }\r\n\r\n}\r\n\r\nenum FileType {\r\n    Model = 1,\r\n    Texture,\r\n    Sound\r\n}\r\n\r\nclass Playground {\r\n\r\n    public static CreateScene(engine: BABYLON.Engine, canvas: HTMLCanvasElement): BABYLON.Scene {\r\n\r\n        PixelPADEvents.AddAllListeners();\r\n        document.addEventListener(\"playClicked\", Engine.OnPlayButton);\r\n\r\n        Engine.current = engine;\r\n        Engine.canvas = canvas;\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        Engine.scene = new BABYLON.Scene(engine);\r\n\r\n        Engine.editorScene = new BABYLON.Scene(engine);\r\n        Engine.editorScene.autoClear = false;\r\n\r\n        Engine.scene.clearColor = BABYLON.Color4.FromColor3(new BABYLON.Color3(0, 0, 0));\r\n\r\n        //Physics are handled in the Physics class\r\n        Engine.scene.enablePhysics(BABYLON.Vector3.Zero());\r\n\r\n        Engine.meshToObject = new Map();\r\n        Engine.toBeDestroyed = new Array();\r\n\r\n        Engine.onUpdate = new BABYLON.Observable();\r\n\r\n        Engine.scripts = Engine.scripts.concat(getScripts());\r\n        \r\n        Time.Init();\r\n        Cursor.Init();\r\n        Material.Init();\r\n        MeshLoader.Init();\r\n        TextureSystem.Init();\r\n        Physics.Init();\r\n        Input.Init();\r\n        SceneManager.Init();\r\n        //Create Shadows and Main Directional Light \r\n        Shadows.Init();\r\n\r\n        if (ENABLE_EDITOR)\r\n        {\r\n            UnionEditor.Init();\r\n        }\r\n        else \r\n        {\r\n            Engine.isPlaying = true;\r\n        }\r\n        SceneManager.LoadScene(\"MainScene.scn\");\r\n\r\n        setTimeout(() => {\r\n            Engine.current.stopRenderLoop();\r\n\r\n                    //Used to run multiple scenes\r\n\r\n            Engine.current.runRenderLoop(() => {\r\n                Engine.scene.render();\r\n                if (ENABLE_EDITOR)\r\n                {\r\n                    Engine.editorScene.render();\r\n                }\r\n            });\r\n        });\r\n\r\n        // Game/Render loop\r\n        Engine.scene.onBeforeRenderObservable.add(() => {\r\n            for (var j = 0; j < Engine.nFramesPerRenderLoop; j++) \r\n            {\r\n                if (ENABLE_EDITOR)\r\n                {\r\n                    UnionEditor.Update();\r\n                }\r\n\r\n                if (Engine.isSwitchingToPlayMode)\r\n                {\r\n                    Engine.isSwitchingToPlayMode = false;\r\n                    Engine.isPlaying = true;\r\n                    return;\r\n                }\r\n\r\n                var scene = SceneManager.GetActiveScene();\r\n\r\n                if (scene)\r\n                {\r\n                    //Start is not called directly after Awake\r\n                    //This should take care of any objects being created in the Start\r\n                    for (var i = 0; i < scene.newObjs.length; i++) {\r\n                        scene.newObjs[i].InternalStart();\r\n                    }\r\n                    scene.newObjs = new Array();\r\n\r\n                    for (var i =scene.objs.length -1; i >= 0 ; i--) {\r\n                        scene.objs[i].InternalUpdate();\r\n                    }\r\n\r\n                    Engine.onUpdate.notifyObservers(0);\r\n                }\r\n\r\n                Material.Update();\r\n                \r\n                //Updates all 'just' pushed or released keys\r\n                Input.Update();\r\n\r\n                //Process detroyed objects\r\n                for (var i = 0; i < Engine.toBeDestroyed.length; i++) {\r\n                    var obj = Engine.toBeDestroyed[i];\r\n                    obj.InternalDestroy();\r\n                }\r\n\r\n                Engine.toBeDestroyed = new Array();\r\n                \r\n                SceneManager.Update();\r\n\r\n\r\n            }\r\n        });        \r\n        \r\n        Engine.scene.onPointerObservable.add((ev) => {\r\n            \r\n            canvas.style.cursor = Engine.cursor;  \r\n        });\r\n\r\n        return Engine.scene;\r\n    }\r\n\r\n}\r\n\r\n//Some helper methods - just like Unity\r\n\r\nfunction Instantiate<T extends MonoBehaviour>(objType: string | (new () => T), startPosition: Vector3 = Vector3.Zero()): T {\r\n   \r\n    return GameObject.Instantiate<T>(objType, startPosition);\r\n}\r\n\r\n\r\n\r\nfunction Destroy(obj) {\r\n    GameObject.Destroy(obj);\r\n}\r\n\r\nfunction print(info: any) {\r\n    Debug.Log(info);\r\n}\r\n\r\n//Attribute\r\nfunction ExecuteInEditMode(target: Function) {\r\n    Engine.editorTypes.push(target.prototype.constructor.name);\r\n}\r\n",
            "PixelPADEvents": "/*\nAll External events coming from the PixelPAD website go through this wrapper\nThe only exception is the stop button - since this is handled directly in the engine.\n*/\n\n//TODO Clean this up into objects of a PixePADEventListenerClass\nclass PixelPADEvents {\n\n  public static onSceneClicked : BABYLON.Observable<string>;\n  public static onSaveClicked : BABYLON.Observable<string>;\n  public static onMaterialClicked : BABYLON.Observable<string>;\n  public static onPrefabClicked : BABYLON.Observable<string>;\n  \n  //Start is called before the first frame update\n  static AddAllListeners() \n  {\n    PixelPADEvents.onSceneClicked = new BABYLON.Observable();\n    PixelPADEvents.onSaveClicked = new BABYLON.Observable();\n    PixelPADEvents.onMaterialClicked = new BABYLON.Observable();\n    PixelPADEvents.onPrefabClicked = new BABYLON.Observable();\n\n    document.addEventListener(\"sceneClicked\", this.OnSceneClicked);\n    document.addEventListener(\"saveClicked\", this.OnSaveClicked);\n    document.addEventListener(\"materialClicked\", this.OnMaterialClicked);\n    document.addEventListener(\"prefabClicked\", this.OnPrefabClicked);\n  }\n  \n  static ClearAllListeners ()\n  {\n    document.removeEventListener(\"sceneClicked\", this.OnSceneClicked);\n    document.removeEventListener(\"saveClicked\", this.OnSaveClicked);\n    document.removeEventListener(\"materialClicked\", this.OnMaterialClicked);\n    document.removeEventListener(\"prefabClicked\", this.OnPrefabClicked);\n\n    PixelPADEvents.onSceneClicked.clear();\n    PixelPADEvents.onSaveClicked.clear();\n    PixelPADEvents.onMaterialClicked.clear();\n    PixelPADEvents.onPrefabClicked.clear();\n  }\n\n  private static OnSceneClicked (e : CustomEvent)\n  {\n    PixelPADEvents.onSceneClicked.notifyObservers( e.detail.sceneName);\n  }\n\n  private static OnSaveClicked (e : CustomEvent)\n  {\n    PixelPADEvents.onSaveClicked.notifyObservers(e.detail.buttonText);\n  }\n\n  private static OnMaterialClicked (e : CustomEvent)\n  {\n    PixelPADEvents.onMaterialClicked.notifyObservers(e.detail.materialName);    \n  }\n\n  private static OnPrefabClicked (e : CustomEvent)\n  {\n    PixelPADEvents.onPrefabClicked.notifyObservers(e.detail.prefabName);    \n  }\n}\n\n",
            "Serializer": "class Serializer {\n  public static isCreatingGameObject;\n  public static isSettingParent;\n\n  private static serializedProperties: Map<any, string[]> = new Map();\n  //Some properties are serialized but should not show in inspector\n  private static hiddenProperties: Map<any, string[]> = new Map();\n\n  private static isSerializingPrefab;\n\n  static RegisterSerialized(target: any, property: any): void {\n    let keys: string[] = this.serializedProperties.get(target);\n    if (!keys) {\n      keys = [];\n      this.serializedProperties.set(target, keys);\n    }\n    keys.push(property);\n  }\n\n  static RegisterHideInInspector(target: any, property: any): void {\n    let keys: string[] = this.hiddenProperties.get(target);\n    if (!keys) {\n      keys = [];\n      this.hiddenProperties.set(target, keys);\n    }\n    keys.push(property);\n  }\n\n  //Returns all serialized properties of an object, including it's base classes\n  static GetProperties(objType: any, includeHidden: boolean): string[] {\n    let keys: string[] = new Array();\n\n    let baseClass: any = Object.getPrototypeOf(objType);\n\n    if (baseClass) {\n      //Recursion to append to keys.\n      keys = keys.concat(this.GetProperties(baseClass, includeHidden));\n    }\n\n    //If it's serialized, but not hidden...\n    if (this.serializedProperties.has(objType)) {\n      //The props of only this class (not using inheritance)\n      let props = this.serializedProperties.get(objType);\n      //Copy over the array (is this the best approach?)\n      props.forEach((value: string) => {\n        //if includeHidden (means ignore HideInInspector refs) OR if it's not a hidden property\n        if (includeHidden || !(this.hiddenProperties.has(objType) && this.hiddenProperties.get(objType).indexOf(value) != -1)) {\n          keys.push(value)\n        }\n      }\n      );\n    }\n\n\n    return keys;\n  }\n\n  static GetPropValues(target: any, includeHidden: boolean): Map<string, any> {\n    //The map that we return\n    var propValues: Map<string, any> = new Map();\n\n    var targetObjectType = Object.getPrototypeOf(target);\n\n    let keys: string[] = this.GetProperties(targetObjectType, includeHidden);\n    //Fill up the map with those strings\n    for (const property of keys) {\n      propValues.set(property, target[property]);\n    }\n\n    return propValues;\n  }\n\n  static nl: NextLine;\n\n  static FromJSON(jsonData: string, reportErrors : boolean = true): any {\n    try {\n      //A cast is only a hint for static code analysis but doesn't have any effect at runtime.\n      var jsonObject: any = JSON.parse(jsonData);\n\n      var realObject: any = this.CreateFromJSObj(jsonObject);\n\n      return realObject;\n    } catch (e) {\n      if (reportErrors)\n      {\n        Debug.Log(\"Error creating JSON Object: \" + e);\n      }\n      return null;\n    }\n\n    return realObject;\n  }\n\n  //owner can be either a Transform (for children GameObjects) or a GameObject (for components)\n  static CreateFromJSObj(jsObj: any, propDesc: PropertyDescriptor = null, owner: BaseObject = null): any {\n    if (jsObj == null) {\n      return null;\n    }\n    var objType: string = jsObj.t;\n\n    var isCreatingPrefab = false;\n\n    if (objType == \"GameObject\") {\n      if (jsObj.prefabName)\n      {\n        isCreatingPrefab = true;\n      }\n      //Used in the GameObject constructor to not create default components when Serializing.\n      this.isCreatingGameObject = true;\n    }\n\n    //instance creation here. Instance might not exist so we just return null in that case\n    try {\n    var obj: any = eval(\"new \" + objType + \"();\");\n    } catch (e) {Debug.Log(e);\n    return null;}\n    this.isCreatingGameObject = false;\n\n    var props = this.GetProperties(obj, true);\n\n    var children: Transform[] = new Array;\n\n    props.forEach((propName: string) => {\n\n      var value = null;\n      try {\n        var p: PropertyDescriptor = Object.getOwnPropertyDescriptor(jsObj, propName);\n        value = p.value;\n      } catch (error) {\n        //No need to print. This means that the serialized field in the object, could not be found in the JSON\n        //This can simply mean that the JSON did not yet contain that serialized property (e.g. if it was just added)\n        return;\n      }\n      if (value === null) {\n        //Do nothing (variable can remain null)\n      } else if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        Object.defineProperty(obj, propName, p);\n\n      } else if (value instanceof Array) {\n        var isc: boolean = obj instanceof GameObject && propName == \"components\";\n\n        for (var i: number = 0; i < value.length; i++) {\n          value[i] = (this.CreateFromJSObj(value[i], null, isc ? obj : null));\n        }\n\n        //We store the 'children' array for later.\n        if (obj instanceof Transform && propName == \"ser_children\") {\n          //Removes all null elements from the list.\n          //Due to the serialization process more and more null elements get added\n          children = value;    \n        }\n\n        //If isComponent, we don't need to redefine the 'components' array since we already push the \n        //components through their Awake call.\n        if (!isc) {\n          Object.defineProperty(obj, propName, p);\n        }\n      } else {\n        //When we use defineProperty, it is ESSENTIAL we set a PropertyDescriptor\n        //If we only set the value, it will override access modifiers\n        //E.g. after setting, a read+write variable might just become read only 0_o\n        Object.defineProperty(obj, propName, this.CreateFromJSObj(value, p));\n      }\n    });\n\n    //Components need to have Awake called when they're initiated         \n    if (owner) {\n      obj.InternalPreAwake(owner);\n      //Transform component needs it's awakening called beforehand.\n      if (objType == \"Transform\")\n      {\n        obj.InternalAwake(owner);\n        //AFTER the Transform has 'awoken' we can set the children to it.\n        //The order here is:\n        //1) Start Transform Creation\n        //2) Create Children\n        //3) Finish Transform Creation\n        //4) Set Children to be parented to Transform\n        for (var i: number = 0; i < children.length; i++) {\n          this.isSettingParent = true;\n          if (children[i]?.transform) {\n            children[i].transform.SetParent(obj, false);\n          }\n          this.isSettingParent = false;\n        }\n      }\n      \n    }\n\n    if (isCreatingPrefab)\n    {\n      Prefab.Create(jsObj.prefabName, obj);\n    }\n\n    if (objType == \"GameObject\") {\n      var go = obj as GameObject;\n      go.components.forEach(c => {\n        //Skip the transform component (already handled above)\n        if (c.transform != c)\n        {\n          c.InternalAwake(go);\n        }\n      });\n    }\n\n    if (propDesc) {\n      propDesc.value = obj;\n      return propDesc;\n    }\n\n    return obj;\n  }\n\n  static ToJSON(target: any, prettyPrint: boolean = false): string {\n\n    this.nl = new NextLine(prettyPrint);\n    return this.GetPropertyJSON(target);\n  }\n\n  private static GetPropertyJSON(target: any): string {\n    \n    var data: string = \"\";\n\n    if (!target)\n    {\n      return \"null\";\n    }\n\n    var typeName = target.constructor.name;\n    var isParentPrefab = false;\n    if (typeName == \"GameObject\")\n    {\n      if (target.prefabParent)\n      {\n        if (target.prefabParent == target)\n        {\n          isParentPrefab = true;\n        }\n        else \n        {\n          //If it has a prefab Parent (and it's not the prefab parent itself)\n          //we return null since we will be loading this from the prefab.\n          return \"null\";\n        }\n      }\n    }\n\n    //Shortcut    \n    var nl = this.nl;\n\n    data += \"{\" + nl.Tab();\n\n\n    data += \"\\\"t\\\":\\\"\" + typeName + \"\\\"\";\n    \n\n    var propValues: Map<string, any> = this.GetPropValues(target, true);\n    propValues.forEach((value: any, key: string) => {\n      //Too hacky?\n      if (this.isSerializingPrefab)\n      {\n        //If it's the Prefab\n        if (isParentPrefab && key == \"name\")\n        {\n          value = target.prefabName;\n        }\n      }\n      data += \",\" + nl;\n      data += \"\\\"\" + key + \"\\\"\" + \":\";\n      if (value === null || value === undefined) {\n        data += \"null\";\n      } else if (value instanceof Array) {\n        data += \"[\" + nl.Tab();\n        for (var j: number = 0; j < value.length; j++) {\n          data += this.GetPropertyJSON(value[j]);\n          if (j < value.length - 1) {\n            data += \",\" + nl;\n          }\n        }\n        data += (nl.ShiftTab() + \"]\");\n      }\n      else if (typeof value == 'number' || typeof value == 'boolean') {\n        data += value;\n      }\n      else if (typeof value == 'string') {\n        data += \"\\\"\" + value + \"\\\"\";\n      } else {\n        //Assuming everything can be processed.  \n        data += nl + this.GetPropertyJSON(value);\n      }\n    });\n\n    data += nl.ShiftTab() + \"}\";\n\n    return data;\n  }\n}\n\nclass NextLine {\n\n  private nl: string = \"\\n\";\n\n  private tab = \"   \";\n\n  constructor(_prettyPrint: boolean) {\n    this.prettyPrint = _prettyPrint;\n  }\n\n\n  prettyPrint: boolean = true;\n\n  ShiftTab(): string {\n    if (this.nl.endsWith(this.tab)) {\n      this.nl = this.nl.substring(0, this.nl.length - this.tab.length);\n    }\n    return this.toString();\n  }\n\n  Tab(): string {\n    this.nl += this.tab;\n    return this.toString();\n  }\n\n  toString(): string {\n    if (this.prettyPrint) {\n      return this.nl;\n    }\n\n    return \"\";\n  }\n}\n\nfunction SerializeField(target: any, propertyKey: string) {\n  Serializer.RegisterSerialized(target, propertyKey);\n}\n\nfunction HideInInspector(target: any, propertyKey: string) {\n  Serializer.RegisterHideInInspector(target, propertyKey);\n\n}",
            "BaseObject": "//script:BaseObject\nclass BaseObject extends Object\n{\n    public name : string;\n}",
            "EditorSystem": "//script:EditorSystem\n\nclass EditorSystem\n{\n  constructor ()\n  {\n    UnionEditor.editorSystems.push(this);\n  }\n\n  OnGUI ()\n  {\n\n  }\n}",
            "Mathf": "class Mathf\n{\n  //TODO Optimize?\n  static get Rad2Deg () : number\n  {\n    return 180 / Math.PI;\n  }\n\n  static get Deg2Rad () : number\n  {\n        return Math.PI / 180;\n  }\n\n  static Clamp (value : number, min : number, max : number)\n  {\n    return Math.min(Math.max(value, min), max);\n  }\n\n  static Min (value : number, min : number)\n  {\n    return Math.min(value, min);\n  }\n\n  static Max (value : number, min : number)\n  {\n    return Math.max(value, min);\n  }\n\n  static MoveTowards (current : number, target : number, maxDelta : number) : number\n  {\n    if (current < target - maxDelta)\n    {\n      return current + maxDelta;\n    } else if (current > target + maxDelta)\n    {\n      return current - maxDelta;\n    }\n    return target;\n  }\n}",
            "SceneObject": "class SceneObject extends BaseObject {\n    prefabParent: GameObject;\n\n    public get markedForDestroy(): boolean {\n        return this._markedForDestroy || this.gameObject._markedForDestroy;\n    };\n\n    public set markedForDestroy(value: boolean) {\n        this._markedForDestroy = value;\n    }\n\n    private _markedForDestroy: boolean = false;\n\n    public GetType(): string {\n        return this.constructor.name;\n    }\n\n    public get transform(): Transform {\n        return this.gameObject.transform;\n    }\n\n    public get renderer(): Renderer {\n        return this.gameObject.renderer;\n    }\n\n    public get gameObject(): GameObject {\n        return this._gameObject;\n    }\n\n    private _gameObject: GameObject;\n\n\n    InternalPreAwake(go: GameObject) {\n        SceneManager.MarkSceneAsDirty();\n        this._gameObject = go;\n        SceneManager.GetActiveScene().newObjs.push(this);\n    }\n\n    InternalAwake(go: GameObject) {\n        if (Engine.isPlaying || Engine.IsEditorType(this)) {\n            //User implemented so needs a try-catch\n            try {\n                this.Awake();\n            } catch (e) {\n                Debug.Log(e);\n            }\n        }\n    }\n\n    Awake() { }\n\n    InternalStart() {\n        if ((Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.Start();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    Start() { }\n\n    InternalUpdate() {\n        if ((Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.Update();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    Update() { }\n\n    InternalDestroy() {\n        if (!Engine.isPlaying) {\n            SceneManager.MarkSceneAsDirty();\n        }\n\n        if (Engine.isPlaying || Engine.IsEditorType(this)) {\n            try {\n                this.OnDestroy();\n            } catch (e) {\n                Debug.Log(e);\n            }\n        }\n        //Remove from components array\n        const index = this.gameObject.components.indexOf(this);\n        if (index > -1) {\n            this.gameObject.components.splice(index, 1);\n        }\n    }\n\n    OnCollisionEnter(other: Collision) { }\n\n    OnTriggerEnter(otherCollider: Collider) { }\n\n    OnTriggerStay(otherCollider: Collider) { }\n\n    OnTriggerExit(otherCollider: Collider) { }\n\n    OnDestroy() { }\n\n    GetComponent<T extends Component>(objType: new () => T): T {\n        for (var i: number = 0; i < this.gameObject.components.length; i++) {\n            if (this.CheckType(this.gameObject.components[i], objType)) {\n                var x: T = this.gameObject.components[i] as T;\n                //No need to check if it's about to be destroyed.\n                //if (!x.markedForDestroy)\n                {\n                    return x;\n                }\n            }\n        }\n        return null;\n    }\n\n    //Recursive function to check for base-classes as well\n    CheckType(c: Component, objType: any): boolean {\n        if (c.GetType() === objType.name) {\n            return true;\n        }\n\n        //Stop looking after 'Component' \n        if (c.GetType() == \"Component\") {\n            return false;\n        }\n\n        return this.CheckType(Object.getPrototypeOf(c), objType);\n    }\n\n}",
            "Component": "class Component extends SceneObject\n{   \n    public static isc : boolean = true;\n\n    get name ()\n    {\n        return this.gameObject.name;\n    }\n\n    set name (value : string)\n    {\n        this.gameObject.name = value;\n    }\n\n   InternalPreAwake (go : GameObject)\n   {\n       go.components.push(this);  \n       super.InternalPreAwake(go);       \n   }\n}\n\n//Attribute that is used to Register a Script as a component\n//This is used as an addition to all scripts that are already registered through the Script name\nfunction RegisterAsComponent(target: Function) {\n    Engine.scripts.push(target.prototype.constructor.name);\n}",
            "GameObject": "class GameObject extends SceneObject {\n\n    public static FindObjectOfType<T extends Component>(objType: new () => T): T {\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            var comp = objs[i].GetComponent(objType);\n            if (comp) {\n                return comp;\n            }\n        }\n        \n        return null;\n    }\n\n    /**To find something*/\n    public static Find(name: string): GameObject {\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            if (objs[i].name == name) {\n                return objs[i];\n            }\n        }\n        return null;\n    }\n\n\n    @SerializeField\n    public name: string;\n\n    @SerializeField\n    components: Component[];\n\n    //TODO we should not refer to the prefab by name...\n    @SerializeField\n    prefabName: string;\n\n    private get activeScene(): Scene {\n        return SceneManager.GetActiveScene();\n    }\n\n    //TODO Optimize\n    public get transform(): Transform {\n        return this.GetComponent(Transform);\n    }\n\n    /** The renderer component is used to display the mesh. If no Renderer component exists, it's automatically added */\n    public get renderer(): Renderer {\n        if (this._renderer == null) {\n            this._renderer = this.GetComponent(Renderer);\n            if (this._renderer == null) {\n                this._renderer = this.AddComponent(Renderer);\n            }\n        }\n        return this._renderer;\n    }\n\n    private _renderer: Renderer;\n\n    public get objectPhysics(): ObjectPhysics {\n        if (this._objectPhysics == null) {\n            this._objectPhysics = new ObjectPhysics();\n            this._objectPhysics.Init(this);\n        }\n        return this._objectPhysics;\n    }\n\n    private _objectPhysics: ObjectPhysics;\n\n    static Destroy(obj: SceneObject) {\n        obj.markedForDestroy = true;\n        Engine.toBeDestroyed.push(obj);\n    }\n\n    static Instantiate<T extends MonoBehaviour>(objType: string | (new () => T), startPosition: Vector3 = Vector3.Zero()) {\n        //We first create an empty GameObject\n        var gameObject = null;\n        if (typeof objType === \"string\") {\n            gameObject = Prefab.Create(objType + \".prefab\");\n            gameObject.transform.position = startPosition.clone();\n            return gameObject;\n        }\n        else {\n            gameObject = new GameObject();\n\n            //We add this Component as a default one\n            var defaultComponent = gameObject.AddComponent(objType);\n\n            gameObject.name = \"GameObject (\" + defaultComponent.GetType() + \")\";\n\n            gameObject.transform.position = startPosition.clone();\n\n            return defaultComponent;\n        }\n    }\n\n    constructor() {\n        super();\n        this.InternalPreAwake(this);\n        this.name = \"GameObject\";\n\n        //When creating from a SerializedObject, it does not add these two default components.\n        if (!Serializer.isCreatingGameObject) {\n            //Every GameObject has a Transform & Renderer by default\n            this.AddComponent(Transform);\n            //this.AddComponent(Renderer);\n        }\n        \n        this.InternalAwake(this);\n    }\n\n    AddComponent<T extends Component>(objType: (new () => T) | string): T {\n        var newComponent: T = null;\n        if (typeof objType == \"string\") {\n            newComponent = eval(\"new \" + objType + \"()\");\n        } else {\n            newComponent = new objType();\n        }\n        newComponent.InternalPreAwake(this);\n        newComponent.InternalAwake(this);\n        return newComponent;\n    }\n\n    OnCollisionEnter(otherCollider: Collision) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnCollisionEnter(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerEnter(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerEnter(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerStay(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerStay(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerExit(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerExit(otherCollider);\n            }\n        }\n    }\n\n    InternalPreAwake(go: GameObject) {\n        this.components = new Array();\n        super.InternalPreAwake(go);\n        this.activeScene.objs.push(this);\n        this.activeScene.rootObjs.push(this);\n    }\n\n    InternalStart() {\n        super.InternalStart();\n    }\n\n    InternalUpdate() {\n        super.InternalUpdate();\n        for (var i = 0; i < this.components.length; i++) {\n            this.components[i].InternalUpdate();\n        }\n    }\n\n    InternalDestroy() {\n\n        for (var i = this.components.length - 1; i >= 0; i--) {\n            this.components[i].InternalDestroy();\n        }\n\n        if (this._objectPhysics) {\n            this._objectPhysics.OnDestroy();\n        }\n\n        //Remove from objects array\n        const index = this.activeScene.objs.indexOf(this);\n        if (index > -1) {\n            this.activeScene.objs.splice(index, 1);\n        }\n        const index2 = this.activeScene.rootObjs.indexOf(this);\n        if (index2 > -1) {\n            this.activeScene.rootObjs.splice(index2, 1);\n        }\n    }\n}",
            "MonoBehaviour": "class MonoBehaviour extends Component \r\n{\r\n\r\n}\r\n",
            "MainGame": "\nENABLE_EDITOR = true;\n//*\n\nclass MainGame extends MonoBehaviour {\n\n  //Start is called before the first frame update\n  Awake() {\n    var b = new BABYLON.GUI.Button(\"SimpleButton\");\n    b.width = \"100px\";\n    b.height = \"20px\";\n    Canvas.main.addControl(b);\n  }\n\n  //Update is called once per frame\n  Update() {\n\n  }\n\n\n}\n/*\n@RegisterAsComponent\nclass RotationTest extends MonoBehaviour {\n\n  @SerializeField\n  pla: number = 4;\n\n  newParent = null;\n\n  Start() {\n\n\n  }\n\n  Update() {\n        Cursor.lockState = CursorLockMode.Locked;\n\n    \n    Cursor.lockState = CursorLockMode.Locked;\n\n    var mouseXInput = Input.GetAxis(\"Mouse X\");\n    var mouseYInput = Input.GetAxis(\"Mouse Y\");\n    this.transform.Rotate(mouseYInput, mouseXInput, 0);\n    \n  }\n}\n\n@RegisterAsComponent\nclass Ground extends MonoBehaviour {\n  Start() {\n    this.GetComponent(BoxCollider).layerMask = 2 | 4 | 8 | 16;\n  }\n}\n\n@RegisterAsComponent\nclass MyBox extends MonoBehaviour {\n\n  @SerializeField\n  triggerTime: number = 0;\n\n  @SerializeField\n  movement: number = 0;\n\n  mat: BABYLON.StandardMaterial;\n\n  @SerializeField\n  meshOffset: Vector3 = new Vector3(0, 0, 0);\n\n  m: BABYLON.Mesh;\n\n\n  //Start is called before the first frame update\n  Start() {\n\n  }\n\n  //Update is called once per frame\n  Update() {\n    // this.transform.eulerAngles.z += 1;\n    //this.transform.position.y += this.speed;\n    //this.transform.position.x += this.movement;\n    if (!this.m) {\n      this.m = this.renderer.GetMesh();\n      // var v : BABYLON.Vector3 = new BABYLON.Vector3();\n      // Vector3.VtoB(this.meshOffset, v);\n      this.m.locallyTranslate(new BABYLON.Vector3(13, 0, 50));\n      this.m.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n    }\n\n    if (this.m) {\n\n      // this.m.translate(new BABYLON.Vector3(0,0,1), 10); \n      //);\n    }\n  }\n\n  OnTriggerEnter(coll: Collider) {\n    this.renderer.material.shader.diffuseColor = BABYLON.Color3.Green();\n  }\n\n  OnTriggerExit(coll: Collider) {\n    this.renderer.material.shader.diffuseColor = BABYLON.Color3.Red();\n  }\n\n  OnTriggerStay(coll: Collider) {\n    this.triggerTime += Time.deltaTime;\n  }\n}\n\n/* */\n\n",
            "Camera": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Camera extends MonoBehaviour {\n  public static main: Camera;\n\n\n  public set mode(value: number) {\n    this.bCam.mode = value;\n  }\n\n  public get mode(): number {\n    return this.bCam.mode;\n  }\n\n  public orthoGraphicSize: number = 5;\n\n  //TargetCamera because regular Camera can't update position/rotation\n  public bCam: BABYLON.TargetCamera;\n\n  //This is a bit hacky but that way the camera view doesn't reset in playmode\n  Awake() {\n    if (this.bCam != null) {\n      this.bCam.dispose();\n    }\n    //var cam = new BABYLON.TargetCamera(\"MainCamera\", new BABYLON.Vector3(0, 0, -10), Engine.scene);\n    this.bCam = new BABYLON.TargetCamera(\"Camera\", new BABYLON.Vector3(0, 10, 0), Engine.scene);\n    if (ENABLE_EDITOR)\n    {\n      this.bCam.viewport = new BABYLON.Viewport(0,0,0.7, 0.5);\n    } else {\n      this.bCam.viewport = new BABYLON.Viewport(0, 0, 1, 1);\n    }\n\n    this.bCam.layerMask = 2;\n\n    //Unshift because we dont want it to be at the top.\n    Engine.scene.activeCameras.push(this.bCam);\n\n    Camera.main = this;\n  }\n\n  Update() {\n    this.bCam.position = this.transform.transformNode.absolutePosition;\n    this.bCam.rotationQuaternion = this.transform.transformNode.absoluteRotationQuaternion;\n\n    if (Camera.main.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {\n      var vert = this.orthoGraphicSize;\n      var horz = vert * Engine.current.getScreenAspectRatio();\n      this.bCam.orthoTop = vert;\n      this.bCam.orthoBottom = -vert;\n      this.bCam.orthoLeft = -horz;\n      this.bCam.orthoRight = horz;\n    }\n  }\n\n  OnDestroy() {\n    this.bCam.dispose();\n  }\n}",
            "EditorCam": "class EditorCam  {\n\n  cam : BABYLON.ArcRotateCamera;\n\n  isAttached: boolean = false;\n\n\n  constructor ()\n  {\n    this.cam = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), Engine.scene);\n    \n    this.cam.viewport = new BABYLON.Viewport(0,0.5,0.7, 0.5);  \n\n    this.cam.attachControl(Engine.canvas, true);\n    this.cam.layerMask = 3;\n    this.cam.wheelPrecision = 10\n    this.isAttached = true;\n\n    Engine.scene.activeCameras.push(this.cam);\n    Engine.scene.onBeforeRenderObservable.add((ev) => {\n      this.Update();\n    });\n\n    \n  }\n\n  Update ()\n  {\n    //Detach on Update\n    if (this.isAttached && (EditorUI.IsPointerOverEditor() || !Input.GetKey(KeyCode.Alt))) {\n      this.cam.detachControl(Engine.canvas);\n      this.isAttached = false;\n    }\n    else if (!this.isAttached && (!EditorUI.IsPointerOverEditor() && Input.GetKey(KeyCode.Alt))) {\n      this.cam.attachControl(Engine.canvas, true);\n      this.isAttached = true;\n    }\n    \n    if (Input.GetKeyDown(KeyCode.F)) {\n      var hasSelection = EditorSelection.GetSelection()?.length > 0;\n      if (hasSelection)\n      {\n        this.cam.target = Vector3.VtoB(EditorSelection.GetCenterPoint(), new BABYLON.Vector3());\n      }\n    }\n  }\n}\n",
            "Renderer": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Renderer extends Component {\n\n    public onChangedMesh: BABYLON.Observable<number>;\n\n    private meshes: BABYLON.Mesh[] = new Array();\n    @SerializeField\n    private meshName: string = \"\";\n\n    @SerializeField\n    public materialName: string = \"\";\n\n    @SerializeField\n    public scale: number = 1;\n    \n    @SerializeField\n    public castShadows : boolean = true;\n\n    private prevCastShadows: boolean = true;\n    \n    @SerializeField\n    public receiveShadows : boolean = false;\n    \n    private prevReceiveShadows: boolean = false;\n\n    private _lastScale: number = 1;\n\n    public material: Material;\n\n    private textureName: string = \"\";\n\n    private _isVisible: boolean = true;\n\n    public get isVisible(): boolean {\n        return this._isVisible;\n    }\n\n    public set isVisible(value: boolean) {\n        this._isVisible = value;\n        this.meshes.forEach((mesh) => {\n            mesh.isVisible = value;\n        });\n    }\n\n    public isLoadingMesh: boolean = false;\n\n    public scaleFactor: BABYLON.Vector3 = BABYLON.Vector3.One();\n\n    private isSprite: boolean = false;\n    private spriteDisplayed: boolean = false;\n    private lastMeshName: string = \"\";\n    private lastMatName: string = \"\";\n\n\n    private mergeMeshes: boolean = false;\n\n\n    Awake() {\n        //We removed the array of meshes for optimization\n        this.onChangedMesh = new BABYLON.Observable();\n    }\n\n    Start() {\n        this.CheckForMeshUpdate();\n    }\n\n    //Check for inspector update.\n    CheckForMeshUpdate() {\n        //If it was deserialized the meshName is set but LoadMesh is never called.\n        if (this.meshName && this.meshName != this.lastMeshName) {\n            this.LoadMesh(this.meshName, this.scale);\n        }\n\n        if (this.materialName && this.materialName != this.lastMatName && this.meshes.length > 0) {\n            this.UpdateMaterial();\n        }\n    }\n\n    Update() {\n        if (this.prevCastShadows != this.castShadows)\n        {\n            this.UpdateShadows();\n            this.prevCastShadows = this.castShadows;\n        }\n        if (this.prevReceiveShadows != this.receiveShadows)\n        {\n            this.UpdateShadows();\n            this.prevReceiveShadows = this.receiveShadows;\n        }\n\n        this.CheckForMeshUpdate();\n        this.InternalUpdateMeshes();\n    }\n\n    SetSprite(textureName: string) {\n        this.SetMesh(BABYLON.Mesh.CreatePlane(\"sprite\", 1, Engine.scene));\n\n        //Sprites just have a unique material.\n        this.material = new Material(\"Sprite\");\n        this.material.shader = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n        this.material.shader.diffuseTexture = TextureSystem.GetSprite(textureName);\n\n        this.material.shader.diffuseTexture.hasAlpha = true;\n        this.material.shader.emissiveTexture = this.material.shader.diffuseTexture;\n        this.material.shader.backFaceCulling = true;\n\n        //Sprite is always a Single Mesh\n        this.GetMesh().material = this.material.shader;\n\n        this.isSprite = true;\n        this.spriteDisplayed = false;\n    }\n\n    InternalUpdateMeshes() {\n        if (this.isSprite) {\n            if (!this.spriteDisplayed) {\n                this.material.shader = this.meshes[0].material as BABYLON.StandardMaterial;\n                var size = this.material.shader.diffuseTexture.getSize();\n                //We need to check the width because the first time it is loaded this value might be 0\n                if (size.width != 0) {\n                    this.scaleFactor = new BABYLON.Vector3(size.width * 0.01, size.height * 0.01, 1);\n                    this.spriteDisplayed = true;\n                    this.UpdateScaling();\n                }\n            }\n        } else {\n            if (this.scale != this._lastScale) {\n                this.scaleFactor = new BABYLON.Vector3(this.scale, this.scale, this.scale);\n                this.UpdateScaling();\n                this._lastScale = this.scale;\n            }\n        }\n\n        //We can't use the mesh-callback since we need to reference this.transform\n        if (this.isLoadingMesh) {\n            //We merge the meshes!\n            var meshes: BABYLON.Mesh[] = MeshLoader.GetMesh(this.meshName, this.textureName);\n            if (meshes != null) {\n                if (this.mergeMeshes) {\n                    this.SetMesh(BABYLON.Mesh.MergeMeshes(meshes, true, true));\n                } else {\n                    this.SetMesh(meshes);\n                }\n                this.isLoadingMesh = false;\n            } else {\n                return;\n            }\n        }\n    }\n\n    UpdateScaling() {\n        this.meshes.forEach((mesh: BABYLON.Mesh) => {\n            mesh.scaling = this.scaleFactor ;//this.transform.transformNode.absoluteScaling.clone().multiply(this.scaleFactor);\n        });\n    }\n\n    RemoveMesh() {\n        if (this.meshes) {\n            this.meshes.forEach((mesh: BABYLON.Mesh) => {\n                try {\n                    //print(\"Removing \" + this.mesh.name + \" to meshToObj with id \" +this.mesh.uniqueId);\n                    Engine.meshToObject.delete(mesh.uniqueId);\n\n                    //This is false so when doing a scene reload the textures persist\n                    mesh.dispose(false, false);\n\n                    //If it's not a material from the material system...\n                    if (!Material.Get(this.materialName)) {\n                        mesh.material?.dispose();\n                    }\n                    this.material = null;\n                } catch (e) {\n                    console.warn(\"Failed to dispose mesh of \" + (this.gameObject ? this.gameObject.name : \"<Unknown>\") + \". Has the array of meshes been modified?\")\n                }\n            });\n            this.meshes = new Array();\n        }\n    }\n\n    SetMesh(newMesh: BABYLON.Mesh | BABYLON.Mesh[]) {\n        //Just in case.\n        this.RemoveMesh();\n\n        if (newMesh instanceof BABYLON.Mesh) {\n            this.SetSingleMesh(newMesh);\n        } else {\n            //TODO Implement this.\n            newMesh.forEach((mesh: BABYLON.Mesh) => {\n                this.SetSingleMesh(mesh);\n            });\n        }\n        \n        this.UpdateScaling() ;\n        this.UpdateShadows ();\n        this.onChangedMesh.notifyObservers(0);\n    }\n\n    private UpdateShadows () {\n        this.meshes.forEach((mesh: BABYLON.Mesh) => {\n            mesh.receiveShadows = this.receiveShadows;\n            \n            if (this.castShadows)\n            {\n                Shadows.AddCastingMesh(mesh);\n            } else {\n                Shadows.RemoveCastingMesh(mesh);\n            }\n            \n        });\n        \n    }\n\n    private SetSingleMesh(newMesh: BABYLON.Mesh) {\n        this.meshes.push(newMesh);\n\n        Engine.meshToObject.set(newMesh.uniqueId, this.gameObject);\n\n        //Meshes get parented to their transform. A mesh should never be moved by itself, but instead the transform component should be used.\n        newMesh.parent = (this.transform.transformNode);\n\n        newMesh.isVisible = true;\n\n        this.UpdateMaterial();\n    }\n\n    UpdateMaterial() {\n        this.material = Material.Get(this.materialName);\n        this.meshes[0].material = this.material.shader;\n        this.lastMatName = this.materialName;\n    }\n\n    GetMesh(): BABYLON.Mesh {\n        return this.meshes[0];\n    }\n\n    GetMeshes(): BABYLON.Mesh[] {\n        return this.meshes;\n    }\n\n    LoadMesh(meshName: string, loadedScale: number = 1, textureName: string = null, mergeMeshes: boolean = true) {\n        this.RemoveMesh();\n        this.isLoadingMesh = true;\n        this.meshName = meshName;\n        this.lastMeshName = meshName;\n        this.scaleFactor = new BABYLON.Vector3(loadedScale, loadedScale, loadedScale);\n        this.mergeMeshes = mergeMeshes;\n\n        if (textureName != null) {\n            this.textureName = textureName;\n        }\n    }\n\n    InternalDestroy() {\n        super.InternalDestroy();\n        this.RemoveMesh();\n    }\n}\n",
            "Physics": "//script:Physics\n\nclass Physics {\n  public static gravity: BABYLON.Vector3 = new BABYLON.Vector3(0, -9.81, 0);\n  // public static gravity2 : BABYLON.Vector3= new BABYLON.Vector3(0, -9.81, 0);\n\n  static Init() {\n    Engine.scene.onBeforePhysicsObservable.add(() => {\n\n      Physics.BeforePhysicsUpdate();\n    });\n  }\n\n  //If the other object is already triggering us, we don't need to retrigger\n\n\n  private static BeforePhysicsUpdate() {\n    var imposters = Engine.scene._physicsEngine.getImpostors();\n\n    //We reset all trigger bools\n    for (var i = 0; i < imposters.length; i++) {\n      var op = (imposters[i].object as ObjectPhysics);\n      op.triggerMap.forEach((value: boolean, key: number) => {\n        op.triggerMap.set(key, false);\n      });\n    }\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = (imposters[i].object as ObjectPhysics);\n      if (op.rb != null && op.rb.useGravity) {\n        //Gravity\n        imposters[i].applyForce(Physics.gravity.scale(imposters[i].mass), imposters[i].getObjectCenter());\n\n        for (var j = 0; j < imposters.length; j++) {\n          var op2 = (imposters[j].object as ObjectPhysics);\n          if (op.coll && op2.coll && op.coll.boundsMesh.uniqueId != op2.coll.boundsMesh.uniqueId) {\n            if (op.coll.isTrigger || op2.coll.isTrigger) {\n              if (this.Intersects(op, op2)) {\n                //Avoid double triggering of two rigidbodies\n                if (!op2.triggerMap.get(op.coll.boundsMesh.uniqueId)) {\n                  //If was already triggering...\n                  if (op.triggerMap.has(op2.coll.boundsMesh.uniqueId)) {\n                    try {\n                      op.coll.gameObject.OnTriggerStay(op2.coll);\n                    } catch (e) { Debug.Log(e); }\n                    try {\n                      op2.coll.gameObject.OnTriggerStay(op.coll);\n                    } catch (e) { Debug.Log(e); }\n                  } else {\n                    try {\n                      op.coll.gameObject.OnTriggerEnter(op2.coll);\n                    } catch (e) { Debug.Log(e); }\n                    try {\n                      op2.coll.gameObject.OnTriggerEnter(op.coll);\n                    } catch (e) { Debug.Log(e); }\n                  }\n                  op.triggerMap.set(op2.coll.boundsMesh.uniqueId, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = (imposters[i].object as ObjectPhysics);\n      op.triggerMap.forEach((value: boolean, key: number) => {\n        //If it was not set to true, it means it did not trigger this frame\n        if (!value) {\n\n          if (ObjectPhysics.colliderMap.has(key)) {\n            var otherCollider = ObjectPhysics.colliderMap.get(key);\n            //otherCollider is null when the PhysicsImpostor is not set up yet\n            if (otherCollider) {\n              try {\n                op.coll.gameObject.OnTriggerExit(otherCollider);\n              } catch (e) { Debug.Log(e); }\n              try {\n              otherCollider.gameObject.OnTriggerExit(op.coll);\n              } catch (e) { Debug.Log(e); }\n              op.triggerMap.delete(key);\n            }\n          }\n        }\n      });\n    }\n  }\n\n  private static Intersects(op: ObjectPhysics, op2: ObjectPhysics): boolean {\n\n    var box: number = BABYLON.PhysicsImpostor.BoxImpostor;\n    var sphere: number = BABYLON.PhysicsImpostor.SphereImpostor;\n\n    if (op.coll.GetImpostor() == box && op2.coll.GetImpostor() == box) {\n      return (op.mesh.intersectsMesh(op2.mesh, true));\n    }\n\n    if (op.coll.GetImpostor() == box && op2.coll.GetImpostor() == sphere) {\n      return this.BoxSphereIntersects(op, op2);\n    }\n\n    if (op.coll.GetImpostor() == sphere && op2.coll.GetImpostor() == box) {\n      return this.BoxSphereIntersects(op2, op);\n    }\n\n    if (op.coll.GetImpostor() == sphere && op2.coll.GetImpostor() == sphere) {\n      return this.SphereToSphere(op2.mesh.position, this.GetSphereRadius(op2.mesh), op.mesh.position, this.GetSphereRadius(op.mesh));\n    }\n\n    return false;\n  }\n\n  private static BoxSphereIntersects(op: ObjectPhysics, op2: ObjectPhysics): boolean {\n    //We get the maxScale of the sphere, since we only allow the sphere to be perfectly round\n    var radius = this.GetSphereRadius(op2.mesh);\n\n    return this.SphereToAABB(op2.mesh.position, radius, op.mesh);\n  }\n\n  private static SphereToAABB(position: BABYLON.Vector3, radius: number, box: BABYLON.AbstractMesh): boolean {\n    //Make the position relative to the box\n    var p = position.subtract(box.position);\n\n    //Rotate the resulting Vector by the inverted box rotation (to make the comparison axis aligned)\n    p.rotateByQuaternionToRef(BABYLON.Quaternion.Inverse(box.rotationQuaternion), p);\n\n    var s = box.scaling;\n\n    //Getting the closest point is easy since it's axis aligned\n    var closesPoint = new BABYLON.Vector3(\n      Mathf.Clamp(p.x, -s.x * 0.5, s.x * 0.5),\n      Mathf.Clamp(p.y, -s.y * 0.5, s.y * 0.5),\n      Mathf.Clamp(p.z, -s.z * 0.5, s.z * 0.5));\n\n\n    var dSqrd = BABYLON.Vector3.DistanceSquared(p, closesPoint);\n\n    return radius * radius > dSqrd;\n  }\n\n  private static SphereToSphere(p1: BABYLON.Vector3, r1: number, p2: BABYLON.Vector3, r2: number): boolean {\n    return BABYLON.Vector3.DistanceSquared(p1, p2) < (r1 + r2) * (r1 + r2);\n  }\n\n  public static OverlapSphere(position: Vector3, radius: number): Collider[] {\n    var imposters = Engine.scene._physicsEngine.getImpostors();\n\n    var colliders: Collider[] = new Array();\n\n    var box: number = BABYLON.PhysicsImpostor.BoxImpostor;\n    var sphere: number = BABYLON.PhysicsImpostor.SphereImpostor;\n\n    for (var j = 0; j < imposters.length; j++) {\n      var op = (imposters[j].object as ObjectPhysics);\n      if (op.coll != null) {\n        if (op.coll.GetImpostor() == box) {\n          if (this.SphereToAABB(Vector3.VtoB(position, new BABYLON.Vector3()), radius, op.mesh)) {\n            colliders.push(op.coll);\n          }\n        } else if (op.coll.GetImpostor() == sphere) {\n          if (this.SphereToSphere(Vector3.VtoB(position, new BABYLON.Vector3()), radius, op.mesh.position, this.GetSphereRadius(op.mesh))) {\n            colliders.push(op.coll);\n          }\n        }\n      }\n    }\n\n    return colliders;\n  }\n\n  private static GetSphereRadius(mesh: BABYLON.AbstractMesh) {\n    return Math.max(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z) * 0.5;\n  }\n\n\n\n\n}",
            "ObjectPhysics": "\n//ObjectPhysics handling the connection of Colliders & Rigidbodies.\n//Because Babylon combines all of that in a PhysicsImpostor, both colliders and rigidbodies affect the same ObjectPhysics\nclass ObjectPhysics implements BABYLON.IPhysicsEnabledObject {\n\n  public static colliderMap: Map<number, Collider> = new Map();\n  public triggerMap: Map<number, boolean> = new Map();\n\n  public get isKinematic(): boolean {\n    return this._isKinematic;\n  }\n\n  public set isKinematic(value: boolean) {\n    this._isKinematic = value;\n  }\n\n  private _isKinematic: boolean;\n\n  private go: GameObject;\n  public physicsImpostor: BABYLON.PhysicsImpostor;\n\n  private refresh: boolean = false;\n\n  public get rb(): Rigidbody {\n    if (this._rb == null || this._rb.markedForDestroy) {\n      this._rb = this.go.GetComponent(Rigidbody);\n    }\n    return this._rb;\n  }\n\n  private _rb: Rigidbody;\n\n  public get coll(): Collider {\n    if (this._coll == null || this._coll.markedForDestroy) {\n      this._coll = this.go.GetComponent(Collider);\n    }\n    return this._coll;\n  }\n\n  private _coll: Collider;\n\n  private collidingImpostors: BABYLON.PhysicsImpostor[];\n\n  Init(go: GameObject) {\n    this.go = go;\n    //The () => is essential to allow for UpdatePhysicsImpostor to reference it's class variables\n    //this.go.transform.transformNode.onChangedMesh.add(() => {      \n\n    //});\n\n    Engine.scene.onBeforePhysicsObservable.add(() => {\n\n    });\n\n    Engine.scene.onAfterPhysicsObservable.add(() => {\n      if (this.refresh) {\n        this.refresh = false;\n        this.UpdatePhysicsImpostor();\n      }\n    });\n  }\n\n  public MarkForUpdate() {\n    this.refresh = true;\n  }\n\n  TryDisposePhysicsImpostor() {\n    //We have to remove the old physicsImposter\n    if (this.physicsImpostor != null) {\n      if (this.coll) {\n        ObjectPhysics.colliderMap.delete(this.coll.boundsMesh.uniqueId);\n      }\n      this.physicsImpostor.dispose();\n      this.physicsImpostor = null;\n    }\n  }\n\n  UpdatePhysicsImpostor() {\n    this.TryDisposePhysicsImpostor();\n\n    //This is usually just when the GameObject is being Destroyed.\n    if (this.go.markedForDestroy || this.go.transform == null) {\n      return;\n    }\n\n    //Justs a Rigidbody collides with nothing\n    var imposterType = BABYLON.PhysicsImpostor.NoImpostor;\n    if (this.coll != null) {\n      imposterType = this.coll.GetImpostor();\n    }\n\n    var mass = this.rb ? this.rb.mass : 0;\n\n    this.physicsImpostor = new BABYLON.PhysicsImpostor(this,\n      imposterType,\n      //Set to mass here so setMass(0) actually updates\n      { mass: mass, restitution: 1},\n      Engine.scene);\n\n    //We have to call this setter once in order for friction to work...\n    this.physicsImpostor.friction = 0.5;\n\n\n    if (this.coll != null && this.rb != null) {\n      this.collidingImpostors = Engine.scene._physicsEngine.getImpostors();\n      this.physicsImpostor.registerOnPhysicsCollide(this.collidingImpostors, (main, collided) => {\n        this.InternalOnCollide(collided);\n      });\n    }\n\n\n    if (this.coll != null) {\n      this.coll.UpdateValuesToImpostor();\n      ObjectPhysics.colliderMap.set(this.coll.boundsMesh.uniqueId, this.coll);\n    }\n\n    if (this.rb != null) {\n      this.rb.UpdateValuesToImpostor();\n    }\n  }\n\n  InternalOnCollide(collided: BABYLON.PhysicsImpostor) {\n    var otherObjPhysics = (collided.object as ObjectPhysics);\n    var otherCollider: Collider = otherObjPhysics.coll;\n    if (!this.coll || !otherObjPhysics.coll)\n      return;\n\n    if (this.coll.isTrigger || otherCollider.isTrigger) {\n      //OnTriggerEvents are handled in the Physics class\n    }\n    else {\n      var c1 = new Collision();\n      c1.collider = otherCollider;\n      c1.gameObject = otherCollider.gameObject;\n      c1.transform = otherCollider.transform;\n      c1.rigidbody = otherCollider.GetComponent(Rigidbody);\n\n      var myVel = this.rb ? this.rb.velocity : new Vector3();\n      var theirVel = c1.rigidbody ? c1.rigidbody.velocity : new Vector3();\n      c1.relativeVelocity = new Vector3(myVel.x - theirVel.x, myVel.y - theirVel.y, myVel.z - theirVel.z);\n\n      var c2 = new Collision();\n      c2.collider = this.coll;\n      c2.gameObject = this.go;\n      c2.transform = this.go.transform;\n      c2.rigidbody = this.rb;\n      c2.relativeVelocity = new Vector3(-c1.relativeVelocity.x, -c1.relativeVelocity.y, -c1.relativeVelocity.z);\n      try {\n        this.go.OnCollisionEnter(c1);\n      } catch (e) {\n        Debug.Log(e);\n      }\n      try {\n        otherCollider.gameObject.OnCollisionEnter(c2);\n      } catch (e) {\n        Debug.Log(e);\n      }\n    }\n  }\n\n  OnDestroy() {\n    this.TryDisposePhysicsImpostor();\n  }\n\n  get mesh(): BABYLON.AbstractMesh {\n    return this.go.transform.transformNode;\n  }\n\n  get position(): BABYLON.Vector3 {\n    return this.mesh.position;\n  }\n\n  set position(value: BABYLON.Vector3) {\n    this.mesh.position = value;\n  }\n\n  get rotationQuaternion(): BABYLON.Quaternion {\n    return this.mesh.rotationQuaternion;\n  }\n\n  set rotationQuaternion(value: BABYLON.Quaternion) {\n    this.mesh.rotationQuaternion = value;\n  }\n\n  get scaling(): BABYLON.Vector3 {\n    return this.mesh.scaling;\n  }\n\n  set scaling(value: BABYLON.Vector3) {\n    this.mesh.scaling = value;\n  }\n\n  getBoundingInfo(): BABYLON.BoundingInfo {\n    return this.mesh.getBoundingInfo();\n  }\n\n  computeWorldMatrix(force?: boolean): BABYLON.Matrix {\n    return this.mesh.computeWorldMatrix(force);\n  }\n\n  getVerticesData(kind: string): BABYLON.FloatArray {\n    return this.mesh.getVerticesData(kind);\n  }\n\n  getAbsolutePivotPoint(): BABYLON.Vector3 {\n    return this.mesh.getAbsolutePivotPoint();\n  }\n\n  getAbsolutePosition(): BABYLON.Vector3 {\n    return this.mesh.getAbsolutePosition();\n  }\n\n  rotate(axis: BABYLON.Vector3, amount: number, space?: BABYLON.Space): BABYLON.TransformNode {\n    return this.mesh.rotate(axis, amount, space);\n  }\n\n  translate(axis: BABYLON.Vector3, distance: number, space?: BABYLON.Space): BABYLON.TransformNode {\n    return this.mesh.translate(axis, distance, space);\n  }\n\n  setAbsolutePosition(absolutePosition: BABYLON.Vector3): BABYLON.TransformNode {\n    return this.mesh.setAbsolutePosition(absolutePosition);\n  }\n\n  getClassName(): string {\n    return this.mesh.getClassName();\n  }\n}\n\nclass Collision {\n  collider: Collider;\n  rigidbody: Rigidbody;\n  transform: Transform;\n  gameObject: GameObject;\n  relativeVelocity: Vector3;\n}",
            "Rigidbody": "@RegisterAsComponent\nclass Rigidbody extends Component {\n\n  private _vel: Vector3 = new Vector3();\n  private _angularVel : Vector3 = new Vector3();\n\n  private get objectPhysics(): ObjectPhysics {\n    return this.gameObject.objectPhysics;\n  }\n\n  //region mass\n  public get mass(): number {\n    return this._mass;\n  }\n\n  public set mass(value: number) {\n    //Setting the mass to 0 will break the physics\n    if (value === 0) {\n      value = 0.00001;\n    }\n\n    this._mass = value;\n    this.UpdateMass();\n  }\n\n  get velocity(): Vector3 {\n    if (this.objectPhysics.physicsImpostor)\n    {\n      Vector3.BtoV(this.objectPhysics.physicsImpostor.getLinearVelocity(), this._vel);\n    }\n    return this._vel;\n  }\n\n  set velocity(value: Vector3) {\n\n    this._vel = value;\n    this._vel.onChange.add(() => {\n      if (this.objectPhysics.physicsImpostor)\n      {\n        this.objectPhysics.physicsImpostor.setLinearVelocity(Vector3.VtoB(this._vel, new BABYLON.Vector3()));\n      }\n    });\n\n    this._vel.onChange.notifyObservers(null);\n  }\n\n  get angularVelocity(): Vector3 {\n    if (this.objectPhysics.physicsImpostor)\n    {\n      Vector3.BtoV(this.objectPhysics.physicsImpostor.getAngularVelocity(), this._angularVel);\n    }\n    return this._angularVel;\n  }\n\n  set angularVelocity(value: Vector3) {\n\n    this._angularVel = value;\n    this._angularVel.onChange.add(() => {\n      if (this.objectPhysics.physicsImpostor)\n      {\n        this.objectPhysics.physicsImpostor.setAngularVelocity(Vector3.VtoB(this._angularVel, new BABYLON.Vector3()));\n      }\n    });\n    this._angularVel.onChange.notifyObservers(null);\n  }\n\n  @SerializeField\n  private _mass: number = 10;\n  //endregion\n\n  //region restitution\n  \n  public get restitution(): number {\n    return this._restitution;\n  }\n\n  public set restitution(value: number) {\n    if (this.objectPhysics.physicsImpostor && this.objectPhysics.physicsImpostor.restitution != value) {\n      this.objectPhysics.physicsImpostor.restitution = value;\n    }\n    this._restitution = value;\n  }\n  \n  @SerializeField\n  private _restitution: number = 0.5;\n  \n  //endregion\n\n  //region friction\n  public get friction(): number {\n    return this._friction;\n  }\n\n  public set friction(value: number) {\n    //Multiply by 10 to have similar numbers as before.\n    if (this.objectPhysics.physicsImpostor != null) {\n      this.objectPhysics.physicsImpostor.friction = value * 10;\n    }\n    this._friction = value;\n  }\n\n  @SerializeField\n  private _friction: number = 0.5;\n  //endregion\n\n  //region isKinematic\n  public get isKinematic(): boolean {\n    return this._isKinematic;\n  }\n\n  public set isKinematic(value: boolean) {\n\n     //Only update when changed.\n    if (this._isKinematic != value)\n    {\n      this._isKinematic = value;\n      //We check for the impostor since the setter in objectPhysics needs it\n      if (this.objectPhysics.physicsImpostor) {\n        {\n          this.UpdateMass();\n          if (value) {\n            //Reset velocity.\n            this.objectPhysics.MarkForUpdate();\n          }\n        }\n      }\n    }\n\n  }\n\n  @SerializeField\n  private _isKinematic: boolean = false;\n  private _wasKinematic: boolean = false;\n  //endregion\n\n  UpdateMass() {\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.mass = this.isKinematic ? 0 : this._mass;\n    }\n  }\n\n  //Works! Cannon.js had to be modified to not calculate friction based on gravity\n  useGravity: boolean = true;\n\n\n  Awake() {\n    this.objectPhysics.MarkForUpdate();\n  }\n\n  Update() {\n    if (this._isKinematic != this._wasKinematic) {\n      this.isKinematic = this._isKinematic;\n      this._wasKinematic = this._isKinematic;\n    }\n    this.restitution = this.restitution;\n    this.friction = this.friction;\n  }\n\n  OnDestroy() {\n\n    this.objectPhysics.MarkForUpdate();\n\n  }\n\n  //When the mesh changes, we need to recreate the Impostor\n  //With a Rigidbody, we only need to change some values.\n  UpdateValuesToImpostor() {\n    //force setters\n    this.mass = this.mass;\n    this.restitution = this.restitution;\n\n    this.friction = this.friction;\n    this.isKinematic = this.isKinematic;\n  }\n}\n",
            "Transform": "@ExecuteInEditMode\nclass Transform extends Component {    \n\n    //This is a mesh because the Gizmo system does not like TransformNodes\n    transformNode : BABYLON.AbstractMesh;\n\n    @SerializeField\n    private _position : Vector3;\n     \n    @SerializeField\n    private _eulerAngles : Vector3;\n    \n    @SerializeField\n    private _scale : Vector3;\n\n    private _absolutePosition : Vector3 = new Vector3();\n    private _absoluteScale : Vector3= new Vector3();\n    private _absoluteRotation : Quaternion= new Quaternion();\n    private _absoluteEulerAngles : Vector3 = new Vector3();\n    private _absoluteRadians : Vector3 = new Vector3();\n\n    @SerializeField\n    uniqueId : number = -1;\n\n    //ALL rotation is handled through the _rotation Quaternion\n    //E.g. if Radians are changed, Radians > EulerAngles > Quaternion > Mesh\n    //It has to be like that since Rigidbodies in Babylon set the Quaternion rotation\n    //After the Quaternion has been set, this is the only way to rotate objects in Babylon\n    private _radians : Vector3;\n    private _rotation : Quaternion;\n\n    private _children : GameObject[] = new Array();\n\n    Awake ()\n    {\n        this.transformNode = (new BABYLON.Mesh(this.gameObject.name, Engine.scene));\n        \n        Engine.meshToObject[this.transformNode.uniqueId] = this.gameObject;\n        this.transformNode.rotationQuaternion = new BABYLON.Quaternion();\n        this.localPosition = this._position ? this._position.clone() : Vector3.Zero(); \n        this.localScale = this._scale ? this._scale.clone() : Vector3.One();\n        var rot = this._eulerAngles ? this._eulerAngles.clone() : Vector3.Zero();\n        \n        this.localRotation = new Quaternion(0,0,0,0); \n        this.localEulerAngles = rot;\n    }\n\n    Start ()\n    {\n        //When saving the scene, all uniqueId's are stored.\n        //When restoring a scene, the uniqueId comes back\n        if (SceneManager.isReloading)\n        {            \n            this.transformNode.uniqueId = this.uniqueId;\n        } else {\n            this.uniqueId = this.transformNode.uniqueId;\n        }\n    }\n\n    \n    Update ()\n    {\n        //This seems redundant but it's calling the setter for all these variables\n        //Because our inspector and serializer use the private variables, this needs to be done\n        //This could be optimized (only selected + when serialized as scene) but is a minor performance overhead.\n        this.transform.localPosition;\n        this.transform.localEulerAngles;\n        this.transform.localScale;\n    }\n\n\n    get parent() : Transform\n    {\n        return this._parent;\n    }\n\n    //ONLY for serialization...\n    //getter only, since these will be set when Transforms are added automatically\n    @SerializeField\n    @HideInInspector\n    public get ser_children () : GameObject[] \n    {\n        return this._ser_children;\n    }\n\n    public set ser_children(value : GameObject[])\n    {\n       //this._ser_children = new Array();\n    }\n\n    public GetAllChildrenRecursively () : GameObject []\n    {\n        var arr = new Array();\n        this.AddChildren(arr, this.ser_children);\n        return arr;\n    }\n\n    private AddChildren (arr : GameObject[], children : GameObject[])\n    {\n        children.forEach(t => {\n            arr.push(t);\n            this.AddChildren(arr, t.transform.ser_children);\n        });\n    }\n\n    private _ser_children : GameObject[] = new Array();\n\n    GetSiblingIndex() : number\n    {\n        var c = this.parent ? this.parent.ser_children : SceneManager.GetActiveScene().rootObjs;\n\n        return c.indexOf(this.gameObject);\n    }\n\n    SetSiblingIndex(index : number)\n    {\n        var c = this.parent ? this.parent.ser_children : SceneManager.GetActiveScene().rootObjs;\n        index = Mathf.Clamp(index, 0, c.length);\n\n        const oldIndex = c.indexOf(this.gameObject);\n        //Remove from old position\n        c.splice(oldIndex, 1);\n        \n        //Add to new position\n        c.splice(index-1, 0, this.gameObject );\n            \n        \n    }\n\n    public SetParent(parent : Transform, worldPositionStays : boolean = true)\n    {\n        if (this.transform == parent)\n        {\n            Debug.Log(\"Can't set \" + this.name + \" to it's own parent.\");\n            return;\n        }\n        //We remove the object from the previous childrern list.\n        if (this._parent)\n        {\n            var x = this._parent.ser_children.indexOf(this.gameObject);\n            this._parent.ser_children.splice(x, 1);\n        } else {\n            var x = SceneManager.GetActiveScene().rootObjs.indexOf(this.gameObject);\n            SceneManager.GetActiveScene().rootObjs.splice(x, 1);\n        }\n        this._parent = parent;\n\n        if (!this._parent)\n        {\n            SceneManager.GetActiveScene().rootObjs.push(this.gameObject);\n        }\n\n        if (parent?.transformNode.nonUniformScaling)\n        {\n            Debug.Log(`Parented ${this.name} to non-uniformly scaled ${parent.name}. This is allowed but not recommended as it can lead to strange distortions.`);\n        }\n\n        if (worldPositionStays)\n        {\n            this.transformNode.setParent(parent?.transformNode);\n        } else {\n            this.transformNode.parent = parent?.transformNode;\n        }\n\n        //This array is auto populated when serializing.\n        if (!Serializer.isSettingParent)\n        {\n           parent?.ser_children.push(this.gameObject);\n        }\n    }\n\n    private _parent : Transform;\n\n\n/*\nPosition, rotation and scale are all stored in the mesh. The Transform component\nis nothing but a wrapper for the user. It will allow the user to easily update\nthe information and set rotation through eulerAngles or radians.\n*/\n\n/*\nThe event listener system for position, scale and rotation is designed\nto pick up on changes on the x,y,z components of these Vectors. Through that,\nusers can change one axis of a Vector, which now automatically updates the information\nin the game.\n*/\n\n// #region position\n    get position () : Vector3\n    {\n        Vector3.BtoV(this.transformNode.absolutePosition, this._absolutePosition);  \n        return this._absolutePosition;\n    }\n\n    set position (value : Vector3)\n    {\n        this._absolutePosition = value;\n\n        this._absolutePosition.onChange.clear();\n\n        this._absolutePosition.onChange.add(() => \n        {\n            this.transformNode.setAbsolutePosition(Vector3.VtoB(this._absolutePosition, new BABYLON.Vector3()));\n        });\n        this._absolutePosition.onChange.notifyObservers(null);    \n    }\n\n    get localPosition(): Vector3 {    \n        Vector3.BtoV(this.transformNode.position, this._position);  \n        return this._position;\n    }\n\n    set localPosition(value: Vector3) {\n        \n        this._position = value;\n\n        this._position.onChange.clear();\n\n        this._position.onChange.add(() => \n        {\n            Vector3.VtoB(this._position, this.transformNode.position);\n        });\n        this._position.onChange.notifyObservers(null);    \n    }\n\n// #endregion    \n\n\n//#region scale\n    get lossyScale() :Vector3\n    {\n        Vector3.BtoV(this.transformNode.absoluteScaling, this._absoluteScale);\n        return this._absoluteScale;        \n    }\n\n    get localScale(): Vector3 {\n\n        Vector3.BtoV(this.transformNode.scaling, this._scale);\n        return this._scale;\n    }\n\n    set localScale(value: Vector3) {\n        this._scale = value;\n\n        this._scale.onChange.clear();\n\n\n        this._scale.onChange.add(() => \n        {\n            Vector3.VtoB(this._scale, this.transformNode.scaling);\n        });\n        this._scale.onChange.notifyObservers(null);\n    }\n\n//#endregion\n\n\n//#region rotation\n\n    get rotation () : Quaternion\n    {\n        return Quaternion.BtoQ(this.transformNode.absoluteRotationQuaternion, this._absoluteRotation);\n    }\n\n    get eulerAngles () : Vector3\n    {\n        return Quaternion.ToEulerAngles(this.rotation, this._absoluteEulerAngles);\n    }\n\n    get radians () : Vector3\n    {\n        //get the eulerAngles\n        this.eulerAngles;\n        this._radians.x = this._absoluteEulerAngles.x * Mathf.Rad2Deg;\n        this._radians.y = this._absoluteEulerAngles.y * Mathf.Rad2Deg;\n        this._radians.z = this._absoluteEulerAngles.z * Mathf.Rad2Deg;\n        return this._radians;\n    }\n    \n    get localEulerAngles(): Vector3 {\n        Quaternion.ToEulerAngles(this.localRotation, this._eulerAngles);     \n    \n        return this._eulerAngles;\n    }\n\n    set localEulerAngles(value: Vector3) {\n        \n        this._eulerAngles = value;\n\n        this._eulerAngles.onChange.clear();\n\n        this._eulerAngles.onChange.add((index : number) => \n        {  \n            //The x eulerAngle needs to be looked at!\n            this.localRotation = Quaternion.Euler(this._eulerAngles.x, this._eulerAngles.y, this._eulerAngles.z, this._rotation);\n        });\n        \n        this._eulerAngles.onChange.notifyObservers(null);\n    }\n   \n\n    //Radians are untested.\n    get localRadians () : Vector3\n    {\n        this._radians.x = this.localEulerAngles.x * Mathf.Rad2Deg;\n        this._radians.y = this.localEulerAngles.y * Mathf.Rad2Deg;\n        this._radians.z = this.localEulerAngles.z * Mathf.Rad2Deg;\n\n        return this._radians;\n    }\n\n    set localRadians(value : Vector3)\n    {\n        this._radians = value;\n\n        this._radians.onChange.clear();\n\n        this._radians.onChange.add((index : number) => \n        {   \n            switch (index)\n            {                \n                case 0:                \n                    this.localEulerAngles.x = this._radians.x * Mathf.Rad2Deg;\n                    break;\n                case 1:\n                    this.localEulerAngles.y = this._radians.y * Mathf.Rad2Deg;\n                    break;\n                case 2:\n                    this.localEulerAngles.z = this._radians.z * Mathf.Rad2Deg;\n                    break;\n                default:\n                    this.localEulerAngles.x = this._radians.x * Mathf.Rad2Deg;\n                    this.localEulerAngles.y = this._radians.y * Mathf.Rad2Deg;\n                    this.localEulerAngles.z = this._radians.z * Mathf.Rad2Deg;\n                    break;\n            }\n        });\n        this._radians.onChange.notifyObservers(null); \n    }\n     \n    get localRotation () : Quaternion\n    {\n        return Quaternion.BtoQ(this.transformNode.rotationQuaternion, this._rotation);\n    }\n\n    set localRotation(value : Quaternion)\n    {\n        this._rotation = value;\n\n        this._rotation.onChange.clear();\n\n        this._rotation.onChange.add(() => \n        {   \n            Quaternion.QtoB(this._rotation, this.transformNode.rotationQuaternion);\n        });\n        this._rotation.onChange.notifyObservers(null); \n    }    \n\n//#endregion\n\n    public Rotate(xAxis: number, yAxis : number, zAxis:number, space?: BABYLON.Space): BABYLON.TransformNode {\n        this.transformNode.rotate(new BABYLON.Vector3(1,0,0), xAxis * Mathf.Deg2Rad, space);\n        this.transformNode.rotate(new BABYLON.Vector3(0,1,0), yAxis* Mathf.Deg2Rad, space);\n        return this.transformNode.rotate(new BABYLON.Vector3(0,0,1), zAxis* Mathf.Deg2Rad, space);\n    }\n\n    public Translate (x : number, y : number, z : number, space?: BABYLON.Space)\n    {\n        this.transformNode.translate(new BABYLON.Vector3(1,0,0), x, space);\n        this.transformNode.translate(new BABYLON.Vector3(0,1,0), y, space);\n        this.transformNode.translate(new BABYLON.Vector3(0,0,1), z, space);\n    }\n\n    private DisposeCurrentTransformNode()\n    {\n        Engine.meshToObject.delete(this.transformNode.uniqueId);\n        this.transformNode.dispose();\n    }\n\n    OnDestroy()\n    {\n        this.SetParent(null);\n        this.DisposeCurrentTransformNode();\n    }   \n}",
            "Collider": "class Collider extends Component {\n  //Only used for it's uniqueId\n  public boundsMesh: BABYLON.TransformNode;\n\n  protected bounds: BABYLON.BoundingInfo;\n  protected boundingBoxLines : BABYLON.LinesMesh;\n\n\n  protected get objectPhysics(): ObjectPhysics {\n    return this.gameObject.objectPhysics;\n  }\n\n  //Overridden by Specific Colliders (e.g. BoxCollider)\n  public GetImpostor(): number {\n    return -1;\n  }\n\n  public get isTrigger(): boolean {\n    return this._isTrigger;\n  }\n\n  public set isTrigger(value: boolean) {\n    this._isTrigger = value;\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionResponse = this.isTrigger ? 0 : 1;\n    }\n  }\n\n  @SerializeField\n  _isTrigger = false;\n\n  wasTrigger = false;\n\n  public get layer(): number {\n    return this._layer;\n  }\n\n  public set layer(value: number) {\n    this._layer = value;\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionFilterGroup = value;\n    }\n  }\n\n  @SerializeField\n  _layer: number = 1;\n\n  public get layerMask(): number {\n    return this._layerMask;\n  }\n\n  public set layerMask(value: number) {\n    this._layerMask = value;\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionFilterMask = value;\n    }\n  }\n\n  @SerializeField\n  _layerMask: number = 1;\n\n\n  Awake() {\n    this.boundsMesh = new BABYLON.TransformNode(\"BoundsMesh\", Engine.scene);\n\n    var min = new BABYLON.Vector3(-0.5, -0.5, -0.5);\n    var max = new BABYLON.Vector3(0.5, 0.5, 0.5);\n    this.bounds = new BABYLON.BoundingInfo(min, max);\n    //We make it a child to it scales along with transform\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n\n      //Scaling is not supported by PhysicsImpostors. Every time the scale changes we should update it\n      this.transform.localScale.onChange.add((i: number) => {\n        this.objectPhysics.UpdatePhysicsImpostor();\n      });\n    }\n  }\n\n  Update() {\n    if (Engine.isPlaying) {\n      //Pretty hacky solution to allow for Inspector Updates.\n      if (this._isTrigger != this.wasTrigger) {\n        this.isTrigger = this._isTrigger;\n        this.wasTrigger = this._isTrigger;\n      }\n      this.layer = this.layer;\n      this.layerMask = this.layerMask;\n    }\n    if (this.boundingBoxLines)\n      this.boundingBoxLines.setEnabled(EditorSelection.IsSelected(this.gameObject, true)) ;\n  }\n\n  OnDestroy() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n\n    this.boundsMesh?.dispose();\n    this.boundingBoxLines?.dispose();\n  }\n\n  //When the mesh changes, we need to recreate the Impostor\n  //With a Rigidbody, we only need to change some values.\n  UpdateValuesToImpostor() {\n    this.objectPhysics.physicsImpostor.type = this.GetImpostor();\n    this.isTrigger = this.isTrigger;\n  }\n\n}",
            "BoxCollider": "//script:BoxCollider\n@ExecuteInEditMode\n@RegisterAsComponent\nclass BoxCollider extends Collider\n{\n\n    @SerializeField\n    _size : Vector3 = new Vector3(1,1,1);\n\n    get size(): Vector3 {\n        return this._size;\n    }\n\n    set size(value: Vector3) {\n        this._size = value;\n        this._size.onChange.add(() => \n        {\n          this.ReconstructMeshLines ();\n        });\n        this._size.onChange.notifyObservers(null);\n    }\n\n    @SerializeField\n    _center : Vector3 = new Vector3(0,0,0);\n\n    get center(): Vector3 {\n        return this._center;\n    }\n\n    set center(value: Vector3) {\n        this._center = value;\n        this._center.onChange.add(() => \n        {\n          this.ReconstructMeshLines ();\n        });\n        this._center.onChange.notifyObservers(null);\n    }\n\n  ReconstructMeshLines ()\n  {\n    this.bounds.reConstruct(\n      new BABYLON.Vector3(this.center.x + this.size.x * -0.5,this.center.y + this.size.y * -0.5, this.center.z + this.size.z * -0.5), \n      new BABYLON.Vector3(this.center.x + this.size.x * 0.5,this.center.y + this.size.y * 0.5, this.center.z + this.size.z * 0.5));\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n    if (Engine.isPlaying)\n    {\n      this.objectPhysics.UpdatePhysicsImpostor();\n    }\n    //Drawing bounding boxes\n    var myPoints = [\n      this.bounds.minimum,\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      this.bounds.minimum,   \n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.minimum.z),   \n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.maximum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.maximum.y, this.bounds.minimum.z),\n      this.bounds.maximum,\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      this.bounds.maximum,\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.minimum.z)\n    ];\n\n    if (this.boundingBoxLines)\n      this.boundingBoxLines.dispose();\n\n    this.boundingBoxLines = BABYLON.MeshBuilder.CreateLines(\"lines\", {points: myPoints}, Engine.scene);\n    this.boundingBoxLines.setParent(this.transform.transformNode);\n    this.boundingBoxLines.color = BABYLON.Color3.Green();\n    this.boundingBoxLines.position = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.rotation = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.scaling = BABYLON.Vector3.One();\n    this.boundingBoxLines.setEnabled(false);\n  }\n\n  Awake ()\n  {\n    super.Awake();\n    this.size = this._size ? this._size.clone() : Vector3.One();\n    this.center = this._center ? this._center.clone() : Vector3.Zero();\n  }\n\n  public GetImpostor () : number \n  {\n    return BABYLON.PhysicsImpostor.BoxImpostor;\n  }\n\n  Update ()\n  {\n    super.Update();\n    //Simple setter for SerializeField\n    this.size;\n    this.center;\n  }\n\n}",
            "SphereCollider": "@ExecuteInEditMode\n@RegisterAsComponent\nclass SphereCollider extends Collider {\n\n  @SerializeField\n  radius: number = 1;\n  private prevRadius: number = 0;\n\n  //Increase to get more round gizmos\n  private gizmoPrecision = 150;\n\n  //This is a magical number to allow for the drawn gizmos to be the same as the radius in engine\n  private radiusMultiplier = 75;\n\n  public GetImpostor(): number {\n    return BABYLON.PhysicsImpostor.SphereImpostor;\n  }\n\n  Update() {\n    if (this.radius != this.prevRadius) {\n      this.prevRadius = this.radius;\n      this.ReconstructMeshLines();\n    }\n    super.Update();\n\n  }\n\n  ReconstructMeshLines() {\n    this.bounds.reConstruct(\n      new BABYLON.Vector3(-this.radius * 0.5,-this.radius * 0.5, -this.radius * 0.5), \n      new BABYLON.Vector3(this.radius * 0.5,this.radius * 0.5, this.radius * 0.5));\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n    if (Engine.isPlaying)\n    {\n      this.objectPhysics.UpdatePhysicsImpostor();\n    }\n\n    this.boundingBoxLines?.dispose();\n    this.boundingBoxLines = new BABYLON.LinesMesh(\"SphereBounds\", Engine.scene);\n    this.boundingBoxLines.parent = this.transform.transformNode;\n    this.boundingBoxLines.setEnabled(false);\n    \n    this.DrawCircle(0);\n    this.DrawCircle(1);\n    this.DrawCircle(2);\n  }\n\n  DrawCircle (axis : number)\n  {\n    var tess = this.gizmoPrecision;\n    \n    var radius = this.radius * this.radiusMultiplier;\n    var pi2 = Math.PI * 2;\n    var p = [];\n    for (var i = 0; i <= tess; i++) {\n        var ang = i * pi2 / tess;\n        var c1 = radius * Math.cos(ang) / tess;\n        var c2 = radius * Math.sin(ang) / tess;\n        var x = axis == 0 ? 0 : c1;\n        var y = axis == 1 ? 0 : c2;\n        var z = axis == 2 ? 0 : axis == 1 ? c2 : c1;\n        p.push(new BABYLON.Vector3(x,y,z));\n    }\n\n    \n    var circle = BABYLON.Mesh.CreateLines('circle', p, Engine.scene);\n    circle.parent = this.boundingBoxLines;\n    circle.color = new BABYLON.Color3(0, 1, 0);\n\n  }\n\n  \n\n\n}",
            "SceneManager": "//TODO rewrite this into a proper scene system\nclass SceneManager {\n\n    public static onSceneLoaded : BABYLON.Observable<Scene> = new BABYLON.Observable();\n\n    public static GetActiveScene(): Scene {\n        return this.activeScene;\n    }\n\n    private static activeScene: Scene;\n\n    static isReloading: boolean;\n\n    private static activeSceneName: string;\n\n    public static prefabLoaded : boolean;\n    \n\n    public static SaveCurrentScene() {\n        if (Engine.isPlaying) {\n            print(\"Can't save during playmode\");\n        } else {\n            this.activeScene.Save();            \n        }\n    }\n\n    static Init() {\n        PixelPADEvents.onSceneClicked.add(name => {\n            if (SceneManager.activeScene) {\n                SceneManager.activeScene.Unload();\n            }\n            SceneManager.LoadScene(name);\n        });\n\n        PixelPADEvents.onSaveClicked.add (ev => {\n            SceneManager.SaveCurrentScene();\n        });\n    }\n\n    static ReloadCurrentScene() {\n\n        if (this.activeScene != null) {\n            var newName = this.activeScene.name;\n            this.LoadScene(newName);\n        }\n        else {\n            Debug.Log(\"No scene is currently loaded\")\n        }\n    }\n\n    public static LoadPrefab (name : string)\n    {\n        this.prefabLoaded = true;\n        this.LoadSceneOrPrefab(name);\n    }\n\n    public static LoadScene(name: string) {\n        this.prefabLoaded = false;\n        this.LoadSceneOrPrefab(name);       \n    }\n\n    private static LoadSceneOrPrefab (name : string)\n    {\n        if (SceneManager.isReloading) {\n            return;\n        }\n\n        EditorSelection.SetSelectedGameObject(null);\n        if (this.activeScene != null) {\n            this.activeScene.Unload();\n        }\n        this.activeSceneName = name;\n        if (ENABLE_EDITOR)\n        {\n            UnionEditor.SetTitle((this.prefabLoaded? \"Prefab: \" : \"Scene: \") + name);\n        }\n        //Using this bool so Scenes are only reloaded at the very end of a frame\n        SceneManager.isReloading = true;\n    }\n\n    private static LoadSceneImmdiate(name: string) {\n        SceneManager.isReloading = true;\n        this.activeScene = new Scene();\n        this.activeScene.name = name;\n        \n        var sceneJSONData = \"\";\n        if (this.prefabLoaded)\n        {\n            sceneJSONData = getPrefab(name);\n        } else {\n            sceneJSONData = getScene(name);\n        }\n\n        //This loads all objects into the activeScene\n        var sceneData: Scene = Serializer.FromJSON(sceneJSONData, false);\n        /*\n        //If the sceneData is null, this is probably an empty scene/prefab\n        if (this.prefabLoaded && (!sceneData || sceneData.rootObjs.length == 0))\n        {\n            this.activeScene.rootObj = new GameObject();\n            this.activeScene.name = Prefab.SimpleName(name);\n        } else {\n            this.activeScene.rootObj = sceneData.rootObjs[0];\n        }        \n        */    \n        SceneManager.isReloading = false;\n        SceneManager.onSceneLoaded.notifyObservers(this.activeScene);\n    }\n\n    public static MarkSceneAsDirty() {\n        if (!Engine.isPlaying && !SceneManager.isReloading) {\n            markSceneDirty();\n        }\n    }\n\n    static Update() {\n        if (SceneManager.isReloading) {\n            this.LoadSceneImmdiate(this.activeSceneName);\n            \n        }\n    }\n}",
            "Scene": "//script:Scene\nclass Scene {\n  public name: string;\n\n  public objs: GameObject[];\n\n  //Null for scenes, the single root object for prefabs\n  public rootObj : GameObject;\n\n  //The objects that have no parent\n  @SerializeField\n  public rootObjs : GameObject[] = new Array();\n\n  //Any newly created GameObjects or Components\n  public newObjs : SceneObject[]\n\n  public constructor() {\n    this.objs = new Array();\n    this.newObjs = new Array();\n  }\n\n  public isDirty : boolean;\n\n  public Save ()\n  {\n    var jsonData = Serializer.ToJSON(this, true);\n    if (SceneManager.prefabLoaded)\n    {\n      savePrefab(this.name, jsonData);\n    } else {\n      saveScene(this.name, jsonData);  \n    }      \n    this.isDirty = false;    \n  }\n\n  public Unload(): void {\n    for (var i = this.objs.length - 1; i >= 0; i--) {\n      GameObject.Destroy(this.objs[i]);\n    }\n  }\n}",
            "Light": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Light extends MonoBehaviour\n{\n  light :  BABYLON.ShadowLight;\n\n  @SerializeField\n  public intensity : number = .7;\n\n // @SerializeField\n  public range : number = 5;\n\n  rot : BABYLON.Vector3;\n\n\n  Awake ()\n  {\n    this.light = new BABYLON.DirectionalLight(\"pointlight\", new BABYLON.Vector3(-1, -2, -1), Engine.scene);\n    Shadows.AddLight(this);\n    \n  }\n\n  Update ()\n  {\n    Vector3.VtoB(this.transform.position, this.light.position);\n    this.light.direction = this.transform.transformNode.forward.clone();\n    this.light.intensity = this.intensity;\n    this.light.range = this.range;\n  }\n\n  OnDestroy ()\n  {\n    Shadows.RemoveLight(this);\n    this.light.dispose();\n  }\n}\n",
            "MeshLoader": "//Helps loading and caches meshes\nclass MeshLoader\n{\n    static enableLogging : boolean = true;\n    static meshTaskMap : Map<string, BABYLON.MeshAssetTask>;\n\n    //TODO move into base class\n    static Log (msg)\n    {\n        if (MeshLoader.enableLogging)\n        {\n            print(msg)\n        }\n    }\n\n    static Init ()\n    {\n        MeshLoader.meshTaskMap = new Map();\n    }\n\n    //Adds a meshTask to the map and starts loading it\n    //NOTE: The loading happens asynchronously.\n    static LoadMesh(name : string, textureName : string = \"\")\n    {\n        //TODO Optimize: Do we need a new assetsManager every time?\n        var assetsManager = new BABYLON.AssetsManager(Engine.scene);\n        assetsManager.useDefaultLoadingScreen = false;        \n\n        var fileName = name;\n\n        fileName = Engine.getFullName(name, FileType.Model);\n        if (fileName == null)\n        {\n            print(\"Could not load mesh \" + name + \". Are you sure it exists?\");\n            return;\n        }\n        textureName = Engine.getFullName(textureName, FileType.Texture);\n        \n        var url = Engine.getUrl();\n\n        var meshTask = assetsManager.addMeshTask(\"Loading \" + name, \"\", url, fileName);\n        MeshLoader.meshTaskMap[name] = meshTask;\n\n        MeshLoader.Log(\"Loading mesh \" + url + name + \"...\");\n        \n        var mat = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n        if (textureName != null && textureName != \"\")\n        {\n            mat.diffuseTexture = new BABYLON.Texture(url + textureName, Engine.scene);\n        }\n        \n        assetsManager.onFinish = function (task) {\n            for (var i = 0; i < meshTask.loadedMeshes.length; i++)\n            {\n                meshTask.loadedMeshes[i].isVisible = false;\n                meshTask.loadedMeshes[i].material = mat;\n            }\n            MeshLoader.Log(\"Mesh \" + name + \" loaded successfully!\");\n        }\n        assetsManager.load();\n    }\n\n    //Tries and gets the mesh for the different objects\n    static GetMesh(name, textureName)\n    {        \n        //Bit hacky\n        if (name == \"box\" || name == \"sphere\")\n        {\n            var defaultMesh = [];\n            if (name == \"box\")\n            {\n                defaultMesh.push(BABYLON.Mesh.CreateBox(name, 1, Engine.scene));\n            } else\n            {\n                defaultMesh.push(BABYLON.Mesh.CreateSphere(name, 8, 1, Engine.scene));\n            }\n            return defaultMesh;\n        }\n\n\n        //meshTaskToMap has a list of all loading/loading meshes\n        //If it's not in there, it should be loaded at that time.\n        var meshTask : BABYLON.MeshAssetTask = MeshLoader.meshTaskMap[name];\n\n        if (meshTask == null)\n        {\n            this.LoadMesh(name, textureName);\n            return null;\n        }\n\n        if (!meshTask.isCompleted)\n        {\n            return null;\n        }\n\n        //If the mesh has been loaded, we return a copy of it.\n        //This ensures the mesh is only loaded once!\n        var meshes = [...MeshLoader.meshTaskMap[name].loadedMeshes];\n        for (var i = 0; i < meshes.length; i++)\n        {\n            meshes[i] = meshes[i].clone(\"Clone_\" + i, null);\n        }\n\n        return meshes;\n    }\n}\n",
            "TextureSystem": "class TextureSystem\n{\n    static spriteToManager : Map<string, BABYLON.SpriteManager>;\n\n    public static Init ()\n    {\n        TextureSystem.spriteToManager = new Map();\n    }\n\n    //TODO This should be cached\n    public static GetSprite(shortName : string) : BABYLON.Texture\n    {\n        /*\n        var manager : BABYLON.SpriteManager = SpriteSystem.spriteToManager[shortName];\n\n        if (manager == null)\n        {\n            var url : string = Engine.getUrl() + Engine.getFullName(shortName, FileType.Texture);\n            manager = new BABYLON.SpriteManager(\"spriteManager\", url, 1, 1, Engine.scene);\n            SpriteSystem.spriteToManager[shortName] = manager;\n        }\n        \n        var sprite = new BABYLON.Sprite(\"sprite\", manager);\n        \n        return sprite;\n        */\n        var url : string = Engine.getUrl() + Engine.getFullName(shortName, FileType.Texture);\n        var texture = new BABYLON.Texture(url, Engine.scene);\n        \n        return texture;\n    }\n}",
            "Input": "class Input {\n    private static codeToKeyState: Record<number, number>\n\n    private static nameToKeyState: Record<string, number>\n\n    private static indexToMouseButtonState : Record <number, number>\n\n    private static mouseDelta : BABYLON.Vector2 = new BABYLON.Vector2();\n    \n    private static keyAxisRaw : BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static keyAxis : BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static sensitivity : number = 0.1;\n\n    private static mouseSensitivity = 0.1;\n\n\n\n\n    static Init() {\n        //Stores all input keys\n        //0 = down, 1 = held, 2 = up, 3 = none\n        Input.codeToKeyState = {};\n        Input.nameToKeyState = {};\n        Input.indexToMouseButtonState = {}\n\n        Engine.scene.actionManager = new BABYLON.ActionManager(Engine.scene);\n\n        Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {\n            if (Input.codeToKeyState[evt.sourceEvent.keyCode] != 1) {\n                Input.codeToKeyState[evt.sourceEvent.keyCode] = 0;\n                Input.nameToKeyState[evt.sourceEvent.key] = 0;\n            }\n        }));\n\n        Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {\n            Input.codeToKeyState[evt.sourceEvent.keyCode] = 2;\n            Input.nameToKeyState[evt.sourceEvent.key] = 2;\n        }));\n\n\n        Engine.scene.onAfterRenderObservable.add((ev) => {\n            //We reset this every frame because pointermove does not call when not moving\n            this.mouseDelta.x = 0;\n            this.mouseDelta.y = 0;\n        });\n\n        Engine.scene.onPointerObservable.add((pointerInfo) => {\n        \n            switch (pointerInfo.type) {\n                case BABYLON.PointerEventTypes.POINTERMOVE:\n                    this.mouseDelta.x = pointerInfo.event.movementX * this.mouseSensitivity;\n                    this.mouseDelta.y = pointerInfo.event.movementY * this.mouseSensitivity;\n                break;\n\n                case BABYLON.PointerEventTypes.POINTERDOWN:\n                   if (Input.indexToMouseButtonState[pointerInfo.event.button] != 1) {\n                        Input.indexToMouseButtonState[pointerInfo.event.button] = 0 ;\n                    }\n                break;\n\n                case BABYLON.PointerEventTypes.POINTERUP:\n                    Input.indexToMouseButtonState[pointerInfo.event.button] = 2; \n                    \n                break;\n            }\n        });\n\n        \n    }\n\n    static Update() {\n\n        this.ProcessAxes();\n\n        for (let k in Input.codeToKeyState) {\n            if (Input.codeToKeyState[k] == 0 || Input.codeToKeyState[k] == 2) {\n                Input.codeToKeyState[k]++;\n            }\n        }\n\n        for (let k in Input.nameToKeyState) {\n            if (Input.nameToKeyState[k] == 0 || Input.nameToKeyState[k] == 2) {\n                Input.nameToKeyState[k]++;\n            }\n        }\n\n        for (let k in Input.indexToMouseButtonState) {\n            if (Input.indexToMouseButtonState[k] == 0 || Input.indexToMouseButtonState[k] == 2) {\n                Input.indexToMouseButtonState[k]++;\n            }\n        }\n    }\n\n    static ProcessAxes ()\n    {\n        if (this.GetKey(KeyCode.LeftArrow) || this.GetKey(KeyCode.A))\n        {\n            this.keyAxisRaw.x = -1;\n        } else if (this.GetKey(KeyCode.RightArrow) || this.GetKey(KeyCode.D))\n        {\n            this.keyAxisRaw.x = 1;\n        } else {\n            this.keyAxisRaw.x = 0;\n        }\n\n        if (this.GetKey(KeyCode.UpArrow) || this.GetKey(KeyCode.W))\n        {\n            this.keyAxis.y = 1;\n        }\n        if (this.GetKey(KeyCode.DownArrow) || this.GetKey(KeyCode.S))\n        {\n            this.keyAxis.y = -1;\n        }\n\n        this.keyAxis.x = Mathf.MoveTowards(this.keyAxis.x, this.keyAxisRaw.x, this.sensitivity);\n        this.keyAxis.y = Mathf.MoveTowards(this.keyAxis.y, this.keyAxisRaw.y, this.sensitivity);\n    }\n\n    static GetMouseButton (button : number) : boolean\n    {\n        return Input.indexToMouseButtonState[button] == 0 || Input.indexToMouseButtonState[button] == 1;;\n    }\n\n    static GetMouseButtonDown (button : number) : boolean\n    {\n        return Input.indexToMouseButtonState[button] == 0;\n    }\n\n    static GetMouseButtonUp (button : number) : boolean\n    {\n        return Input.indexToMouseButtonState[button] == 2;\n    }\n\n    static GetKey(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 0 || Input.nameToKeyState[key] == 1;\n        }\n        return Input.codeToKeyState[key] == 0 || Input.codeToKeyState[key] == 1;\n    }\n\n    static GetKeyDown(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 0;\n        }\n        return Input.codeToKeyState[key] == 0;\n    }\n\n    static GetKeyUp(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 2;\n        }\n        return Input.codeToKeyState[key] == 2;\n    }\n\n    static GetAxis(axisName: string) : number{\n        switch (axisName) {\n            case \"Mouse X\":\n                return this.mouseDelta.x;\n            case \"Mouse Y\":\n                return this.mouseDelta.y;\n            case \"Horizontal\":\n                return this.keyAxis.x;\n            case \"Vertical\":\n                return this.keyAxis.y;\n            default:\n                Debug.Log(`Axisname ${axisName} does not exist! Currently the only options are Mouse X, Mouse Y, Horizontal & Vertical`);\n            break;\n        }\n    }\n\n}\n\nenum KeyCode {\n    Break = 3,\n    Backspace = 8,\n    Tab = 9,\n    Clear = 12,\n    Enter = 13,\n    Shift = 16,\n    Control = 17,\n    Alt = 18,\n    Pause = 19,\n    CapsLock = 20,\n    Hangul = 21,\n    Hanja = 25,\n    Escape = 27,\n    Conversion = 28,\n    NonConversion = 29,\n    Space = 32,\n    PageUp = 33,\n    PageDown = 34,\n    End = 35,\n    Home = 36,\n    LeftArrow = 37,\n    UpArrow = 38,\n    RightArrow = 39,\n    DownArrow = 40,\n    Select = 41,\n    Print = 42,\n    Execute = 43,\n    PrintScreen = 44,\n    Insert = 45,\n    Delete = 46,\n    Help = 47,\n    Alpha0 = 48,\n    Alpha1 = 49,\n    Alpha2 = 50,\n    Alpha3 = 51,\n    Alpha4 = 52,\n    Alpha5 = 53,\n    Alpha6 = 54,\n    Alpah7 = 55,\n    Alpha8 = 56,\n    Alpha9 = 57,\n    Colon = 58,\n    Semicolon = 59,\n    LessThan = 60,\n    Equals = 61,\n    Beta = 63,\n    CommercialAt = 64,\n    A = 65,\n    B = 66,\n    C = 67,\n    D = 68,\n    E = 69,\n    F = 70,\n    G = 71,\n    H = 72,\n    I = 73,\n    J = 74,\n    K = 75,\n    L = 76,\n    M = 77,\n    N = 78,\n    O = 79,\n    P = 80,\n    Q = 81,\n    R = 82,\n    S = 83,\n    T = 84,\n    U = 85,\n    V = 86,\n    W = 87,\n    X = 88,\n    Y = 89,\n    Z = 90,\n    WindowsKey = 91,\n    LeftCommand = 91,\n    RightWindow = 92,\n    RightCommand = 93,\n    Sleep = 95,\n    Keypad0 = 96,\n    Keypad1 = 97,\n    Keypad2 = 98,\n    Keypad3 = 99,\n    Keypad4 = 100,\n    Keypad5 = 101,\n    Keypad6 = 102,\n    Keypad7 = 103,\n    Keypad8 = 104,\n    Keypad9 = 105,\n    KeypadMultiply = 106,\n    KeypadAdd = 107,\n    KeypadPeriod = 108,\n    KeypadSubtract = 109,\n    DecimalPoint = 110,\n    KeypadDivide = 111,\n    F1 = 112,\n    F2 = 113,\n    F3 = 114,\n    F4 = 115,\n    F5 = 116,\n    F6 = 117,\n    F7 = 118,\n    F8 = 119,\n    F9 = 120,\n    F10 = 121,\n    F11 = 122,\n    F12 = 123,\n    F13 = 124,\n    F14 = 125,\n    F15 = 126,\n    F16 = 127,\n    F17 = 128,\n    F18 = 129,\n    F19 = 130,\n    F20 = 131,\n    F21 = 132,\n    F22 = 133,\n    F23 = 134,\n    F24 = 135,\n    F25 = 136,\n    F26 = 137,\n    F27 = 138,\n    F28 = 139,\n    F29 = 140,\n    F30 = 141,\n    F31 = 142,\n    F32 = 143,\n    NumLock = 144,\n    ScrollLock = 145,\n    AirplaneMode = 151,\n    CircumFlex = 160,\n    ExclamationMark = 161,\n    ArabicSemicolon = 162,\n    Hash = 163,\n    DollarSign = 164,\n    PageBackward = 166,\n    PageForward = 167,\n    Refresh = 168,\n    Asterisk = 170,\n}",
            "Random": "/**\nThe Random class can give you random values\n */\nclass Random\n{\n    static get value ()\n    {\n        return Math.random();\n    }\n\n    static Range (min : number, max : number, wholeNumber : boolean = false)\n    {\n        var r : number = (Math.random() * (max-min)) + min;\n        if (wholeNumber)\n        {\n            return Math.floor(r);\n        }\n        return r;\n    }\n}",
            "BabylonExtensions": "//TODO Rework this class.\nclass Vector2 extends BABYLON.Vector2\n{\n    \n}\n\nclass Vector3 \n{\n    public onChange : BABYLON.Observable<number>;\n\n    constructor(x? : number, y? : number, z? : number) \n    {\n        this.onChange = new BABYLON.Observable();\n        this.x = x ? x : 0;\n        this.y = y ? y : 0;\n        this.z = z ? z : 0;\n    }\n\n    _x : number;\n    _y : number;    \n    _z : number;\n\n    @SerializeField\n    get x () : number\n    {\n        return this._x;\n    }\n\n    set x (value : number)\n    {\n        this._x = value\n        this.onChange.notifyObservers(0);\n    }\n\n    @SerializeField\n    get y () : number\n    {\n        return this._y;\n    }\n\n    set y (value : number)\n    {\n        this._y = value;\n        this.onChange.notifyObservers(1);\n    }\n    \n    @SerializeField\n    get z () : number\n    {\n        return this._z;\n    }\n    \n    set z (value : number)\n    {\n        this._z = value;\n        this.onChange.notifyObservers(2);\n    }\n\n    public add(v : Vector3)\n    {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n    }\n\n    public negate(v : Vector3)\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n    }\n\n    static One () : Vector3\n    {\n        return new Vector3(1.0, 1.0, 1.0);\n    }\n\n    static Zero() : Vector3\n    {\n        return new Vector3(0.0, 0.0, 0.0);\n    }\n\n    public static Lerp (a : Vector3, b : Vector3, l : number) : Vector3\n    {\n        var v : Vector3 = a.clone();\n        v.x = v.x + l * (b.x - v.x);\n        v.y = v.y + l * (b.y - v.y);\n        v.z = v.z + l * (b.z - v.z);\n        return v;\n    }\n\n    clone () : Vector3\n    {\n        return new Vector3(this.x, this.y, this.z);\n    }\n\n    public static VtoB (v: Vector3, b : BABYLON.Vector3) : BABYLON.Vector3\n    {\n        b.x = v._x;\n        b.y = v._y;\n        b.z = v._z;\n        return b;\n    }\n\n    public static BtoV  (b : BABYLON.Vector3, v : Vector3) : Vector3\n    {\n        v._x = b.x;\n        v._y = b.y;\n        v._z = b.z;\n        return v;\n    }\n\n    toString ()\n    {\n        return \"Vector3(\"+ this._x + \",\" + this._y + \",\" + this._z + \")\";\n    }\n\n    public get magnitude () : number\n    {\n        return Math.sqrt(this.sqrMagnitude);\n    }\n\n    public get sqrMagnitude () : number\n    {\n        return this.x*this.x + this.y * this.y + this.z*this.z;\n    }\n\n    public get normalized () : Vector3\n    {\n        var m = 1.0 / this.magnitude;\n        return new Vector3(this.x * m, this.y * m, this.z* m);\n    }\n}\n\nclass Quaternion \n{\n    public onChange : BABYLON.Observable<number>;\n\n    constructor(x? : number, y? : number, z? : number, w? : number) \n    {\n        this.onChange = new BABYLON.Observable();\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n\n    _x : number;\n    _y : number;\n    _z : number;\n    _w : number;\n\n    @SerializeField\n    get x () : number\n    {\n        return this._x;\n    }\n\n    set x (value : number)\n    {\n        this._x = value\n        this.onChange.notifyObservers(0);\n    }\n\n    @SerializeField\n    get y () : number\n    {\n        return this._y;\n    }\n\n    set y (value : number)\n    {\n        this._y = value;\n        this.onChange.notifyObservers(1);\n    }\n\n    @SerializeField\n    get z () : number\n    {\n        return this._z;\n    }\n    \n    set z (value : number)\n    {\n        this._z = value;\n        this.onChange.notifyObservers(2);\n    }\n\n    @SerializeField\n    get w () : number\n    {\n        return this._w;\n    }\n    \n    set w (value : number)\n    {\n        this._w = value;\n        this.onChange.notifyObservers(3);\n    }    \n\n    clone () : Quaternion\n    {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n\n    toString ()\n    {\n        return \"Quaternion(\"+ this._x + \",\" + this._y + \",\" + this._z + \",\" + this._w + \")\";\n    }\n\n    public static QtoB (v: Quaternion, b : BABYLON.Quaternion) : BABYLON.Quaternion\n    {\n        b.x = v._x;\n        b.y = v._y;\n        b.z = v._z;\n        b.w = v._w;\n        return b;\n    }\n\n    public static BtoQ  (b : BABYLON.Quaternion, v : Quaternion) : Quaternion\n    {\n        v._x = b.x;\n        v._y = b.y;\n        v._z = b.z;\n        v._w = b.w;\n        return v;\n    }\n\n    public static Inverse (q : Quaternion)\n    {\n        return new Quaternion(-q.x, -q.y, -q.z, -q.w);\n    }\n\n    //TODO Can we do this math without Babylon?\n    public static Euler (x : number, y : number, z : number, q? : Quaternion) : Quaternion\n    {\n        if (!q)\n        {\n            q = new Quaternion(0,0,0,0);\n        }\n\n        var newQuat = BABYLON.Quaternion.FromEulerAngles(x*Mathf.Deg2Rad,y*Mathf.Deg2Rad,z*Mathf.Deg2Rad);\n        return Quaternion.BtoQ(newQuat, q);\n    }\n\n    static ToEulerAngles(q : Quaternion, v : Vector3) : Vector3\n    {\n        var b = new BABYLON.Quaternion();\n        Quaternion.QtoB(q, b);\n\n        var bv : BABYLON.Vector3 = b.toEulerAngles();\n        bv.x *= Mathf.Rad2Deg;\n        bv.y *= Mathf.Rad2Deg;\n        bv.z *= Mathf.Rad2Deg;\n\n        return Vector3.BtoV(bv, v);\n    }\n}\n\n\n//The GameScene (hidden to user) creates all Game Related objects\nclass GameScene extends MonoBehaviour {\n\n    Start()\n    {\n        this.renderer.isVisible = false;\n    }\n\n    Update()\n    {\n\n    }\n}\n",
            "EditorHelpers": "class TestObject extends MonoBehaviour\n{    \n    public static main;\n\n    public rot : Vector3;\n\n    @SerializeField\n    public rotateSpeed : number = 50;\n        @SerializeField\n    moveSpeed : number = 0;\n\n    Start()\n    {      \n       // this.rot = new Vector3(Random.value, Random.value, Random.value);\n      //  this.transform.eulerAngles = new Vector3(30,0,0);\n    }\n\n    Update()\n    {\n       // this.transform.position.y += this.moveSpeed * Time.deltaTime;\n    }\n\n    OnTriggerEnter (c : Collider)\n    {\n        print(\"TRIGGER: \" + this.name + \" + \" + c.name);\n    }\n}\n\nclass FPSCounter extends MonoBehaviour\n{\n    nFrameUpdateInterval : number = 10;\n\n    text : TextLabel;\n    average : number = 0;\n    nFramesSinceUpdate : number = 0;\n\n    Start()\n    {\n        this.text = this.gameObject.AddComponent(TextLabel);\n        this.transform.position.x = 4;\n        this.transform.position.y = 4;\n    }\n\n    Update ()\n    {\n        this.nFramesSinceUpdate++;\n        this.average += Time.deltaTime;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval)\n        {\n            this.text.text = \"FPS: \" + (1 / (this.average/ this.nFrameUpdateInterval)).toFixed(0);\n            this.average = 0;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n\n    OnDestroy()\n    {\n        \n    }\n\n}\n\n\nclass ObjCounter extends MonoBehaviour\n{\n\n    nFrameUpdateInterval : number = 1;\n\n    text : TextLabel;\n    nFramesSinceUpdate : number = 0;\n\n    Start()\n    {\n        this.text = this.gameObject.AddComponent(TextLabel);\n        this.transform.position.x = 4;\n        this.transform.position.y = 4.5;\n    }\n\n    Update ()\n    {\n        this.nFramesSinceUpdate++;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval)\n        {\n            this.text.text = \"Objs \" + SceneManager.GetActiveScene().objs.length;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n\n}",
            "Canvas": "//script:GUITest\n\nclass Canvas extends MonoBehaviour\n{\n  //Singleton pattern\n  public static get instance (): Canvas\n  {\n    if (Canvas._instance == null || Canvas._instance == undefined)\n    {\n      Canvas._instance = Instantiate(Canvas);      \n    }\n    return Canvas._instance;\n  }\n\n  private static _instance: Canvas;  \n\n  public static get main (): BABYLON.GUI.AdvancedDynamicTexture\n  {\n    return Canvas.instance.main;\n  }\n\n  private main : BABYLON.GUI.AdvancedDynamicTexture;\n\n  Awake ()\n  {\n    this.main = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"Main\", true, Engine.scene);\n    this.main.layer.layerMask = 2;\n  }\n\n  Update ()\n  {\n\n  }\n\n  OnDestroy ()\n  {\n    this.main?.dispose();\n    Canvas._instance = null;\n  }\n}",
            "TextLabel": "class TextLabel extends MonoBehaviour\n{\n  //MUST HAVE A DEFAULT VALUE OR MIGHT CRASH!\n  public text : string = \"\";\n\n  private label : BABYLON.GUI.TextBlock;\n\n  Awake ()\n  {\n    this.label = new BABYLON.GUI.TextBlock();\n    this.label.color = \"white\";\n    this.label.fontSize = 30;\n    this.label.outlineColor = \"black\";\n    this.label.outlineWidth = 3;\n    this.label.shadowColor = \"black\";\n    this.label.shadowOffsetX = 2;\n    this.label.shadowOffsetY = 2;\n\n    Canvas.main.addControl(this.label);\n    this.label.linkWithMesh(this.renderer.GetMesh());\n  }\n\n  Update ()\n  {\n    this.label.text = this.text;\n    \n  }\n}",
            "ReflectionSystem": "//script:ReflectionSystem\n\nclass ReflectionSystem\n{\n  public static DefineParams (o : any)\n  {\n      //Looping through all keys (currently unused)\n      Object.keys(o).forEach((name : string, i : number, array : string[]) => {\n        \n      });\n      \n      //Get all variables in object \n      var names = Object.getOwnPropertyNames(o);      \n\n      //Loop through\n      names.forEach((name : string) => {\n        //Get Property based on name\n        var p : PropertyDescriptor = Object.getOwnPropertyDescriptor(o, name);                \n        \n        //Check typeof property\n        if (typeof p.value === \"number\")\n        {\n            //Set the value\n            p.value = 0.01;\n            //Apply change to actual object\n            Object.defineProperty(o, name, p);\n        }\n      });\n\n  }\n\n  \n}\n",
            "PlayerPrefs": "//script:Serializer\n\nclass PlayerPrefs\n{\n  public static Save (jsonData : string){\n    \n    Engine.current.getHostDocument().cookie = jsonData + \"|||\";\n  }\n\n  public static Load() : string\n  {\n    var cookie : string = Engine.current.getHostDocument().cookie;\n\n    if (cookie.startsWith(\"{\"))\n    {\n        cookie = cookie.split(\"|||\")[0];\n        return cookie;\n    }\n    return null;\n  }\n\n  public static Clear ()\n  {\n    this.Save(\"{}\");\n    \n  }\n}\n",
            "UnionEditor": "class UnionButton extends BABYLON.GUI.Button {\n\n  get textBlock () : BABYLON.GUI.TextBlock\n  {\n    return this._tb;\n  }\n\n  private _tb : BABYLON.GUI.TextBlock;\n\n  constructor(text: string, resizeToText : boolean = true) {\n    super(\"Button_\" + text);\n    this.width = \"100px\";\n    this.height = \"20px\";\n    this.color = UnionEditor.style.darkLineColor.toHexString();\n    this.background = UnionEditor.style.backgroundColor.toHexString();\n    \n    this.alpha = 1;\n    \n    this.isPointerBlocker = true;\n    // Adding text\n    this._tb = new BABYLON.GUI.TextBlock(name + \"_button\", text);\n    this._tb.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this._tb.paddingTop = \"20%\";\n    this._tb.fontSize = 12;\n    this._tb.resizeToFit = true;\n    \n    this._tb.color = UnionEditor.style.textColor.toHexString();\n    \n    this.addControl(this._tb);\n    \n    this.onBeforeDrawObservable.add(e => {\n      if (resizeToText)\n      {\n        this.widthInPixels = this._tb.widthInPixels + 20;\n      }\n    });\n\n    this.onPointerEnterObservable.add(e => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n    this.onPointerOutObservable.add(e => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n  } \n}\n\nclass UnionEditor {\n\n  public static style: EditorStyle;\n\n  public static editorUI: BABYLON.GUI.AdvancedDynamicTexture;\n\n  public static editorCam: EditorCam;\n\n  public static editorSystems: EditorSystem[];\n\n  public static fontStyle: BABYLON.GUI.Style;\n  public static fontStyleBold: BABYLON.GUI.Style;\n\n  private static uiCam: BABYLON.TargetCamera;\n\n  private static topBar: TopBarWindow;\n\n  public static CreateButton(name: string): BABYLON.GUI.Button {\n    var button = new UnionButton(name);\n    return button;\n  }\n\n  public static SetTitle(name: string) {\n    this.topBar.breadCrumbsText.textBlock.text = name;\n  }\n\n  public static Init() {\n    this.style = new EditorStyle();\n\n    this.editorSystems = new Array();\n\n    //Here to render the User Interface\n    this.uiCam = new BABYLON.TargetCamera(\"uiCam\", new BABYLON.Vector3(999999, 0, 999999), Engine.editorScene);\n    this.uiCam.viewport = new BABYLON.Viewport(0, 0, 1, 1);\n    this.uiCam.attachControl(Engine.canvas, true);\n\n    UnionEditor.editorCam = new EditorCam();\n\n    Engine.editorScene.activeCameras.push(this.uiCam);\n\n\n\n\n    new EditorSelection();\n    new EditorGizmos();\n\n    this.editorUI = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\", true, Engine.editorScene);\n    this.editorUI.layer.layerMask = 1;\n\n    this.fontStyle = new BABYLON.GUI.Style(this.editorUI);\n    this.fontStyle.fontSize = 12;\n\n    this.fontStyleBold = new BABYLON.GUI.Style(this.editorUI);\n    this.fontStyleBold.fontSize = 13;\n    this.fontStyleBold.fontWeight = \"bold\";\n\n    this.topBar = new TopBarWindow();\n    new HierarchyWindow();\n    new InspectorWindow();\n\n    Engine.scene.onKeyboardObservable.add((keybrd) => {\n\n      if (keybrd.type == BABYLON.KeyboardEventTypes.KEYDOWN && keybrd.event.key == \"d\") {\n        if (keybrd.event.ctrlKey) {\n          keybrd.event.preventDefault();\n\n          var sel = EditorSelection.GetSelection();\n\n          /*\n          //Prefabs only have a single root-object\n          if (SceneManager.prefabLoaded && !c.transform.parent)\n          {\n            Debug.Log(\"Can't duplicate the root-object of a prefab!\");\n            return;\n          }\n          */\n          EditorSelection.SetSelectedGameObject(null);\n          sel.forEach(c => {\n            var jsonData: string = Serializer.ToJSON(c);\n            //Create a clone from data read from the string.\n            var clone: GameObject = Serializer.FromJSON(jsonData) as GameObject;\n            clone.transform.SetParent(c.transform.parent, false);\n            EditorSelection.AddSelectedGameObject(clone);\n          });\n\n        }\n      }\n    });\n\n  }\n\n  public static Update() {\n\n    if (Input.GetKeyDown(KeyCode.Delete)) {\n      var sel = EditorSelection.GetSelection();\n      sel.forEach(c => {\n        Destroy(c);\n\n        EditorSelection.SetSelectedGameObject(null);\n      });\n    }\n\n\n    this.editorSystems.forEach((window: EditorWindow) => {\n      window.OnGUI();\n    });\n  }\n\n}\n\nclass EditorStyle {\n\n  //Unity grey\n  backgroundColor = new BABYLON.Color3(0.219607843, 0.219607843, 0.219607843);\n  lineColor = new BABYLON.Color4(0, 0, 0, 0);\n  darkLineColor = new BABYLON.Color3(0.1, 0.1, 0.1);\n  textColor = new BABYLON.Color3(0.8, 0.8, 0.8);\n  selectedTextColor = new BABYLON.Color3(1, 1, 1);\n  selectionColor = new BABYLON.Color3(0.17254902, 0.364705882, 0.529411765);\n  hoverColor = new BABYLON.Color3(0.270588235, 0.270588235, 0.270588235);\n}\n\n",
            "EditorWindow": "class EditorWindow extends EditorSystem\n{\n  private sv : BABYLON.GUI.ScrollViewer;\n\n  public main : BABYLON.GUI.StackPanel;\n\n  public background : BABYLON.GUI.Rectangle;\n\n  constructor()\n  {\n    super();    \n    this.Refresh();\n  }\n\n  OnGUI()\n  {\n\n  }\n\n  Refresh()\n  {\n    this.main?.dispose();\n    this.sv?.dispose();\n\n    if (this.background)\n    {\n      this.background.onPointerEnterObservable.clear();\n      this.background.onPointerOutObservable.clear();\n    }\n\n    this.background?.dispose();\n\n    this.main = new BABYLON.GUI.StackPanel();\n    \n    this.main.fontSize = 14;\n\n    this.main.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.main.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    \n    this.background = new BABYLON.GUI.Rectangle();\n    this.background.cornerRadius = 0;\n    this.background.background = UnionEditor.style.backgroundColor.toHexString();\n    this.background.color = UnionEditor.style.darkLineColor.toHexString();\n\n    this.background.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.background.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n      \n    this.sv = new BABYLON.GUI.ScrollViewer();\n    this.sv.color = UnionEditor.style.darkLineColor.toHexString();\n    this.background.addControl(this.sv);\n\n    this.sv.addControl(this.main);\n    this.sv.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.sv.barSize = 15;\n    \n    this.background.widthInPixels = 200;\n    this.background.heightInPixels = 350;\n\n    this.background.zIndex = -1;\n    \n    this.background.onPointerEnterObservable.add((evt) => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n\n    this.background.onPointerOutObservable.add((evt) => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n    \n    UnionEditor.editorUI.addControl(this.background);\n  }\n}",
            "MenuButton": "class MenuButton extends UnionButton {\n\n  data: MenuItemData;\n  owner: MenuButtonList;\n  list: MenuButtonList;\n\n  constructor(owner: MenuButtonList, data: MenuItemData) {\n    //Only the top menu resizes\n    super(data.name, owner.owner == null);\n    this.color = UnionEditor.style.backgroundColor.toHexString();\n    this.owner = owner;\n    this.data = data;\n    this.textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.isPointerBlocker = true;\n\n    //Remove the deeper menus when hovering\n    this.onPointerEnterObservable.add(e => {\n\n      owner.children.forEach(c => {\n        var b = c as MenuButton;\n        //We dispose any list since if it's this, a new one will get created\n        //if (b != this)\n        {\n          b.list?.dispose();\n        }\n      });\n\n      //If not top bar\n      if (this.GetTopOwner().isFocused) {\n        this.Expand();\n      }\n    });\n\n\n    this.onPointerClickObservable.add(e => {\n\n      if (!this.GetTopOwner().isFocused) {\n        this.GetTopOwner().isFocused = true;\n        this.Expand();\n      } else {\n        this.Collapse();\n      }\n\n      if (data.functionToCall) {\n        data.functionToCall();\n        //Clear all menus when clicking somewhere\n\n        this.Collapse();\n      }\n    });\n\n    this.onDisposeObservable.add(e => {\n      this.list?.dispose();\n    });\n  }\n\n  IsTopButton() {\n    return this.owner == this.GetTopOwner();\n  }\n\n  Collapse() {\n    var owner = this.GetTopOwner() as MenuButtonList;\n    owner.children.forEach(c => {\n      var b = c as MenuButton;\n      b.list?.dispose();\n    })\n    owner.isFocused = false;\n  }\n\n  Expand() {\n    if (this.data.children.length > 0) {\n      this.list = new MenuButtonList(this, this.data.children);\n      var pos = this.getLocalCoordinates(new BABYLON.Vector2()).negate();\n\n      UnionEditor.editorUI.addControl(this.list);\n      this.list.leftInPixels += pos.x;\n      this.list.topInPixels += pos.y;\n    }\n  }\n\n  GetTopOwner(): MenuButtonList {\n    return this.owner.GetTopOwner();\n  }\n}\n\n\n\n\n\n\n\n\nfunction MenuItem(value: string) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    {\n      if (!MenuItemData.main) {\n        MenuItemData.main = new MenuItemData();\n      }\n      MenuItemData.main.AddChild(value.split(\"/\"), descriptor.value);\n    }\n  }\n}\n\nclass MenuItemData {\n  static main: MenuItemData;\n\n  name: string;\n  functionToCall: any;\n  children: MenuItemData[] = new Array();\n\n  constructor() {\n\n  }\n\n  AddChild(items: string[], functionToCall: any) {\n    //Pop off the start of items\n    var name = items.shift();\n\n    var child = null;\n    //If the child already exists, we group them under the same MenuItemData\n    this.children.forEach(c => {\n      if (c.name == name) {\n        child = c;\n      }\n    });\n\n    //If it didn't exist yet in the menu, we add it here\n    if (!child) {\n      child = new MenuItemData();\n      this.children.push(child);\n      child.name = name;\n    }\n\n    //If there are more submenus...\n    if (items.length > 0) {\n      child.AddChild(items, functionToCall);\n    } else {\n      child.functionToCall = functionToCall;\n    }\n  }\n}",
            "MenuButtonList": "class MenuButtonList extends BABYLON.GUI.StackPanel {\n\n  owner : MenuButton;\n  isFocused : boolean;\n\n  constructor(owner : MenuButton, itemDataList: MenuItemData[], isVertical = true) {\n    super();\n    this.owner = owner;\n    this.isVertical = isVertical;\n    //The first line after the main top bar should be moved down\n    if (owner?.owner && !owner.owner.isVertical)\n    {\n      this.topInPixels += 20;\n    } else {\n      this.leftInPixels += 100;\n    }\n\n    if (isVertical) {\n      this.widthInPixels = 100;\n      \n    } else {\n      this.heightInPixels = 20;\n    }\n    this.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    itemDataList.forEach(itemData => {\n      var button = new MenuButton(this, itemData);\n      this.addControl(button);\n    });\n\n  }\n\n  GetTopOwner () : MenuButtonList {\n    if (!this.owner)\n      return this;\n    return this.owner.GetTopOwner();\n  }\n}\n",
            "TopBarWindow": "class TopBarWindow extends EditorWindow {\n\n  public static items: string[];\n\n  private topPanel: BABYLON.GUI.StackPanel;\n  private breadCrumbs: BABYLON.GUI.StackPanel;\n  public breadCrumbsText: BABYLON.GUI.Button;\n\n\n  @MenuItem(\"GameObject/Create Empty\")\n  static CreateEmpty() {\n    var go: GameObject = new GameObject();\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/Create Child\")\n  static CreateEmptyChild() {\n    var go: GameObject = new GameObject();\n    if (EditorSelection.HasSelection()) {\n      go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n\n  @MenuItem(\"GameObject/Create Parent\")\n  static CreateParent() {\n    var go: GameObject = new GameObject();\n    go.transform.position = EditorSelection.GetCenterPoint();\n    var first = true;\n    EditorSelection.GetSelection().forEach(sgo => {\n      if (first) {\n        first = false;\n        var i: number = sgo.transform.GetSiblingIndex();\n        go.transform.SetParent(sgo.transform.parent, true);\n        go.transform.SetSiblingIndex(i + 1);\n      }\n      sgo.transform.SetParent(go.transform, true);\n    });\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/3D Object/Cube\")\n  static CreateBox() {\n    var go: GameObject = new GameObject();\n    go.name = \"Box\";\n    go.AddComponent(Renderer).LoadMesh(\"box\");\n    go.AddComponent(BoxCollider);\n    go.AddComponent(Rigidbody);\n    if (EditorSelection.HasSelection()) {\n      go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/3D Object/Sphere\")\n  static Sphere() {\n    var go: GameObject = new GameObject();\n    go.name = \"Sphere\";\n    go.AddComponent(Renderer).LoadMesh(\"sphere\");\n    go.AddComponent(SphereCollider);\n    go.AddComponent(Rigidbody);\n    if (EditorSelection.HasSelection()) {\n      go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n\n\n  @MenuItem(\"GameObject/Light/Directional Light\")\n  static CreateLight() {\n    var go: GameObject = new GameObject();\n    go.name = \"Light\";\n    go.AddComponent(Light);\n    go.transform.position = new Vector3(0,50,0);\n    go.transform.localEulerAngles = new Vector3(45,-45,0);\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"File Viewer\")\n  static FileViewer ()\n  {\n    InspectorWindow.current.OnViewModel();\n  }\n\n  constructor() {\n    super()\n    this.background.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.background.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.background.widthInPixels = 600;\n    this.background.heightInPixels = 60;\n    this.background.background = UnionEditor.style.darkLineColor.toHexString();\n\n    this.breadCrumbs = new BABYLON.GUI.StackPanel();\n\n    this.breadCrumbs.isVertical = false;\n    this.breadCrumbs.height = \"20px\";\n\n    this.breadCrumbs.fontSize = \"14px\";\n    this.breadCrumbs.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.breadCrumbs.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n    this.breadCrumbsText = UnionEditor.CreateButton(\"Breadcrumbs\");\n    this.breadCrumbsText.horizontalAlignment= BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n        this.breadCrumbsText.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n    this.breadCrumbsText.color = UnionEditor.style.backgroundColor.toHexString();\n    this.breadCrumbsText.width = \"200px\";\n    this.breadCrumbs.addControl(this.breadCrumbsText);\n\n    this.background.addControl(this.breadCrumbs);\n    var buttonList = new MenuButtonList(null, MenuItemData.main.children, false);\n    this.breadCrumbs.addControl(buttonList);\n    //buttonList.paddingLeftInPixels += 100;\n\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n        buttonList.children.forEach(c => {\n          var b = c as MenuButton;\n          b.list?.dispose();\n        });\n        buttonList.isFocused = false;\n      }\n    });\n\n    this.topPanel = new BABYLON.GUI.StackPanel();\n\n    this.topPanel.isVertical = false;\n    this.topPanel.height = \"40px\";\n    \n    this.topPanel.fontSize = \"14px\";\n    this.topPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.topPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    this.background.addControl(this.topPanel);\n\n    var playButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"PlayButton\", \"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.play_button.png\");\n    playButton.width = \"25px\"; \n    playButton.height = \"25px\";\n    playButton.image.width = \"20px\";\n    playButton.image.height = \"20px\";\n    playButton.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    playButton.background =UnionEditor.style.backgroundColor.toHexString();\n    playButton.color = UnionEditor.style.darkLineColor.toHexString();\n    playButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    playButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    playButton.topInPixels = 10;\n    this.topPanel.addControl(playButton);\n\n    playButton.onPointerClickObservable.add(() => {\n      //The scene saves when going into PlayMode\n      if (!Engine.isPlaying) {\n        SceneManager.SaveCurrentScene();\n      }\n\n      if (!Engine.isPlaying) {\n        Engine.SwitchToPlayMode();\n        playButton.background =UnionEditor.style.selectionColor.toHexString();\n\n      } else {\n        Engine.StopPlayMode();\n        playButton.background =UnionEditor.style.backgroundColor.toHexString();\n      }\n      EditorSelection.SetSelectedGameObject(null);\n      //Reloading the current scene, which should reset if not playing\n      SceneManager.ReloadCurrentScene();\n\n      playButton.textBlock.text = Engine.isSwitchingToPlayMode ? \"Stop\" : \"Play\";\n    });\n\n\n    var pauseButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"PlayButton\", \"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.pause_button.png\");\n    pauseButton.width = \"25px\"; \n    pauseButton.height = \"25px\";\n    pauseButton.image.width = \"20px\";\n    pauseButton.image.height = \"20px\";\n    pauseButton.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    pauseButton.background =UnionEditor.style.backgroundColor.toHexString();\n    pauseButton.color = UnionEditor.style.darkLineColor.toHexString();\n    pauseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    pauseButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    pauseButton.topInPixels = 10;\n    this.topPanel.addControl(pauseButton);\n\n    pauseButton.onPointerClickObservable.add(() => {\n      print(\"Not yet implemented\");\n    });\n\n  }\n\n}\n",
            "HierarchyWindow": "class HierarchyWindow extends EditorWindow\n{\n  public static refresh : boolean = false;\n\n  public static idToCollapseState: Record<number, boolean> \n\n  lastObjects : number = 0;\n\n  private list : HierarchyList;\n\n\n  constructor ()\n  {\n    super();\n    HierarchyWindow.idToCollapseState = {};\n    SceneManager.onSceneLoaded.add((ev: Scene) => {\n      this.DisplaySceneHierarchy();\n    });\n  }\n\n\n  OnGUI ()\n  {\n    super.OnGUI();\n    var scene = SceneManager.GetActiveScene();\n    //Simple 'isDirty' check\n    if (scene != null && (scene.objs.length != this.lastObjects || HierarchyWindow.refresh))\n    {\n      HierarchyWindow.refresh = false;\n      this.lastObjects = scene.objs.length;\n      this.DisplaySceneHierarchy();\n    }\n  }\n\n  DisplaySceneHierarchy ()\n  {\n    this.Refresh();\n    this.list?.dispose();\n    var scene = SceneManager.GetActiveScene();\n\n    this.list = new HierarchyList(scene.rootObjs, 0, null);\n    this.main.addControl(this.list);\n  }\n}",
            "HierarchyList": "class HierarchyList extends BABYLON.GUI.StackPanel {\n\n  tabSize: number = 10;\n  parentItem: HierarchyItem\n  items: HierarchyItem[];\n\n  constructor(objs: GameObject[], offset: number, parentItem: HierarchyItem) {\n    super(\"HierarchyList\");\n\n    this.parentItem = parentItem;\n    this.leftInPixels = offset;\n\n\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    var i: number = 0;\n    this.items = new Array();\n\n    objs.forEach((obj: GameObject) => {\n      if (!obj)\n        return;\n\n\n      var splitItem = new HierarchySplitItem(this, i);\n      this.addControl(splitItem.background);\n      i++;\n\n      var item = new HierarchyItem(this, obj);\n      this.items.push(item);\n      this.addControl(item.p);\n      \n      item.onSelect.add(() => {\n        if (Input.GetKey(KeyCode.Control)) {\n          EditorSelection.ToggleSelectedGameObject(obj);\n\n        } else if (Input.GetKey(KeyCode.Shift)) {\n          if (EditorSelection.HasSelection()) {\n            var sel = EditorSelection.GetSelection();\n            var lastSelectedObject = sel[sel.length - 1];\n\n            this.state = 0;\n            this.GoThroughSelection(SceneManager.GetActiveScene().rootObjs, lastSelectedObject, item.obj);\n          }\n        } else {\n          EditorSelection.SetSelectedGameObject(obj);\n        }\n\n\n      });\n\n      //Slighly hacky way to ensure the newly created object is selected.\n      /*\n      if (obj == EditorSelection.currentSelectedGameObject) {\n        EditorSelection.SetSelectedGameObject(null);\n        EditorSelection.SetSelectedGameObject(obj);\n      }\n      */\n    });\n\n    //One split item at the bottom\n    var splitItem = new HierarchySplitItem(this, i);\n    this.addControl(splitItem.background);\n  }\n\n  state: number = 0;\n\n  GoThroughSelection(siblings: GameObject[], go1: GameObject, go2: GameObject) {\n\n    //state starts at 0: which means don't select items\n    //when it hits either GameObject, start selecting\n    //when it hits the next GameObject, stop everything.\n\n    //We collapse all children before we collapse a parent\n    siblings.forEach(item => {\n      if (this.state > 1)\n        return;\n\n      if (item === go1 || item === go2) {\n        EditorSelection.AddSelectedGameObject(item);\n        this.state++;\n      }\n\n      if (this.state == 1) {\n        EditorSelection.AddSelectedGameObject(item);\n      }\n\n      this.GoThroughSelection(item.transform.ser_children, go1, go2);\n\n\n\n    });\n  }\n}\n\n",
            "HierarchyItem": "\nclass BaseHierarchyItem {\n\n    background: BABYLON.GUI.Rectangle;\n    parentList: HierarchyList;\n\n    constructor (parentList: HierarchyList)\n    {\n        this.parentList = parentList;\n        this.background = new BABYLON.GUI.Rectangle(\"Block\");\n        this.background.color = UnionEditor.style.backgroundColor.toHexString();\n        this.background.widthInPixels = 200;\n        //Needs to block the pointer for the Gizmos to work.\n        this.background.isPointerBlocker = true;\n    }\n\n    OnReleased ()\n    {\n        \n    }\n}\n\n\nclass HierarchyItem extends BaseHierarchyItem {\n\n    public static justClicked: HierarchyItem = null;\n\n    public onChange: BABYLON.Observable<string>;\n    public onSelect: BABYLON.Observable<boolean>;\n\n    //Tweakables\n    itemHeight: number = 20;\n\n    maxDoubleClickDelay: number = 0.3;\n\n    //Gameplay Vars\n    public static currentDraggedItem: HierarchyItem = null;\n    public static currentHoveredItem: BaseHierarchyItem = null;\n\n    lastClickTime: number;\n    isSelected: boolean;\n    obj: GameObject;\n    isCollapsed = true;\n\n    //References\n    public p: BABYLON.GUI.StackPanel;\n    private collapseButton: BABYLON.GUI.Button;\n    childrenList: HierarchyList;\n\n    private nameField : BABYLON.GUI.TextBlock;\n\n    constructor(parentList: HierarchyList, obj: GameObject) {\n        super(parentList);\n        \n        this.obj = obj;\n\n        \n\n        this.onChange = new BABYLON.Observable();\n        this.onSelect = new BABYLON.Observable();\n\n        this.p = new BABYLON.GUI.StackPanel();\n        this.p.width = \"200px\";\n        this.p.heightInPixels = this.itemHeight;\n        this.p.isVertical = true;\n        this.p.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT\n\n\n        var item = new BABYLON.GUI.StackPanel();;\n        item.width = \"200px\";\n        item.height = \"20px\";\n        item.isVertical = false;\n        this.p.addControl(item);  \n\n        if (obj.transform.ser_children.length > 0) {\n            this.collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n            this.collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n            this.collapseButton.width = \"20px\";\n            this.collapseButton.color = UnionEditor.style.lineColor.toHexString();\n            this.collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n            this.background.addControl(this.collapseButton);\n\n            this.collapseButton.onPointerUpObservable.add((evt) => {\n                this.SetCollapse(!this.isCollapsed);\n            });\n        }\n\n        this.nameField = new BABYLON.GUI.TextBlock(\"\", obj.name);\n        this.nameField.paddingLeft = \"25px\";\n        this.nameField.paddingTopInPixels = 3;\n        this.nameField.color = obj.prefabParent ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.textColor.toHexString();\n        this.nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n        this.background.addControl(this.nameField);\n\n\n        var nameInput: BABYLON.GUI.InputText = null;\n\n        this.background.onPointerDownObservable.add((ev) => {\n            HierarchyItem.currentDraggedItem = this;\n            HierarchyItem.currentHoveredItem = this;\n        });\n\n        //This pointerUp is called when releasing a the pointer \n        //but NOT on the object the poitner is released, but rather where it was released from\n        this.background.onPointerUpObservable.add((ev) => {\n            var hover = HierarchyItem.currentHoveredItem;\n            \n            if (!hover) {\n               \n               //If not hovering over itself\n            } else if (this != hover) {\n                hover.OnReleased();                \n                HierarchyWindow.refresh = true;\n            }\n\n            HierarchyItem.currentDraggedItem = null;\n        });\n\n        Engine.scene.onPointerObservable.add((pointerInfo) => {\n            if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n                if (this != HierarchyItem.currentDraggedItem)\n                    return;\n            }\n        });\n\n        this.background.onPointerEnterObservable.add((ev) => {\n            if (HierarchyItem.currentDraggedItem) {\n\n                if (HierarchyItem.currentDraggedItem != this) {\n                    HierarchyItem.currentHoveredItem = this;\n                    this.background.background = UnionEditor.style.hoverColor.toHexString();\n                }\n            }\n        });\n\n        this.background.onPointerOutObservable.add((ev) => {\n            if (HierarchyItem.currentHoveredItem == this) {\n                HierarchyItem.currentHoveredItem = null;\n                if (!EditorSelection.IsSelected(this.obj)) {\n                    this.background.background = UnionEditor.style.backgroundColor.toHexString();\n                }\n            }\n        });\n\n\n        this.background.onPointerClickObservable.add((ev) => {\n            HierarchyItem.justClicked = this;\n            var clickDelay = Time.time - this.lastClickTime;\n            //Double click\n            if (clickDelay < this.maxDoubleClickDelay) {\n\n                if (nameInput == null) {\n                    nameInput = new BABYLON.GUI.InputText();\n                    nameInput.text = this.nameField.text;\n                    nameInput.width = 1;\n                    nameInput.height = 1;\n                    nameInput.color = UnionEditor.style.selectedTextColor.toHexString();\n                    nameInput.textHighlightColor = UnionEditor.style.selectionColor.toHexString();\n                    nameInput.onFocusSelectAll = true;\n                    this.background.addControl(nameInput);\n                    UnionEditor.editorUI.moveFocusToControl(nameInput);\n                    nameInput.onBlurObservable.add((ev) => {\n                        this.nameField.text = nameInput.text;\n                        nameInput.dispose();\n                        nameInput = null;\n                        obj.name = this.nameField.text;\n                        this.onChange.notifyObservers(obj.name);\n                    });\n                }\n                //Single click\n            } else {\n                this.onSelect.notifyObservers(this.isSelected);\n            }\n\n            this.lastClickTime = Time.time;\n\n        });\n\n        item.addControl(this.background);\n        item.paddingBottomInPixels = -3;\n        item.paddingTopInPixels = -3;\n        EditorSelection.onSelected.add((data: SelectionData) => {\n            if (data.obj === obj) {\n                this.SetSelected(data.isSelected);\n            }\n        });\n\n        var collapsed = HierarchyWindow.idToCollapseState[obj.transform.uniqueId];\n        this.SetCollapse(collapsed);\n        this.SetSelected(EditorSelection.IsSelected(obj));\n    }\n\n\n    SetCollapse(value: boolean) {\n        //Can't collapse if it has no children\n        if (value == this.isCollapsed || this.obj.transform.ser_children.length == 0)\n            return;\n\n        \n        this.isCollapsed = value;\n        HierarchyWindow.idToCollapseState[this.obj.transform.uniqueId] = value;\n        this.collapseButton.textBlock.text = this.isCollapsed ? \">\" : \"v\";\n        if (this.isCollapsed) {\n            //We collapse all children before we collapse a parent\n            this.childrenList.items.forEach(item => {\n                item.SetCollapse(true);\n            });\n            this.childrenList.dispose();\n            this.AddToHeight(-this.obj.transform.ser_children.length);\n        } else {\n            //TODO Clean this up! The HierarchyWindow shouldn't clean the child list\n            this.obj.transform.ser_children = this.obj.transform.ser_children.filter(function (el) {\n                return el != null;\n            });\n            \n            this.childrenList = new HierarchyList(this.obj.transform.ser_children, this.parentList.tabSize, this);\n            this.p.addControl(this.childrenList);\n            this.AddToHeight(this.obj.transform.ser_children.length);\n        }\n    }\n\n    public AddToHeight(nElements: number) {\n        this.p.heightInPixels += nElements * (this.itemHeight + 5); //5 because of HierarchySplitItemWidth <- FIX THIS!\n        this.p.heightInPixels += nElements > 0 ? 5 : -5;\n        if (this.parentList.parentItem) {\n            this.parentList.parentItem.AddToHeight(nElements);\n        }\n    }\n\n    OnReleased ()\n    {\n        //After releasing, parent all selected objects to here.\n        EditorSelection.GetSelection().forEach(go =>\n        {\n            go.transform.SetParent( this.obj.transform, true);\n        });\n    }\n\n    SetSelected (value : boolean)\n    {\n        if (value) {\n            this.background.background = UnionEditor.style.selectionColor.toHexString();\n            this.nameField.color = UnionEditor.style.textColor.toHexString();\n        } else {\n            this.background.background = UnionEditor.style.backgroundColor.toHexString();\n            this.nameField.color = this.obj.prefabParent ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.textColor.toHexString();\n        }\n    }\n}\n\nclass HierarchySplitItem extends BaseHierarchyItem {\n\n    siblingIndex : number;\n\n    constructor(parentList : HierarchyList, siblingIndex : number) {\n        super(parentList);\n\n        this.siblingIndex = siblingIndex;\n\n        this.background.heightInPixels = 5;\n        this.background.color = UnionEditor.style.backgroundColor.toHexString();\n\n        \n        this.background.onPointerEnterObservable.add((ev) => {\n            if (HierarchyItem.currentDraggedItem) {\n                HierarchyItem.currentHoveredItem = this;\n                this.background.background = UnionEditor.style.selectionColor.toHexString();                \n            }\n        });\n\n        this.background.onPointerOutObservable.add((ev) => {\n            if (HierarchyItem.currentHoveredItem == this) {\n                HierarchyItem.currentHoveredItem = null;\n                this.background.background = UnionEditor.style.backgroundColor.toHexString();\n            }\n        });\n    }\n\n    //The SplitItem returns it's parent since that will be the new parent for a dragged on object\n    OnReleased ()\n    {\n        //After releasing, parent all objects to my parent and set the sibling index\n        //TODO The splitter item should also know the parent\n        EditorSelection.GetSelection().forEach(go => \n        {\n            var i = go.transform.GetSiblingIndex();\n            var parentChange = go.transform.parent != this.parentList?.parentItem?.obj.transform;\n\n            go.transform.SetParent(this.parentList?.parentItem?.obj.transform, true);\n            \n            //Only if the parent didn't change, and we moved it from a higher spot to a lower spot\n            //We have to adjust our sibling index\n            if (parentChange || i > this.siblingIndex)\n            {\n                this.siblingIndex += 1;\n            }\n            \n            go.transform.SetSiblingIndex(this.siblingIndex);\n        });\n    }\n}\n\n",
            "EditorGizmos": "class EditorGizmos extends EditorSystem {\n  gizmoManager: BABYLON.GizmoManager;\n\n  private gizmoMode: Mode;\n\n  private prevMode: Mode;\n\n  //Since the GizmoManager requires a mesh to attach the pivot to, we will just use a dummy Mesh\n  private dummyMesh: BABYLON.Mesh;\n\n  private canSelect: boolean;\n\n  private isMoving: boolean;\n  private isRotating: boolean;\n  private isScaling: boolean;\n\n  private lastPos: BABYLON.Vector3 = new BABYLON.Vector3();\n  private lastRot: BABYLON.Vector3 = new BABYLON.Vector3();\n\n  constructor() {\n    super()\n\n    this.dummyMesh = new BABYLON.Mesh(\"GizmoDummyMesh\", Engine.scene);\n\n    // Initialize GizmoManager\n    this.gizmoManager = new BABYLON.GizmoManager(Engine.scene);\n\n    this.gizmoManager.keepDepthUtilityLayer.setRenderCamera(UnionEditor.editorCam.cam);\n    this.gizmoManager.utilityLayer.setRenderCamera(UnionEditor.editorCam.cam);\n    this.gizmoManager.attachToMesh(this.dummyMesh);\n    this.gizmoManager.usePointerToAttachGizmos = false;\n\n    //Need to enable once to access gizmos\n    this.gizmoManager.positionGizmoEnabled = true;\n    this.gizmoManager.rotationGizmoEnabled = true;\n    this.gizmoManager.scaleGizmoEnabled = true;\n\n    this.gizmoManager.gizmos.scaleGizmo.sensitivity = 10;\n\n    this.gizmoManager.gizmos.positionGizmo.onDragStartObservable.add((ev) => {\n      this.lastPos = this.dummyMesh.position.clone();\n      this.isMoving = true;\n    });\n    this.gizmoManager.gizmos.positionGizmo.onDragEndObservable.add((ev) => {\n      this.isMoving = false;\n    });\n\n    this.gizmoManager.gizmos.rotationGizmo.onDragStartObservable.add((ev) => {\n      this.lastRot = this.dummyMesh.rotationQuaternion.toEulerAngles().clone();\n      this.isRotating = true;\n    });\n    this.gizmoManager.gizmos.rotationGizmo.onDragEndObservable.add((ev) => {\n      this.isRotating = false;\n    });\n\n    this.gizmoManager.gizmos.scaleGizmo.onDragStartObservable.add((ev) => {\n      this.lastPos = this.dummyMesh.scaling.clone();\n      this.isScaling = true;\n    });\n    this.gizmoManager.gizmos.scaleGizmo.onDragEndObservable.add((ev) => {\n      this.isScaling = false;\n    });\n\n\n    this.gizmoManager.positionGizmoEnabled = false;\n    this.gizmoManager.rotationGizmoEnabled = false;\n    this.gizmoManager.scaleGizmoEnabled = false;\n\n    this.gizmoMode = Mode.Translate;\n\n    Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n\n          if (this.canSelect  && !EditorUI.IsPointerOverEditor()) {\n            var pickResult = Engine.scene.pick(Engine.scene.pointerX, Engine.scene.pointerY);\n            var go: GameObject = null;\n            if (pickResult.hit) {\n              var mesh = pickResult.pickedMesh;\n              go = !mesh?.parent ? null : Engine.meshToObject[mesh.parent.uniqueId];\n            }\n            if (Input.GetKey(KeyCode.Control)) {\n              EditorSelection.ToggleSelectedGameObject(go);\n            } else {\n              if (go) {\n                EditorSelection.SetSelectedGameObject(go);\n\n              } else {\n                EditorSelection.SetSelectedGameObject(null);\n              }\n            }\n\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n\n          break;\n      }\n    });\n\n\n  }\n\n  OnGUI() {\n    var selection = EditorSelection.GetSelection();\n\n    var hasSelection = selection?.length > 0;\n    if (hasSelection) {\n\n      if (this.isMoving) {\n        //How much the gizmo moved\n        var offset = this.dummyMesh.position.subtract(this.lastPos);\n\n        selection.forEach(go => {\n          //For some reason I need to set the entire Vector. The change is not recognized otherwise? 0_o\n          go.transform.position = new Vector3(\n            go.transform.position.x + offset.x,\n            go.transform.position.y + offset.y,\n            go.transform.position.z + offset.z\n          );\n        });\n\n        this.lastPos = this.dummyMesh.position.clone();\n      }\n      else {\n        Vector3.VtoB(EditorSelection.GetCenterPoint(), this.dummyMesh.position);\n      }\n      if (this.isRotating) {\n        var offset2 = this.dummyMesh.rotationQuaternion.toEulerAngles().subtract(this.lastRot)\n\n        selection.forEach(go => {\n          //We set each individual value so the inspector displays it properly\n          go.transform.localEulerAngles.x = go.transform.localEulerAngles.x + offset2.x * Mathf.Rad2Deg;\n          go.transform.localEulerAngles.y = go.transform.localEulerAngles.y + offset2.y * Mathf.Rad2Deg;\n          go.transform.localEulerAngles.z = go.transform.localEulerAngles.z + offset2.z * Mathf.Rad2Deg;\n\n\n        });\n\n        this.lastRot = this.dummyMesh.rotationQuaternion.toEulerAngles().clone();\n      } else {\n        //Just use the rotation of the first selected object...\n        this.dummyMesh.rotationQuaternion = EditorSelection.GetSelection()[0].transform.transformNode.absoluteRotationQuaternion.clone();\n      }\n\n      if (this.isScaling) {\n        var offset3 = this.dummyMesh.scaling.subtract(this.lastPos)\n\n        selection.forEach(go => {\n\n          go.transform.localScale.x = go.transform.localScale.x + offset3.x;\n          go.transform.localScale.y = go.transform.localScale.y + offset3.y;\n          go.transform.localScale.z = go.transform.localScale.z + offset3.z;\n\n        });\n\n        this.lastPos = this.dummyMesh.scaling.clone();\n      }\n    }\n\n\n    this.gizmoManager.positionGizmoEnabled = this.gizmoMode == Mode.Translate && hasSelection;\n    this.gizmoManager.rotationGizmoEnabled = this.gizmoMode == Mode.Rotate && hasSelection;\n    this.gizmoManager.scaleGizmoEnabled = this.gizmoMode == Mode.Scale && hasSelection;\n    this.gizmoManager.boundingBoxGizmoEnabled = false;\n\n    if (Input.GetKeyDown(KeyCode.W)) {\n      this.gizmoMode = Mode.Translate;\n    }\n\n    if (Input.GetKeyDown(KeyCode.E)) {\n      this.gizmoMode = Mode.Rotate;\n    }\n\n    if (Input.GetKeyDown(KeyCode.R)) {\n      this.gizmoMode = Mode.Scale;\n    }\n\n    if (Input.GetKey(KeyCode.Alt) || EditorUI.IsPointerOverEditor()) {\n      this.canSelect = false;\n      this.gizmoManager.clearGizmoOnEmptyPointerEvent = false;\n      //this.gizmoManager.usePointerToAttachGizmos = false;\n    } else {\n      this.canSelect = true;\n      this.gizmoManager.clearGizmoOnEmptyPointerEvent = true;\n      //this.gizmoManager.usePointerToAttachGizmos = true;\n\n    }\n\n    if (Input.GetKeyDown(KeyCode.Escape)) {\n      EditorSelection.SetSelectedGameObject(null);\n    }\n\n  }\n\n}\n\nenum Mode {\n  Translate,\n  Rotate,\n  Scale\n}",
            "EditorSelection": "class EditorSelection extends EditorSystem {\n  constructor() {\n    super();\n    EditorSelection.onSelected = new BABYLON.Observable();\n  }\n\n  private static selected: GameObject[] = new Array();\n\n  public static onSelected: BABYLON.Observable<SelectionData>\n\n\n  public static IsSelected(value: GameObject, includeParent: boolean = false): boolean {\n    return this.selected.indexOf(value) != -1;\n  }\n\n  public static HasSelection (): boolean{\n    return this.GetSelection().length > 0;\n  }\n\n  public static currentSelectedGameObject;\n\n  public static GetSelection(): GameObject[] {\n    return this.selected;\n  }\n\n  public static GetCenterPoint(): Vector3 {\n    var v = new Vector3();\n    this.selected.forEach((s: GameObject) => {\n      v.x += s.transform.position.x;\n      v.y += s.transform.position.y;\n      v.z += s.transform.position.z;\n    });\n\n    v.x /= this.selected.length;\n    v.y /= this.selected.length;\n    v.z /= this.selected.length;\n    return v;\n  }\n\n  public static ToggleSelectedGameObject(go: GameObject) {\n    if (EditorSelection.IsSelected(go)) {\n      EditorSelection.RemoveSelectedGameObject(go);\n    } else {\n      EditorSelection.AddSelectedGameObject(go);\n    }\n  }\n\n  public static AddSelectedGameObject(params: GameObject | GameObject[]) {\n    if (!params)\n      return;\n\n    if (params instanceof GameObject)\n      params = new Array(params);\n\n    params.forEach(value => {\n      if (this.selected.indexOf(value) == -1)\n      {\n        this.selected.push(value);\n        this.onSelected.notifyObservers({ obj: value, isSelected: true });\n      }\n    });\n  }\n\n  public static RemoveSelectedGameObject(params: GameObject | GameObject[]) {\n    if (!params)\n      return;\n\n    if (params instanceof GameObject)\n      params = new Array(params);\n\n    params.forEach(value => {\n      const index = this.selected.indexOf(value);\n      if (index > -1) {\n        this.selected.splice(index, 1);\n        this.onSelected.notifyObservers({ obj: value, isSelected: false });\n      }\n    });\n  }\n\n  private static ClearSelection() {\n    //Clear old selection\n    this.selected.forEach((s: GameObject) => {\n      this.onSelected.notifyObservers({ obj: s, isSelected: false });\n    });\n\n    this.selected = new Array();\n  }\n\n  public static SetSelectedGameObject(params: GameObject | GameObject[]) {\n    this.ClearSelection();\n\n    this.AddSelectedGameObject(params);\n  }\n}\n\nclass SelectionData {\n  obj: BaseObject;\n  isSelected: boolean;\n}",
            "InspectorWindow": "class InspectorWindow extends EditorWindow\n{\n  static current : InspectorWindow;\n  currentGameObject : GameObject;\n\n  constructor ()\n  {\n    super()\n    InspectorWindow.current = this;\n    EditorSelection.onSelected.add((data : SelectionData) => {\n      \n      if (data.isSelected)\n      {\n        this.RefreshGOInspector(data.obj as GameObject);\n      } else {\n        this.Refresh();\n      }\n    });\n\n    PixelPADEvents.onMaterialClicked.add((matName: string) => {\n      EditorSelection.SetSelectedGameObject(null);\n      this.Refresh();\n      this.main.addControl(new MaterialInspector(matName));\n    });\n\n    PixelPADEvents.onPrefabClicked.add((name: string) => {\n      this.Refresh();\n      this.main.addControl(new PrefabInspector(name));\n    });\n  }\n\n  OnViewModel () \n  {\n    this.Refresh();\n    this.main.addControl(new ModelViewer());\n  }\n\n  OnGUI ()\n  {\n    //When a GO is about to be deleted, we should clear the inspector\n    if (this.currentGameObject && this.currentGameObject.markedForDestroy)\n    {\n      this.Refresh();\n    }\n  }\n\n  RefreshGOInspector (go : GameObject)\n  {\n    this.Refresh();\n    this.currentGameObject= go;\n\n    go.components.forEach((c : Component) => {\n      if (!c.markedForDestroy)\n      {\n        this.main.addControl(new ComponentInspector(this, c));\n      }\n    });\n\n    var addButton = BABYLON.GUI.Button.CreateSimpleButton(\"\", \"Add Component\");\n    addButton.width = \"150px\";\n    addButton.height = \"20px\";\n    addButton.color = UnionEditor.style.darkLineColor.toHexString();\n    addButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    this.main.addControl(addButton);\n    addButton.onPointerClickObservable.add(() => {\n      var dropDown = new Dropdown(3);\n      dropDown.isSearchable = true;\n      \n      dropDown.SetOptions(this.GetAvailableComponents());\n      this.main.addControl(dropDown);\n      dropDown.onSelect.add((selected: string) =>\n      {\n          go.AddComponent(selected);\n          this.RefreshGOInspector(go);\n      });          \n    });\n    \n    //Can't edit prefabs directly.\n    if (go.prefabParent && go.prefabParent != go)\n    {\n      let coverPanel = new BABYLON.GUI.Rectangle();\n      coverPanel.widthInPixels = this.background.widthInPixels;\n      coverPanel.heightInPixels = this.background.heightInPixels;\n      coverPanel.background = UnionEditor.style.backgroundColor.toHexString() + \"88\";\n      this.background.addControl(coverPanel);\n    }\n  }\n\n  //TODO reconsider the hackiness of this.\n  //Can be done through Serializable Fields\n  GetAvailableComponents () : string []\n  {\n    var components : string[] = new Array();\n    var scripts : string[] = Engine.scripts;\n    scripts.forEach((script : string) => {\n      try {\n        if (eval(script + \".isc\") == true)\n        {\n          components.push(script);\n        }\n      } catch (e)\n      {\n\n      }\n    });\n    return components;\n  }\n\n\n  Refresh()\n  {\n    this.currentGameObject = null;\n    super.Refresh();\n    this.background.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;\n  }\n\n}",
            "ComponentInspector": "//script:ComponentInspector\n\nclass ComponentInspector extends BABYLON.GUI.StackPanel {\n\n  propertiesPanel: BABYLON.GUI.StackPanel;\n\n  constructor(parent: InspectorWindow, c: Component) {\n    super()\n\n    var namePanel = new BABYLON.GUI.StackPanel();\n    namePanel.heightInPixels = 20;\n    namePanel.isVertical = false;\n    this.addControl(namePanel);\n\n    var collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n    collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    collapseButton.width = \"20px\";\n    collapseButton.color = UnionEditor.style.backgroundColor.toHexString();\n    collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    namePanel.addControl(collapseButton);\n\n    collapseButton.onPointerUpObservable.add((evt) => {\n      this.propertiesPanel.isVisible = !this.propertiesPanel.isVisible;\n      collapseButton.textBlock.text = this.propertiesPanel.isVisible ? \"v\" : \">\";\n    });\n\n\n    var nameField = new BABYLON.GUI.TextBlock(\"\", c.constructor.name);\n\n    nameField.paddingLeft = \"5px\";\n    nameField.style = UnionEditor.fontStyleBold;\n    nameField.color = UnionEditor.style.textColor.toHexString();\n    nameField.width = \"140px\";\n    nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    namePanel.addControl(nameField);\n    namePanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.propertiesPanel = new BABYLON.GUI.StackPanel();\n    this.propertiesPanel.isVisible = true;\n    this.addControl(this.propertiesPanel);\n\n    Serializer.GetPropValues(c, false).forEach((value: any, key: string) => {\n      var propInspector: PropertyInspector = PropertyInspector.Create(c, key, value);\n\n      this.propertiesPanel.addControl(propInspector);\n    });\n\n\n    if (c.GetType() == \"Transform\") {\n      //TODO DRY this up\n      this.propertiesPanel.isVisible = true;\n\n    } else {\n      //Transforms can't be removed\n      var deleteButton = BABYLON.GUI.Button.CreateSimpleButton(\"deleteButton\", \"x\");\n      deleteButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n      deleteButton.width = \"20px\";\n      deleteButton.color = UnionEditor.style.darkLineColor.toHexString();\n      deleteButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n      namePanel.addControl(deleteButton);\n\n      deleteButton.onPointerUpObservable.add((evt) => {\n        var go: GameObject = c.gameObject;\n        Destroy(c);\n        parent.RefreshGOInspector(go);\n        /*\n        var dropDown = new Dropdown();\n          dropDown.AddOption(\"Remove Component\");\n          dropDown.linkOffsetXInPixels = 50;\n          UnionEditor.editorUI.addControl(dropDown);\n          dropDown.onSelect.add((selected: string) =>\n          {\n            if (selected == \"Remove Component\")\n            {\n              \n            }\n            \n          });       \n          */\n      });\n\n    }\n\n    collapseButton.textBlock.text = this.propertiesPanel.isVisible ? \"v\" : \">\";\n\n  }\n}",
            "PropertyInspector": "class PropertyInspector extends BABYLON.GUI.StackPanel {\n\n  public onValueChanged : BABYLON.Observable<any> = new BABYLON.Observable();\n\n  //This is a variable used to store which PropertyInspector was last created\n  //We can use that to tab through the Inspectors after\n  //Currently only setup in the Text Inspector\n  public static lastCreated : PropertyInspector;\n\n  protected previous : PropertyInspector;\n  public next : PropertyInspector; \n\n  isAdjustingByMouse: boolean = false;\n  isOverThisControl : boolean = false;\n\n  //The object that 'owns' this property\n  owner : any;\n  propName : string;\n  valueInput : any;\n\n  get value () : any\n  {\n    return this._value;\n  }\n\n  set value (v : any)\n  {\n    this._value = v;\n  }\n\n  _value : any;\n\n  constructor(owner: any, propName: string, value: any) {\n    super()\n\n    this.isVertical = false;\n    //this.adaptWidthToChildren = true;\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.owner = owner;\n    this.propName = propName;\n    this.value = value;\n\n    this.heightInPixels = 20;\n    var nameField = new BABYLON.GUI.TextBlock(\"\", this.ConvertToInspectorName(propName));\n    nameField.paddingLeft = \"5px\";\n    nameField.color =  UnionEditor.style.textColor.toHexString();\n    nameField.style = UnionEditor.fontStyle;\n    if (owner instanceof Component)\n    {\n      nameField.width = \"60px\"\n    }\n    else\n    {\n      nameField.resizeToFit = true;\n    }\n    nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(nameField); \n  }\n\n  ConvertToInspectorName(value : string)\n  {\n    value = value.replace(\"_\", \" \");\n    value = value.trim();\n    //Start with uppercase\n    value = value[0].toUpperCase() + value.substring(1, value.length);\n    return value;\n  }\n\n  Init ()\n  {\n\n  }\n\n  UpdateProperty ()\n  {    \n    this.owner[this.propName] = this.value;\n    this.onValueChanged.notifyObservers(this.value);\n  }\n\n  public static Create(c : any, key : string, value : any): PropertyInspector\n  {\n    var propInspector : PropertyInspector =null;\n    //TODO using declarations in the Inspector classes this could be a bit prettier.      \n    if (value === null) {\n      return;\n    } else if (typeof value === 'number') {\n      propInspector = new NumberInspector(c, key, value);\n    } else if (typeof value === 'string') {\n      propInspector = new TextInspector(c, key, value);\n    } else if (typeof value === 'boolean') {\n      propInspector = new BoolInspector(c, key, value);\n    } else if (value instanceof Array) {\n      //TODO Add ArrayInspector\n      propInspector = new ArrayInspector(c, key, value);\n    } else if (value instanceof Vector3) {\n      propInspector = new Vector3Inspector(c, key, value);\n    } else if (value instanceof Color) {\n      propInspector = new ColorInspector(c, key, value);\n    }  else {\n      propInspector = new TextInspector(c, key, value);\n    }\n    propInspector.Init();\n    return propInspector;\n  }\n\n}",
            "EditorUI": "//TODO is this Editor only?\nclass EditorUI\n{\n  //A variety of objects (such as EditorWindows, but also ColorPicker) use this\n  private static objs : any[] = new Array();\n\n  public static SetPointerOverEditor(obj : any)\n  {\n    var i = this.objs.indexOf(obj);\n    if (i == -1)\n    {\n      this.objs.push(obj);\n    }\n  }\n\n  public static RemovePointerOverEditor(obj : any)\n  {\n    var i = this.objs.indexOf(obj);\n    if (i != -1)\n    {\n      this.objs = this.objs.splice(i, 1);\n    }\n  }\n\n  public static IsPointerOverEditor () : boolean\n  {\n    //I'm not sure why this is > 1... but it works and it's late.\n    return this.objs.length > 1;\n  }\n\n}",
            "TextInspector": "class TextInspector extends PropertyInspector\n{\n  Init()\n  {\n    super.Init();\n\n    if (PropertyInspector.lastCreated)\n    {\n      //We set this up to tab through this afterwards\n      this.previous = PropertyInspector.lastCreated;\n      PropertyInspector.lastCreated.next = this;\n    }\n    PropertyInspector.lastCreated = this;\n\n    this.valueInput = new BABYLON.GUI.InputText();\n    var vInput : BABYLON.GUI.InputText = this.valueInput;\n    \n    this.valueInput.style = UnionEditor.fontStyle;\n    this.valueInput.paddingLeftInPixels = 2;\n    this.valueInput.paddingRightInPixels = 2;\n    this.valueInput.margin = \"2px\";\n    this.valueInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    var x = new BABYLON.GUI.InputText();\n    this.valueInput.text = this.value ? this.value : \"\";\n    this.valueInput.width = \"100px\";\n    this.valueInput.color =  UnionEditor.style.textColor.toHexString();\n    \n    this.valueInput.onFocusSelectAll = true;\n    //When inspector inputfield is changed, update value\n    this.valueInput.onBlurObservable.add((ev) => {\n      this.UpdateValueFromText();\n      this.UpdateProperty ();\n    });\n\n    vInput.onKeyboardEventProcessedObservable.add((event) => {\n      if (event.key == \"Tab\")\n      {\n        var nextSelected : PropertyInspector = this.next;\n        if (event.shiftKey)\n        {\n          nextSelected = this.previous;\n        }\n        if (nextSelected)\n        {\n          UnionEditor.editorUI.moveFocusToControl(nextSelected.valueInput);\n          event.preventDefault();\n        }\n      }\n    });    \n\n    this.addControl(this.valueInput);\n    //Update the value every frame in the inspector\n    Engine.scene.onBeforeRenderObservable.add(() =>\n    {\n       this.UpdateTextFromValue ();\n    });\n  }\n\n  UpdateValueFromText()\n  {\n    if (this.value != this.valueInput.text)\n    {\n      this.value = this.valueInput.text;\n      SceneManager.MarkSceneAsDirty();\n    }\n  }\n\n  UpdateTextFromValue ()\n  {  \n    if (this.value != this.owner[this.propName])\n    {\n      this.value = this.owner[this.propName];\n      this.valueInput.text = this.value;\n      SceneManager.MarkSceneAsDirty();\n    }\n  }\n}",
            "NumberInspector": "//script:NumberInspector\nclass NumberInspector extends TextInspector {\n  \n  mouseAdjustSensitivity : number = 0.01;\n  \n  public Init() {\n    super.Init();\n    if (this.valueInput.text == \"\")\n    {\n      this.valueInput.text = \"0\";\n    }\n    this.valueInput.width = \"30px\";\n   \n    this.onPointerEnterObservable.add((ev) => {\n      Engine.cursor = \"ew-resize\";\n      this.isOverThisControl = true;\n    });\n    this.onPointerOutObservable.add((ev) => {\n      Engine.cursor = \"default\";\n      this.isOverThisControl = false;\n    });\n\n    Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.isOverThisControl) {\n            this.isAdjustingByMouse = true;\n            Engine.current.enterPointerlock();\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERUP:\n          this.isAdjustingByMouse = false;\n          Engine.current.exitPointerlock();\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n          if (this.isAdjustingByMouse) {\n            this.value += pointerInfo.event.movementX * this.mouseAdjustSensitivity;\n            this.valueInput.text = this.value;\n            this.UpdateProperty();\n          }\n          break;\n      }\n    });\n  }\n\n  UpdateTextFromValue()\n  {\n    super.UpdateTextFromValue();\n  }\n\n\n  //Convert the text into a number\n  \n  UpdateValueFromText() {\n    if (this.value != +this.valueInput.text)\n    {\n      var x = +this.valueInput.text;\n      if (Number.isNaN(x))\n      {\n        this.valueInput.text = \"0\";\n        x = 0;\n      }\n\n      this.value = x;\n      \n      SceneManager.MarkSceneAsDirty();\n    }\n  }\n  \n}",
            "ArrayInspector": "class ArrayInspector extends PropertyInspector {\n\n  Init()\n  {\n    super.Init();\n  }\n}\n",
            "ColorInspector": "class ColorInspector extends PropertyInspector {\n\ncurrentPicker : BABYLON.GUI.ColorPicker;\n\nInit()\n  {\n    super.Init();\n\n    var colorButton : BABYLON.GUI.Button = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \"\");\n    \n    colorButton.paddingLeftInPixels = 2;\n    colorButton.paddingRightInPixels = 2;\n    colorButton.width = \"15px\";\n    colorButton.height = \"10px\";\n    colorButton.color = \"white\";\n\n    var c : BABYLON.Color3 = new BABYLON.Color3();\n    Color.UtoB(this.value, c);\n    \n    colorButton.background = c.toHexString();    \n    colorButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.addControl(colorButton);\n\n    colorButton.onPointerClickObservable.add((ev) => {  \n      this.TryDisposeColorPicker();\n      this.currentPicker = new BABYLON.GUI.ColorPicker(\"Color Picker\");\n      this.currentPicker.value = c;\n      this.currentPicker.onValueChangedObservable.add(() => {\n        Color.BtoU(this.currentPicker.value, this.value);\n        this.UpdateProperty();\n        colorButton.background = this.currentPicker.value.toHexString();        \n      });\n      this.currentPicker.onPointerEnterObservable.add((ev) => {\n        EditorUI.SetPointerOverEditor(this.currentPicker);\n      })\n      this.currentPicker.onPointerOutObservable.add((ev) => {\n        EditorUI.RemovePointerOverEditor(this.currentPicker);\n      })\n      UnionEditor.editorUI.addControl(this.currentPicker);\n    });\n\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP) {        \n        this.TryDisposeColorPicker();\n      }\n    });\n\n    \n\n    this.onDisposeObservable.add(() => {\n      this.TryDisposeColorPicker();\n    });\n    /*\n    this.valueInput.color = this.value;\n    this.valueInput.onValueChangedObservable.add(() => {\n      this.value = this.valueInput.color;\n      this.UpdateProperty();\n    });\n    \n    //Update the value every frame in the inspector\n    Engine.scene.onBeforeRenderObservable.add(() =>\n    {\n      if (this.valueInput.color != this.value)\n      {\n        SceneManager.MarkSceneAsDirty();\n        this.valueInput.color = this.value;\n      }\n        \n    });\n    */\n  }\n\n  TryDisposeColorPicker () \n  {\n    if (this.currentPicker)\n      {\n        this.currentPicker.dispose();\n        this.currentPicker = null;\n        return;\n      }\n  }\n\n}\n",
            "BoolInspector": "class BoolInspector extends PropertyInspector\n{\n  Init()\n  {\n    super.Init();\n    \n    this.valueInput = new BABYLON.GUI.Checkbox(\"Checkbox\");\n    this.valueInput.paddingLeftInPixels = 2;\n    this.valueInput.paddingRightInPixels = 2;\n    this.valueInput.margin = \"2px\";\n    this.valueInput.width = \"15px\";\n    this.valueInput.height = \"10px\";\n    this.valueInput.color = \"white\";\n    \n    this.valueInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(this.valueInput);\n    \n    this.valueInput.isChecked = this.value;\n    this.valueInput.onIsCheckedChangedObservable.add(() => {\n      this.value = this.valueInput.isChecked;\n      this.UpdateProperty();\n    });\n    \n    //Update the value every frame in the inspector\n    Engine.scene.onBeforeRenderObservable.add(() =>\n    {\n      if (this.valueInput.isChecked != this.value)\n      {\n        SceneManager.MarkSceneAsDirty();\n        this.valueInput.isChecked = this.value;\n      }\n        \n    });\n    \n  }\n\n  \n}",
            "Vector3Inspector": "//script:Vector3Inspector\nclass Vector3Inspector extends PropertyInspector\n{\n  Init ()\n  {\n    super.Init();\n     Serializer.GetPropValues(this.value, true).forEach((value: any, key: string) => {\n       \n       this.addControl(PropertyInspector.Create(this.value, key, value));\n     });   \n  }\n\n  Update()\n  {\n    \n  }\n\n}\n",
            "Dropdown": "class Dropdown extends BABYLON.GUI.StackPanel\n{\n  public isSearchable : boolean;\n  public maxOptions : number;\n  public onSelect : BABYLON.Observable<string>;\n\n  options : string[] = new Array();\n  searchInput : BABYLON.GUI.InputText;\n\n  optionStack : BABYLON.GUI.StackPanel;\n\n  filteredOptions : string[] = new Array();\n\n constructor (maxOptions : number = -1)\n {\n   super();\n   this.maxOptions = maxOptions;\n   this.onSelect = new BABYLON.Observable();\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n        this.dispose();\n      }\n    });\n }\n\n public SetOptions (options: string[])\n {\n    this.options = options;\n    this.Refresh();\n }\n\n Refresh ()\n {\n    this.searchInput = new EditorInputText();\n    this.addControl(this.searchInput);\n    this.searchInput.text = \"\";\n    \n    this.searchInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.searchInput.onTextChangedObservable.add((ev) => {\n      this.RefreshOptions();\n    });\n\n    this.searchInput.onKeyboardEventProcessedObservable.add((ev) =>\n    {\n      if (ev.keyCode == KeyCode.Enter)\n      {\n        if (this.filteredOptions.length > 0)\n        {\n          this.onSelect.notifyObservers(this.filteredOptions[0]);\n        }\n      }\n    });\n    this.RefreshOptions();\n    //We have to wait one frame or else we get error messages?\n    this.Focus();\n }\n\n async Focus ()\n {\n    await null;\n    UnionEditor.editorUI.moveFocusToControl(this.searchInput);\n }\n\n RefreshOptions () \n {\n   this.optionStack?.dispose();\n\n   this.optionStack = new BABYLON.GUI.StackPanel;\n   this.addControl(this.optionStack);\n   var filter = \"\";\n   if (this.isSearchable)\n   {\n     filter = this.searchInput.text;\n   }\n\n   var i = 0;\n   this.filteredOptions = new Array();\n   this.options.forEach((option : string) => {\n    if (option.toLowerCase().includes(filter.toLowerCase()))\n    {\n      if (i != -1 && i >= this.maxOptions)\n      {\n        return;\n      }\n      i++;\n      this.filteredOptions.push(option);\n      \n    }\n   });\n\n    this.filteredOptions.forEach((option : string) => {\n    var scriptButton = BABYLON.GUI.Button.CreateSimpleButton(\"\", option);\n        scriptButton.width = \"150px\";\n        scriptButton.height = \"20px\";\n        scriptButton.color = UnionEditor.style.darkLineColor.toHexString();\n        scriptButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n        scriptButton.onPointerClickObservable.add(() =>\n        {\n          this.onSelect.notifyObservers(option);\n        });\n        this.optionStack.addControl(scriptButton);\n    });\n }\n}\n",
            "EditorInputText": "class EditorInputText extends BABYLON.GUI.InputText {\n\n  constructor ()\n  {\n    super(\"EditorInputText\");\n    this.style = UnionEditor.fontStyle;\n    this.paddingLeftInPixels = 2;\n    this.paddingRightInPixels = 2;\n    this.margin = \"2px\";\n    this.width = \"150px\"\n    this.height = \"20px\";\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.color = \"white\";\n  }\n}\n",
            "Material": "class Material {\n\n  constructor(name: string) {\n    this.shader = new BABYLON.StandardMaterial(name, Engine.scene);\n  }\n\n  shader: BABYLON.StandardMaterial;\n\n  @SerializeField\n  mainColor: Color = new Color();\n\n  @SerializeField\n  mainTexture: string = \"\";\n  _lastTexture: string = \"\";\n\n  @SerializeField\n  alpha : number = 1;\n\n  @SerializeField\n  normalTexture: string = \"\";\n  _lastNormalTexture: string = \"\";\n\n  @SerializeField uScale: number = 1;\n  @SerializeField vScale: number = 1;\n\n  @SerializeField \n  specularColor : Color = new Color(0,0,0);\n\n  @SerializeField\n  specularPower : number = 0;\n\n  @SerializeField\n  roughness : number = 0;\n\n  private Update() {\n    Color.UtoB(this.mainColor, this.shader.diffuseColor);\n    Color.UtoB(this.specularColor, this.shader.specularColor);\n\n    this.shader.specularPower = this.specularPower;\n    this.shader.alpha = this.alpha;\n    this.shader.roughness = this.roughness;\n\n    if (this.mainTexture && this.mainTexture != this._lastTexture) {\n      this.shader.diffuseTexture = TextureSystem.GetSprite(this.mainTexture);\n      this._lastTexture = this.mainTexture;\n    }\n    if (this.normalTexture && this.normalTexture != this._lastNormalTexture) {\n      this.shader.bumpTexture = TextureSystem.GetSprite(this.normalTexture);\n      this._lastNormalTexture = this.normalTexture;\n    }\n\n    var t = this.shader.diffuseTexture as BABYLON.Texture;\n\n    if (t) {\n      t.uScale = this.uScale;\n      t.vScale = this.vScale;\n    }\n  }\n\n\n  // #region static\n  public static Get(name: string): Material {\n    //Not in array or null?\n    if (!this.nameToMat.has(name) || !this.nameToMat.get(name)) {\n      //If no name is added, we just use default\n      if (name) {\n        var matJson = getMaterial(name);\n      }\n\n      var material: Material = null;\n      //If we we used a non-existent material matJson would not be there.\n      if (matJson) {\n        material = Serializer.FromJSON(matJson, false);\n      }\n\n      if (!material) {\n        material = new Material(name);\n      }\n\n      this.nameToMat.set(name, material);\n    }\n\n    return this.nameToMat.get(name);\n  }\n\n\n  public static SaveToJSON(name: string) {\n    //Not in array or null?\n    if (!this.nameToMat.has(name) || !this.nameToMat.get(name)) {\n      Debug.Log(\"Error saving material \" + name + \". This material does not exist!\");\n      return;\n    }\n    var matJson = Serializer.ToJSON(this.nameToMat.get(name));\n    saveMaterial(name, matJson);\n  }\n\n  public static nameToMat: Map<string, Material>;\n\n  public static Init() {\n    this.nameToMat = new Map<string, Material>();\n\n  }\n\n  public static Update() {\n    //We run an update method on all active materials \n    this.nameToMat.forEach((value: Material, key: string) => {\n      value.Update();\n    });\n  }\n  // #endregion\n}\n",
            "MaterialInspector": "class MaterialInspector extends BABYLON.GUI.StackPanel {\n\n  material : Material;\n\n  propertiesPanel : BABYLON.GUI.StackPanel;\n\n  materialName : string;\n\n constructor(materialName : string) {\n    super()\n    \n    this.materialName = materialName;\n\n    var material = Material.Get(materialName);\n\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    \n    this.material = material;\n    \n    this.propertiesPanel = new BABYLON.GUI.StackPanel();\n    this.propertiesPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.propertiesPanel.isVisible = true;\n    \n    this.addControl(this.propertiesPanel);  \n\n    Serializer.GetPropValues(material, false).forEach((value: any, key: string) => {\n      var propInspector: PropertyInspector = PropertyInspector.Create(material, key, value);      \n      this.propertiesPanel.addControl(propInspector);\n      propInspector.onValueChanged.add((ev) => {\n        Material.SaveToJSON(this.materialName);\n      });\n    });\n   \n }\n\n \n}\n",
            "ModelViewer": "class ModelViewer extends BABYLON.GUI.StackPanel {\n\n  img: BABYLON.GUI.Image;\n\n  valueInput: BABYLON.GUI.InputText;\n\n  scene: BABYLON.Scene;\n  cam: BABYLON.ArcRotateCamera;\n\n  isValidFile: boolean = false;\n  url: string;\n\n  viewedObject: BABYLON.TransformNode;\n\n  fileType: FileType = FileType.Texture;\n\n  constructor() {\n    super()\n\n    this.valueInput = new BABYLON.GUI.InputText();\n    this.valueInput.style = UnionEditor.fontStyle;\n    this.valueInput.paddingLeftInPixels = 2;\n    this.valueInput.paddingRightInPixels = 2;\n    this.valueInput.margin = \"2px\";\n    this.valueInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.valueInput.width = \"100px\";\n    this.valueInput.height = \"40px\";\n    this.valueInput.color = UnionEditor.style.textColor.toHexString();\n    this.valueInput.paddingTop = 10;\n    this.valueInput.paddingBottom = 10;\n\n    this.addControl(this.valueInput);\n\n    this.RecreateTextureImage();\n\n    var downloadButton = UnionEditor.CreateButton(\"Download\");\n    downloadButton.paddingTopInPixels = 10;\n    downloadButton.heightInPixels = 30;\n    downloadButton.isVisible = false;\n    this.addControl(downloadButton);\n\n    var urlButton = UnionEditor.CreateButton(\"Print URL\");\n    urlButton.paddingTopInPixels = 10;\n    urlButton.heightInPixels = 30;\n    urlButton.isVisible = false;\n    this.addControl(urlButton);\n\n    urlButton.onPointerClickObservable.add(ev => {\n      if (this.isValidFile) {\n        print(this.url);\n      }\n    });\n\n    downloadButton.onPointerClickObservable.add(ev => {\n      if (this.isValidFile) {\n        window.open(this.url);\n      }\n    });\n\n    this.onDisposeObservable.add(e => {\n      this.OnDispose();\n    });\n\n    this.scene = new BABYLON.Scene(Engine.current);\n    this.scene.autoClear = false;\n    this.scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);\n\n    this.cam = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), this.scene);\n    this.cam.position = new BABYLON.Vector3(0, 0, -5);\n\n\n    this.cam.attachControl(Engine.canvas, true);\n    this.cam.wheelPrecision = 10;\n    this.scene.activeCameras.push(this.cam);\n\n    var background = BABYLON.Mesh.CreatePlane(\"Background\", 100000, this.scene);\n    background.rotate(new BABYLON.Vector3(0, 0, 1), Math.PI * 0.5);\n    background.position.z = 500;\n    var m = new BABYLON.StandardMaterial(\"BackgroundMat\", this.scene);\n    m.disableLighting = true;\n    background.material = m;\n    //Parented so it follows when the camera zooms/rotates\n    background.setParent(this.cam);\n\n    var light = new BABYLON.DirectionalLight(\"light\", new BABYLON.Vector3(0, 1, 0), this.scene);\n    light.intensity = .7;\n\n    //Render \n    Engine.editorScene.onAfterRenderObservable.add((ev) => {\n      if (this.fileType == FileType.Model) {\n        light.setDirectionToTarget(background.absolutePosition);\n\n        //This is so we can use pixel coordinates instead of the ratio\n        //That way, the viewport displays on top of our GUI\n        var posX = 1 - 175 / Engine.canvas.width;\n        var width = 150 / Engine.canvas.width;\n        var posY = 158 / Engine.canvas.height;\n        var height = 150 / Engine.canvas.height;\n\n        this.cam.viewport = new BABYLON.Viewport(posX, posY, width, height);\n        this.scene.render();\n      }\n    });\n\n    this.viewedObject = new BABYLON.TransformNode(\"ViewedObject\", this.scene);\n\n\n    this.valueInput.onBlurObservable.add(e => {\n      this.viewedObject?.dispose(false, true);\n      this.img.widthInPixels = 0;\n      downloadButton.isVisible = false;\n      urlButton.isVisible = false;\n\n      this.isValidFile = false;\n      var fileName = this.valueInput.text;\n      this.url = \"\";\n      if (fileName.endsWith(\".obj\")) {\n        this.url = getModel(fileName);\n        this.fileType = FileType.Model;\n\n        //Load the model\n        var fullName = Engine.getFullName(fileName, FileType.Model);\n        BABYLON.SceneLoader.ImportMesh(\"\", Engine.getUrl(), fullName, this.scene, (meshes) => {\n          meshes.forEach(m => {\n            m.setParent(this.viewedObject);\n          });\n          this.viewedObject.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n        });\n      } else if (fileName.endsWith(\".png\") || fileName.endsWith(\".jpg\")) {\n        this.url = getTexture(fileName);\n\n        this.fileType = FileType.Texture;\n        //Load the texture\n        var fullName = Engine.getFullName(fileName, FileType.Texture);\n        this.img.source = this.url;\n        this.img.widthInPixels = 150;\n      } else {\n        Debug.Log(\"Unrecognized file-format.\");\n        return;\n      }\n      if (!this.url) {\n        Debug.Log(\"Unrecognized filename\");\n        return;\n      }\n      downloadButton.isVisible = true;\n      urlButton.isVisible = true;\n      this.isValidFile = true;\n    });\n  }\n\n  RecreateTextureImage () \n  {\n    this.img?.dispose();\n    this.img = new BABYLON.GUI.Image(\"TextureViewer\");\n    this.img.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.img.width = \"150px\";\n    this.img.height = \"150px\";\n    this.img.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM;\n    this.addControl(this.img);\n  }\n\n  OnDispose() {\n    this.onDisposeObservable.removeCallback(this.OnDispose);\n    this.scene.dispose();\n  }\n\n}\n",
            "Color": "class Color  {\n\n    constructor (r :number = 1, g :number = 1, b : number = 1)\n    {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n\n    @SerializeField\n    public r : number;\n    @SerializeField\n    public g : number;\n    @SerializeField\n    public b : number;\n\n\n    public static UtoB (u: Color, b : BABYLON.Color3) : BABYLON.Color3\n    {\n        b.r = u.r;\n        b.g = u.g;\n        b.b = u.b\n        return b;\n    }\n\n    public static BtoU  (b : BABYLON.Color3, u : Color) : Color\n    {\n        u.r = b.r;\n        u.g = b.g;\n        u.b = b.b;\n        return u;\n    }\n}\n",
            "PrefabInspector": "class PrefabInspector extends BABYLON.GUI.StackPanel {\n\n   propertiesPanel: BABYLON.GUI.StackPanel;\n\n   name: string;\n\n   constructor(prefabName: string) {\n      super()\n\n      this.name = prefabName;\n\n      var prefab = Prefab.Get(prefabName);\n\n      this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n      var nameField = new BABYLON.GUI.TextBlock(\"\", prefabName);\n\n      nameField.paddingLeft = \"5px\";\n      nameField.style = UnionEditor.fontStyleBold;\n      nameField.color =  UnionEditor.style.textColor.toHexString();\n      nameField.width = \"160px\";\n      nameField.heightInPixels = 25;\n      nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n      nameField.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n      \n      this.heightInPixels = 400;\n      this.paddingTopInPixels = 3;\n      this.paddingBottomInPixels = 5;\n\n      this.propertiesPanel = new BABYLON.GUI.StackPanel();\n      this.propertiesPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n      this.propertiesPanel.isVisible = true;\n      \n      this.addControl(this.propertiesPanel);\n\n      this.propertiesPanel.addControl(nameField);\n\n      var createPrefabButton = UnionEditor.CreateButton(\"Create\");\n      createPrefabButton.widthInPixels = 100;\n      this.propertiesPanel.addControl(createPrefabButton);\n      createPrefabButton.onPointerClickObservable.add((ev) => {\n         Prefab.Create(prefabName);\n      });\n\n      /*\n      var savePrefabButton = UnionEditor.CreateButton(\"Save Selection\");\n      this.propertiesPanel.addControl(savePrefabButton);\n      savePrefabButton.onPointerClickObservable.add((ev) => {\n         if (!EditorSelection.currentSelectedGameObject)\n         {\n            Debug.Log(\"Select a GameObject to save\");\n         } else {\n            var prefabJson = Serializer.ToJSON(EditorSelection.currentSelectedGameObject);\n            savePrefab(prefabName, prefabJson);\n         }\n      });\n      */\n\n      var openPrefabButton = UnionEditor.CreateButton(\"Open Prefab\");\n      this.propertiesPanel.addControl(openPrefabButton);\n      openPrefabButton.onPointerClickObservable.add((ev) => {\n         if (SceneManager.GetActiveScene().isDirty)\n         {\n            alert(\"Save scene first you dumb dumb!\");\n         } else {\n            SceneManager.LoadPrefab(prefabName);\n         }\n      });\n   }\n\n\n}\n",
            "Prefab": "class Prefab  {\n\n  public static Get (name : string) : string\n  {\n    return getPrefab(name);\n  }\n\n  public static SimpleName (name : string)\n  {\n    return name.slice(0, -7);\n  }\n\n  public static Create (name : string, goParent : GameObject = null) : GameObject\n  {\n    var prefabJson = getPrefab(name);\n\n    var parent = goParent ? goParent  : new GameObject();\n    parent.name = this.SimpleName(name) + \" (Clone)\";\n    parent.prefabParent = parent;\n    parent.prefabName = name;\n    var clone : Scene = Serializer.FromJSON(prefabJson);\n    clone.rootObjs.forEach((go : GameObject) => {\n      go.transform.SetParent(parent.transform, false);\n      go.prefabParent = parent;\n    });\n\n    return parent;\n  }\n}\n",
            "Shadows": "class Shadows {\n\n  private static shadowGenerators : BABYLON.ShadowGenerator[] = new Array();\n\n  private static casters : BABYLON.Mesh[] = new Array();\n\n  public static RemoveCastingMesh (m : BABYLON.Mesh)\n  {    \n    const index = this.casters.indexOf(m);\n    if (index > -1) {\n      var removedMesh = this.casters.splice(index, 1)[0];\n      this.shadowGenerators.forEach((gen) => {\n        gen.removeShadowCaster(removedMesh);\n      });\n    }\n  }\n\n  public static AddCastingMesh(m : BABYLON.Mesh)\n  {\n    const index = this.casters.indexOf(m);\n    if (index == -1) {\n      this.casters.push(m);\n      this.shadowGenerators.forEach((gen) => {\n        gen.addShadowCaster(m, true);\n      });\n    }\n  }\n\n  public static AddLight (l : Light)\n  {\n    var generator = new BABYLON.ShadowGenerator(1024, l.light, true);\n    generator.useExponentialShadowMap = true;  \n    this.shadowGenerators.push(generator);\n    //We add all previous casters to our new light\n    this.casters.forEach((m : BABYLON.Mesh) => {\n      generator.addShadowCaster(m, true);\n    });\n  }\n\n  public static RemoveLight (l : Light)\n  {\n    let index = -1;\n    this.shadowGenerators.forEach((gen) => {\n      if (gen.getLight() == l.light)\n      {\n        index = this.shadowGenerators.indexOf(gen);\n        gen.dispose();    \n      }\n    });\n\n    //Remove the generator from our array\n    if (index > -1) {\n      this.shadowGenerators.splice(index, 1);\n    }\n  }\n\n  //Start is called before the first frame update\n  static Init() {\n    \n    //Create main light\n    var light1 = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), Engine.scene);\n    light1.intensity = .3;\n    \n  }\n}\n",
            "Cursor": "class Cursor {\n\n  static Init ()\n  {\n     \n    Engine.editorScene.onPrePointerObservable.add((ev) => {\n      if (!Engine.current.isPointerLock && Cursor.lockState == CursorLockMode.Locked)\n      {\n        Cursor.lockState = CursorLockMode.None;\n      }\n\n      //When the cursor is unlocked somehow, we reset it to none here      \n      if (Cursor.lockState == CursorLockMode.Locked)\n      {\n        ev.skipOnPointerObservable = true;\n      }\n    });\n  }\n\n\n  static get lockState (): CursorLockMode{\n    return this._lockState;\n  }\n\n  static set lockState(value:CursorLockMode)\n  {\n    Cursor._lockState = value;\n    switch(value)\n    {\n      case CursorLockMode.Locked:\n        Engine.current.enterPointerlock();\n      break;\n      case CursorLockMode.None:\n        Engine.current.exitPointerlock();\n      break;\n      case CursorLockMode.Confined:\n        Debug.Log(\"Confined lockmode is currently not supported\")\n    }\n  }\n\n  private static _lockState : CursorLockMode;\n}\n\nenum CursorLockMode\n{\n  Locked,\n  Confined,\n  None\n}"
        },
        "model": {
            "asteroid.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.asteroid.obj"
            },
            "ship.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ship.obj"
            },
            "ball.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ball.obj"
            },
            "virus.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.virus.obj"
            },
            "crate.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.crate.obj"
            },
            "fence.obj": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.fence.obj"
            }
        },
        "texture": {
            "laser.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.laser.png"
            },
            "nebula.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.nebula.jpg"
            },
            "asteroid.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.asteroid.jpg"
            },
            "ship.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ship.jpg"
            },
            "Grass.jpg": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Grass.jpg"
            },
            "Wood.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Wood.png"
            },
            "synty.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.synty.png"
            },
            "play_button.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.play_button.png"
            },
            "pause_button.png": {
                "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.pause_button.png"
            }
        },
        "sound": {},
        "library": {},
        "scene": {
            "MainScene.scn": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Sphere\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":2.390965461730957,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":5130,\n               \"ser_children\":[\n                  {\n                     \"t\":\"GameObject\",\n                     \"name\":\"Sphere\",\n                     \"components\":[\n                        {\n                           \"t\":\"Transform\",\n                           \"_position\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":0\n                           },\n                           \"_eulerAngles\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":0\n                           },\n                           \"_scale\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":1,\n                              \"y\":1,\n                              \"z\":1\n                           },\n                           \"uniqueId\":5128,\n                           \"ser_children\":[\n                              \n                           ]\n                        },\n                        {\n                           \"t\":\"Renderer\",\n                           \"meshName\":\"sphere\",\n                           \"materialName\":\"\",\n                           \"scale\":1,\n                           \"castShadows\":true,\n                           \"receiveShadows\":false\n                        },\n                        {\n                           \"t\":\"SphereCollider\",\n                           \"_isTrigger\":false,\n                           \"_layer\":1,\n                           \"_layerMask\":1,\n                           \"radius\":1\n                        },\n                        {\n                           \"t\":\"Rigidbody\",\n                           \"_mass\":10,\n                           \"_restitution\":0.5,\n                           \"_friction\":0.5,\n                           \"_isKinematic\":false\n                        }\n                     ],\n                     \"prefabName\":null\n                  }\n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"sphere\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Sphere\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1.529078094873864,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":5138,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"sphere\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Floor\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":-2.3115310668945312,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":9.618080716002204,\n                  \"y\":0.5060179091366171,\n                  \"z\":7.6483267313493\n               },\n               \"uniqueId\":5146,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":false,\n               \"receiveShadows\":true\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Sphere\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":-0.4968818724155426,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":5154,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"sphere\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"SphereCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"radius\":1\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Light\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":20.10999999999981,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":44.999999999999986,\n                  \"y\":-45.00000000000002,\n                  \"z\":-4.72288274471469e-14\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":5156,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Light\",\n               \"intensity\":0.7\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":-10\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":2.8499999999999983\n               },\n               \"uniqueId\":5159,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Camera\"\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"Box\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0.9341810101045658,\n                  \"z\":0.02013990841805935\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":5161,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_restitution\":0.5,\n               \"_friction\":0.5,\n               \"_isKinematic\":false\n            },\n            {\n               \"t\":\"MainGame\"\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}",
            "TEST.scn": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":2.1333043575286865,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":797,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}"
        },
        "material": {
            "Red.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":0,\"b\":0},\"mainTexture\":\"\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}",
            "Asteroid.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"asteroid.jpg\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}",
            "Grass.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"Grass.jpg\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":5,\"vScale\":5,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}",
            "Yellow.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":0.792158236747296,\"b\":0},\"mainTexture\":\"\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}",
            "Synty.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"synty.png\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":9.260000000000003,\"roughness\":20.02000000000001}",
            "Flip.mat": "//material: Flip.mat\n\n"
        },
        "prefab": {
            "Test.prefab": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0.11797763309128564,\n                  \"y\":-2.3257447407301215,\n                  \"z\":1\n               },\n               \"uniqueId\":1721,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}",
            "Robot.prefab": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9638,\n               \"ser_children\":[\n                  \n               ]\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0.7628781554881394,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-0.35345975736876584,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9639,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-0.35345975736876584,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9648,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      },\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0.36953156155958977,\n                  \"y\":0.948546214173521,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":-0.35345975736876584,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":9657,\n               \"ser_children\":[\n                  \n               ]\n            },\n            {\n               \"t\":\"Renderer\",\n               \"meshName\":\"box\",\n               \"materialName\":\"\",\n               \"scale\":1,\n               \"castShadows\":true,\n               \"receiveShadows\":false\n            },\n            {\n               \"t\":\"BoxCollider\",\n               \"_isTrigger\":false,\n               \"_layer\":1,\n               \"_layerMask\":1,\n               \"_size\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"_center\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               }\n            },\n            {\n               \"t\":\"MainGame\"\n            },\n            {\n               \"t\":\"Rigidbody\",\n               \"_mass\":10,\n               \"_isKinematic\":false\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}"
        }
    }
}