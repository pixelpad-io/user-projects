{
    "assets": {
        "code": [
            {
                "main": "/*\r\nReminders for PixelPAD Union\r\n\r\n- Instance variables need to be initialized! Even basic vars such as integers/strings\r\n- There are no structs. Basic objects such as Vectors pass by reference by default\r\n- Specific Vectors like position, rotation can be set by simply setting their individual variables.\r\n    e.g. transform.position.x = 4 works\r\n- Instantiate is used to create GameObjects with a specific Component or as a prefab\r\n\r\n*/\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n\r\n*/\r\n"
            },
            {
                "EngineDir": [
                    {
                        "Serializer": "class Serializer {\n  public static isCreatingGameObject;\n  public static isSettingParent;\n\n  private static serializedProperties: Map<any, SerializedProperty[]> = new Map();\n  //Some properties are serialized but should not show in inspector\n  private static hiddenProperties: Map<any, string[]> = new Map();\n\n  public static enumTypeToValues : Map<any, string[]> = new Map ();\n\n  private static isSerializingPrefab;\n\n\n  static RegisterSerialized(target: any, property: any, enumType : any = null): void {\n    let keys: SerializedProperty[] = this.serializedProperties.get(target);\n    if (!keys) {\n      keys = [];     \n      this.serializedProperties.set(target, keys);\n    }\n    keys.push({name : property, propType : enumType});\n  }\n\n  static RegisterHideInInspector(target: any, property: any): void {\n    let keys: string[] = this.hiddenProperties.get(target);\n    if (!keys) {\n      keys = [];\n      this.hiddenProperties.set(target, keys);\n    }\n    keys.push(property);\n  }\n\n  //Returns all serialized properties of an object, including it's base classes\n  static GetProperties(objType: any, includeHidden: boolean): SerializedProperty[] {\n    let keys: SerializedProperty[] = new Array();\n\n    let baseClass: any = Object.getPrototypeOf(objType);\n\n    if (baseClass) {\n      //Recursion to append to keys.\n      keys = keys.concat(this.GetProperties(baseClass, includeHidden));\n    }\n\n    //If it's serialized, but not hidden...\n    if (this.serializedProperties.has(objType)) {\n      //The props of only this class (not using inheritance)\n      let props = this.serializedProperties.get(objType);\n      //Copy over the array (is this the best approach?)\n      props.forEach((value: SerializedProperty) => {\n        //if includeHidden (means ignore HideInInspector refs) OR if it's not a hidden property\n        if (includeHidden || !(this.hiddenProperties.has(objType) && this.hiddenProperties.get(objType).indexOf(value.name) != -1)) {\n          keys.push(value)\n        }\n      }\n      );\n    }\n\n\n    return keys;\n  }\n\n  static GetPropValues(target: any, includeHidden: boolean): Map<SerializedProperty, any> {\n    //The map that we return\n    var propValues: Map<SerializedProperty, any> = new Map();\n\n    var targetObjectType = Object.getPrototypeOf(target);\n\n    let keys: SerializedProperty[] = this.GetProperties(targetObjectType, includeHidden);\n    //Fill up the map with those strings\n    for (const property of keys) {\n      propValues.set(property, target[property.name]);\n    }\n\n    return propValues;\n  }\n\n  static nl: NextLine;\n\n  static FromJSON(jsonData: string, reportErrors : boolean = true): any {\n    try {\n      //A cast is only a hint for static code analysis but doesn't have any effect at runtime.\n      var jsonObject: any = JSON.parse(jsonData);\n\n      var realObject: any = this.CreateFromJSObj(jsonObject);\n\n      return realObject;\n    } catch (e) {\n      if (reportErrors)\n      {\n        Debug.Log(\"Error creating JSON Object: \" + e);\n      }\n      return null;\n    }\n\n    return realObject;\n  }\n\n  private static IsBasicType (value : any) : boolean\n  { \n    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n  }\n\n  //owner can be either a Transform (for children GameObjects) or a GameObject (for components)\n  static CreateFromJSObj(jsObj: any, propDesc: PropertyDescriptor = null, owner: BaseObject = null): any {\n    if (jsObj == null) {\n      return null;\n    }\n    var objType: string = jsObj.t;\n\n    var isCreatingPrefab = false;\n\n    if (objType == \"GameObject\") {\n      if (jsObj.prefabName)\n      {\n        isCreatingPrefab = true;\n      }\n      //Used in the GameObject constructor to not create default components when Serializing.\n      this.isCreatingGameObject = true;\n    }\n\n    //instance creation here. Instance might not exist so we just return null in that case\n    try {\n    var obj: any = eval(\"new \" + objType + \"();\");\n    } catch (e) {Debug.Log(e);\n    return null;}\n    this.isCreatingGameObject = false;\n\n    var props = this.GetProperties(obj, true);\n\n    var children: Transform[] = new Array;\n\n    props.forEach((prop: SerializedProperty) => {\n\n      var value = null;\n      try {\n        var p: PropertyDescriptor = Object.getOwnPropertyDescriptor(jsObj, prop.name);\n        value = p.value;\n      } catch (error) {\n        //No need to print. This means that the serialized field in the object, could not be found in the JSON\n        //This can simply mean that the JSON did not yet contain that serialized property (e.g. if it was just added)\n        return;\n      }\n      if (value === null) {\n        //Do nothing (variable can remain null)\n      } else if (this.IsBasicType(value)) {\n        Object.defineProperty(obj, prop.name, p);\n\n      } else if (value instanceof Array) {\n        var isc: boolean = obj instanceof GameObject && prop.name == \"components\";\n\n        for (var i: number = 0; i < value.length; i++) {\n          //Basic variables such as strings & bools are already good\n          if (this.IsBasicType(value[i]))\n          {\n            continue;\n          }\n          value[i] = (this.CreateFromJSObj(value[i], null, isc ? obj : null));\n        }\n\n        //We store the 'children' array for later.\n        if (obj instanceof Transform && prop.name == \"ser_children\") {\n          //Removes all null elements from the list.\n          //Due to the serialization process more and more null elements get added\n          children = value;    \n        }\n\n        //If isComponent, we don't need to redefine the 'components' array since we already push the \n        //components through their Awake call.\n        if (!isc) {\n          Object.defineProperty(obj, prop.name, p);\n        }\n      } else {\n        //When we use defineProperty, it is ESSENTIAL we set a PropertyDescriptor\n        //If we only set the value, it will override access modifiers\n        //E.g. after setting, a read+write variable might just become read only 0_o\n        Object.defineProperty(obj, prop.name, this.CreateFromJSObj(value, p));\n      }\n    });\n\n    //Components need to have Awake called when they're initiated         \n    if (owner) {\n      obj.InternalPreAwake(owner);\n      //Transform component needs it's awakening called beforehand.\n      if (objType == \"Transform\")\n      {\n        obj.InternalAwake(owner);\n        //AFTER the Transform has 'awoken' we can set the children to it.\n        //The order here is:\n        //1) Start Transform Creation\n        //2) Create Children\n        //3) Finish Transform Creation\n        //4) Set Children to be parented to Transform\n        for (var i: number = 0; i < children.length; i++) {\n          this.isSettingParent = true;\n          if (children[i]?.transform) {\n            children[i].transform.SetParent(obj, false);\n          }\n          this.isSettingParent = false;\n        }\n      }\n      \n    }\n\n    if (isCreatingPrefab)\n    {\n      Prefab.Create(jsObj.prefabName, obj);\n    }\n\n    if (objType == \"GameObject\") {\n      var go = obj as GameObject;\n      go.components.forEach(c => {\n        //Skip the transform component (already handled above)\n        if (c.transform != c)\n        {\n          c.InternalAwake(go);\n        }\n      });\n    }\n\n    if (propDesc) {\n      propDesc.value = obj;\n      return propDesc;\n    }\n\n    return obj;\n  }\n\n  static ToJSON(target: any, prettyPrint: boolean = false): string {\n\n    this.nl = new NextLine(prettyPrint);\n    return this.GetPropertyJSON(target);\n  }\n\n  private static GetPropertyJSON(target: any): string {\n    \n    var data: string = \"\";\n\n    if (!target)\n    {\n      return \"null\";\n    }\n\n    \n\n    var typeName = target.constructor.name;\n    var isParentPrefab = false;\n    if (typeName == \"GameObject\")\n    {\n      if (target.prefabParent)\n      {\n        if (target.prefabParent == target)\n        {\n          isParentPrefab = true;\n        }\n        else \n        {\n          //If it has a prefab Parent (and it's not the prefab parent itself)\n          //we return null since we will be loading this from the prefab.\n          return \"null\";\n        }\n      }\n    }\n\n    //Shortcut    \n    var nl = this.nl;\n\n    data += \"{\" + nl.Tab();\n\n\n    data += \"\\\"t\\\":\\\"\" + typeName + \"\\\"\";\n    \n\n    var propValues: Map<SerializedProperty, any> = this.GetPropValues(target, true);\n    propValues.forEach((value: any, key: SerializedProperty) => {\n      //Too hacky?\n      if (this.isSerializingPrefab)\n      {\n        //If it's the Prefab\n        if (isParentPrefab && key.name == \"name\")\n        {\n          value = target.prefabName;\n        }\n      }\n      data += \",\" + nl;\n      data += \"\\\"\" + key.name + \"\\\"\" + \":\";\n      if (value === null || value === undefined) {\n        data += \"null\";\n      } else if (value instanceof Array) {\n        data += \"[\" + nl.Tab();\n        for (var j: number = 0; j < value.length; j++) {\n          //TODO This is WET!\n          if (typeof value[j] == 'number' || typeof value[j] == 'boolean') {\n            data += value[j];\n          }\n          else if (typeof value[j] == 'string') {\n            data += \"\\\"\" + value[j] + \"\\\"\";\n          } else {\n            data += this.GetPropertyJSON(value[j]);\n          }\n          \n          if (j < value.length - 1) {\n            data += \",\" + nl;\n          }\n        }\n        data += (nl.ShiftTab() + \"]\");\n      }\n      else if (typeof value == 'number' || typeof value == 'boolean') {\n        data += value;\n      }\n      else if (typeof value == 'string') {\n        data += \"\\\"\" + value + \"\\\"\";\n      } else {\n        //Assuming everything can be processed.  \n        data += nl + this.GetPropertyJSON(value);\n      }\n    });\n\n    data += nl.ShiftTab() + \"}\";\n\n    return data;\n  }\n}\n\nclass NextLine {\n\n  private nl: string = \"\\n\";\n\n  private tab = \"   \";\n\n  constructor(_prettyPrint: boolean) {\n    this.prettyPrint = _prettyPrint;\n  }\n\n\n  prettyPrint: boolean = true;\n\n  ShiftTab(): string {\n    if (this.nl.endsWith(this.tab)) {\n      this.nl = this.nl.substring(0, this.nl.length - this.tab.length);\n    }\n    return this.toString();\n  }\n\n  Tab(): string {\n    this.nl += this.tab;\n    return this.toString();\n  }\n\n  toString(): string {\n    if (this.prettyPrint) {\n      return this.nl;\n    }\n\n    return \"\";\n  }\n}\n\nclass SerializedProperty\n{\n  name : string = \"\";\n  //Currently propType is only used for enums. It might have other use in the future?\n  propType : any;\n}\n\nfunction SerializeEnumField (enumType : any)\n{\n  function actualDecorator(target: Object, property: string | symbol): void {\n    Serializer.RegisterSerialized(target, property, enumType);   \n  }\n  // return the decorator\n  return actualDecorator;\n}\n\nfunction SerializeConditionalField(condition : boolean) {    \n  \n  function actualDecorator(target: Object, property: string | symbol): void {\n    if (condition)\n    {\n      Serializer.RegisterSerialized(target, property);\n    }   \n  }\n  // return the decorator\n  return actualDecorator; \n}\n\n\nfunction SerializeField(target: Object, property: string | symbol) {    \n  Serializer.RegisterSerialized(target, property);    \n}\n\n\nfunction HideInInspector(target: any, propertyKey: string) {\n  Serializer.RegisterHideInInspector(target, propertyKey);\n\n}"
                    },
                    {
                        "Engine": "var ENABLE_EDITOR: boolean = true;\r\n\r\nfunction uuidv4() {\r\n    //@ts-ignore\r\n  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\r\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\r\n  );\r\n}\r\n\r\nclass Engine {\r\n\r\n    public static current: BABYLON.Engine;\r\n    public static scene: BABYLON.Scene;\r\n    public static editorScene: BABYLON.Scene;\r\n    public static isPlaying: boolean = false;\r\n    public static isExitingPlayMode: boolean = false;\r\n\r\n    public static gizmoManager : BABYLON.GizmoManager;\r\n\r\n    public static targetFrameRate = 60;\r\n\r\n\r\n    //Can be adjusted for testing, specifically useful for testing memory leaks\r\n    public static get nFramesPerRenderLoop(): number {\r\n        return this._nFramesPerRenderLoop;\r\n    }\r\n\r\n    public static set nFramesPerRenderLoop(value: number) {\r\n        Debug.Log(\"WARNING: nFramesPerRenderLoop is set to \" + value + \". This should only happen during testing!\");\r\n        this._nFramesPerRenderLoop = value;\r\n    }\r\n\r\n    private static _nFramesPerRenderLoop: number = 1;\r\n\r\n    public static canvas: HTMLCanvasElement;\r\n\r\n    public static toBeDestroyed: SceneObject[];\r\n\r\n    public static meshToObject: Map<number, GameObject>;\r\n\r\n    public static editorTypes: string[] = new Array();\r\n\r\n    public static get cursor() {\r\n        return Engine.editorScene.defaultCursor;\r\n    };\r\n\r\n\r\n    public static set cursor(value: string) {\r\n        Engine.editorScene.defaultCursor = value;\r\n    };\r\n\r\n    public static onUpdate: BABYLON.Observable<number>;\r\n\r\n    public static scripts: string[] = new Array();\r\n\r\n    public static startScene: string;\r\n\r\n\r\n    public static IsEditorType(value: Component): boolean {\r\n        var isEditorType: boolean = this.editorTypes.indexOf(value.constructor.name) > -1;\r\n        return isEditorType;\r\n    }\r\n\r\n    public static isSwitchingToPlayMode: boolean;\r\n\r\n    public static SwitchToPlayMode() {\r\n        Engine.startScene = SceneManager.GetActiveScene().name;\r\n        SceneManager.ReloadCurrentScene();\r\n        this.isSwitchingToPlayMode = true;\r\n    }\r\n\r\n    public static StopPlayMode() {\r\n        //Reloading the current scene, which should reset if not playing\r\n        SceneManager.LoadScene(Engine.startScene);\r\n\r\n        Engine.isExitingPlayMode = true;\r\n        Engine.isPlaying = false;\r\n    }\r\n\r\n    public static ShouldRun(obj: SceneObject): boolean {\r\n        return Engine.isPlaying || Engine.IsEditorType(obj)\r\n    }\r\n\r\n    public static OnPlayButton(evt: CustomEvent) {\r\n        var buttonText: string = evt.detail.buttonText;\r\n        //When the recompile button is clicked, we first remove all the old listeners\r\n        PixelPADEvents.ClearAllListeners();\r\n        document.removeEventListener(\"playClicked\", Engine.OnPlayButton);\r\n    }\r\n\r\n}\r\n\r\nenum FileType {\r\n    Model = 1,\r\n    Texture,\r\n    Sound\r\n}\r\n\r\n\r\n\r\nclass Playground {\r\n\r\n    public static CreateScene(engine: BABYLON.Engine, canvas: HTMLCanvasElement): BABYLON.Scene {\r\n\r\n        Engine.current = engine;\r\n\r\n        PixelPADEvents.AddAllListeners();\r\n        document.addEventListener(\"playClicked\", Engine.OnPlayButton);\r\n\r\n\r\n        Engine.canvas = canvas;\r\n        // This creates a basic Babylon Scene object (non-mesh)\r\n        Engine.scene = new BABYLON.Scene(engine);\r\n\r\n        if (ENABLE_EDITOR) {\r\n            //Since Babylon 4.2, the gizmoManager needs to be crerated BEFORE the editorScene is created \r\n            //Odd bug but this resolves it.\r\n            Engine.gizmoManager = new BABYLON.GizmoManager(Engine.scene)\r\n\r\n            Engine.editorScene = new BABYLON.Scene(engine);\r\n            Engine.editorScene.autoClear = false;\r\n            //Used for editor input - should not be \r\n            Engine.editorScene.actionManager = new BABYLON.ActionManager(Engine.editorScene);\r\n\r\n        }\r\n\r\n        Engine.scene.clearColor = BABYLON.Color4.FromColor3(new BABYLON.Color3(0, 0, 0));\r\n\r\n\r\n        //Physics are handled in the Physics class\r\n        var physEngine = new BABYLON.CannonJSPlugin(false);\r\n        Engine.scene.enablePhysics(BABYLON.Vector3.Zero(), physEngine);\r\n        physEngine.setTimeStep(1 / 60);\r\n\r\n        Engine.meshToObject = new Map();\r\n        Engine.toBeDestroyed = new Array();\r\n\r\n        Engine.onUpdate = new BABYLON.Observable();\r\n\r\n        Engine.scripts = Engine.scripts.concat(getScripts());\r\n\r\n        Time.Init();\r\n        Cursor.Init();\r\n        Material.Init();\r\n        MeshLoader.Init();\r\n        Physics.Init();\r\n        Input.Init();\r\n        Project.Init();\r\n        SceneManager.Init();\r\n        //Create Shadows and Main Directional Light \r\n        Lighting.Init();\r\n\r\n        \r\n\r\n        if (ENABLE_EDITOR) {\r\n            UnionEditor.Init();\r\n        }\r\n        else {\r\n            Engine.isPlaying = true;\r\n        }\r\n\r\n        var sceneName = null;\r\n\r\n        //In editor mode, see if we can get our last loadedSceneOrPrefab\r\n        //Currently not working! Need option to save data outside of engine.\r\n        if (!Engine.isPlaying) {\r\n            sceneName = Project.data.loadedSceneOrPrefab;\r\n        }\r\n\r\n        if (!sceneName) {\r\n            sceneName = getFirstSceneName();\r\n        }\r\n\r\n        if (!sceneName) {\r\n            //In non-editor mode, we try to load a scene from the library\r\n            if (Engine.isPlaying) {\r\n                sceneName = getFirstLibrarySceneName();\r\n            }\r\n        }\r\n\r\n        \r\n        if (sceneName) {\r\n            SceneManager.LoadScene(sceneName);\r\n        } else {\r\n            Debug.Log(\"No scene was found! Without a scene in your game you will get unexpected errors!\")\r\n        }\r\n\r\n\r\n\r\n        setTimeout(() => {\r\n            Engine.current.stopRenderLoop();\r\n\r\n            Engine.current.runRenderLoop(() => {\r\n                Engine.scene.render();\r\n                if (ENABLE_EDITOR) {\r\n                    Engine.editorScene.render();\r\n                }\r\n            });\r\n        });\r\n\r\n        Engine.scene.onBeforeStepObservable.add(() => {\r\n            var scene = SceneManager.GetActiveScene();\r\n            if (scene) {\r\n\r\n                for (var i = scene.objs.length - 1; i >= 0; i--) {\r\n                    var obj = scene.objs[i];\r\n                    obj.InternalFixedUpdate();\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n        });\r\n\r\n        // Game/Render loop\r\n        Engine.scene.onBeforeRenderObservable.add(() => {\r\n            Time.Update();\r\n\r\n            for (var j = 0; j < Engine.nFramesPerRenderLoop; j++) {\r\n\r\n                if (ENABLE_EDITOR) {\r\n                    UnionEditor.Update();\r\n                }\r\n\r\n                if (Engine.isSwitchingToPlayMode) {\r\n                    Engine.isSwitchingToPlayMode = false;\r\n                    Engine.isPlaying = true;\r\n                    return;\r\n                }\r\n\r\n                var scene = SceneManager.GetActiveScene();\r\n\r\n                if (scene) {\r\n\r\n\r\n                    //Start is not called directly after Awake\r\n                    //This should take care of any objects being created in the Start\r\n                    for (var i = 0; i < scene.newObjs.length; i++) {\r\n                        scene.newObjs[i].InternalStart();\r\n                    }\r\n                    scene.newObjs = new Array();\r\n\r\n                    for (var i = scene.objs.length - 1; i >= 0; i--) {\r\n                        var obj = scene.objs[i];\r\n                        obj.InternalUpdate();\r\n                    }\r\n\r\n                    Engine.onUpdate.notifyObservers(0);\r\n                }\r\n\r\n                Material.Update();\r\n\r\n                //Updates all 'just' pushed or released keys\r\n                Input.Update();\r\n\r\n                //Process detroyed objects\r\n                //Needs to be in this order so children are destroyed before parents\r\n                for (var i = 0; i < Engine.toBeDestroyed.length; i++) {\r\n\r\n                    var tbd = Engine.toBeDestroyed[i];\r\n                    tbd.InternalDestroy();\r\n                }\r\n\r\n                Engine.toBeDestroyed = new Array();\r\n\r\n                SceneManager.Update();\r\n\r\n                //Needed to check for destroying objects\r\n                if (Engine.isExitingPlayMode) {\r\n                    Engine.isExitingPlayMode = false;\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n        // Engine.scene.onPrePointerObservable.add((ev) => {\r\n        //     canvas.style.cursor = Engine.cursor;\r\n        // });\r\n\r\n        return Engine.scene;\r\n    }\r\n\r\n}\r\n\r\n//Some helper methods - just like Unity\r\n\r\nfunction Instantiate<T extends MonoBehaviour>(objType: string | (new () => T), startPosition: Vector3 = Vector3.Zero()): T {\r\n\r\n    return GameObject.Instantiate<T>(objType, startPosition);\r\n}\r\n\r\n\r\n\r\nfunction Destroy(obj) {\r\n    GameObject.Destroy(obj);\r\n}\r\n\r\nfunction print(info: any) {\r\n    Debug.Log(info);\r\n}\r\n\r\n//Attribute\r\nfunction ExecuteInEditMode(target: Function) {\r\n    Engine.editorTypes.push(target.prototype.constructor.name);\r\n}\r\n\r\n/** A helper class to break up a URL in baseUrl and fileName */\r\nclass URLResult {\r\n\r\n    public static Create(name: string, fileType: FileType): URLResult {\r\n        var result: URLResult = new URLResult();\r\n        var fullUrl: string = \"\";\r\n        switch (fileType) {\r\n            case FileType.Model:\r\n                fullUrl = getModel(name);\r\n                break;\r\n            case FileType.Texture:\r\n                fullUrl = getTexture(name);\r\n                break;\r\n            case FileType.Sound:\r\n                fullUrl = getSound(name);\r\n                break;\r\n            default:\r\n                //statements; \r\n                break;\r\n        }\r\n        if (!fullUrl) {\r\n            return result;\r\n        }\r\n\r\n        var splits = fullUrl.split('/');\r\n        result.fullName = splits.pop();\r\n        result.baseUrl = splits.join('/') + \"/\";\r\n        return result;\r\n    }\r\n\r\n    baseUrl: string;\r\n    fullName: string;\r\n}"
                    },
                    {
                        "BaseObject": "//script:BaseObject\nclass BaseObject extends Object\n{\n    public name : string;\n}"
                    }
                ]
            },
            {
                "Components": [
                    {
                        "SceneObject": "class SceneObject extends BaseObject {\n    prefabParent: GameObject;\n\n    public get markedForDestroy(): boolean {\n        return this._markedForDestroy || this.gameObject._markedForDestroy;\n    };\n\n    public set markedForDestroy(value: boolean) {\n        this._markedForDestroy = value;\n    }\n\n    private _markedForDestroy: boolean = false;\n\n    public hasStarted : boolean = false;\n\n    public GetType(): string {\n        return this.constructor.name;\n    }\n\n    public get transform(): Transform {\n        return this.gameObject.transform;\n    }\n\n    public get renderer(): Renderer {\n        return this.gameObject.renderer;\n    }\n\n    public get gameObject(): GameObject {\n        return this._gameObject;\n    }\n\n    private _gameObject: GameObject;\n\n\n    InternalPreAwake(go: GameObject) {\n        SceneManager.MarkSceneAsDirty();\n        this._gameObject = go;\n        SceneManager.GetActiveScene().newObjs.push(this);\n    }\n\n    InternalAwake(go: GameObject) {\n        if (Engine.isPlaying || Engine.IsEditorType(this)) {\n            //User implemented so needs a try-catch\n            try {\n                this.Awake();\n            } catch (e) {\n                Debug.Log(e);\n            }\n        }\n    }\n\n    Awake() { }\n\n    InternalStart() {\n        if ((Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            this.hasStarted = true\n            try {                \n                this.Start();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        } \n    }\n\n    Start() { }\n\n    InternalUpdate() {\n        if (this.hasStarted && (Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.Update();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    Update() { }\n\n    InternalFixedUpdate() {\n        if (this.hasStarted && (Engine.isPlaying || Engine.IsEditorType(this)) && !this.markedForDestroy) {\n            try {\n                this.FixedUpdate();\n            } catch (e) {\n                Debug.Log(e, true);\n            }\n        }\n    }\n\n    FixedUpdate() {\n        \n    }\n\n    InternalDestroy() {\n        if (!Engine.isPlaying) {\n            SceneManager.MarkSceneAsDirty();\n        }\n\n        if (Engine.isExitingPlayMode || Engine.isPlaying || Engine.IsEditorType(this)) {\n            try {\n                //Debug.Log(\"Destroying \" + this.GetType())\n\n                this.OnDestroy();\n            } catch (e) {\n                Debug.Log(e);\n            }\n        }\n        //Remove from components array\n        const index = this.gameObject.components.indexOf(this);\n        if (index > -1) {\n            this.gameObject.components.splice(index, 1);\n        }\n    }\n\n    OnCollisionEnter(other: Collision) { }\n\n    OnTriggerEnter(otherCollider: Collider) { }\n\n    OnTriggerStay(otherCollider: Collider) { }\n\n    OnTriggerExit(otherCollider: Collider) { }\n\n    OnDestroy() { }\n\n    GetComponent<T extends Component>(objType: new () => T): T {\n        for (var i: number = 0; i < this.gameObject.components.length; i++) {\n            if (this.CheckType(this.gameObject.components[i], objType)) {\n                var x: T = this.gameObject.components[i] as T;\n                //No need to check if it's about to be destroyed.\n                //if (!x.markedForDestroy)\n                {\n                    return x;\n                }\n            }\n        }\n        return null;\n    }\n\n    GetComponentInParent<T extends Component>(objType: new () => T): T {\n        var c = this.GetComponent(objType);\n        if (!c && this.transform.parent) {\n            c = this.transform.parent.GetComponentInParent(objType);\n        }\n        return c;\n    }\n\n    GetComponentInChildren<T extends Component>(objType: new () => T): T {\n        var c = this.GetComponent(objType);\n        if (!c) {\n            for (var i = 0; i < this.transform.ser_children.length; i++) {\n                var child = this.transform.ser_children[i];\n                if (child)\n                    c = child.GetComponentInChildren(objType);\n                //Once found, stop looking\n                if (c)\n                    return c;\n            }\n        }\n        return c;\n    }\n\n    GetComponents<T extends Component>(objType: new () => T): T[] {\n        var arr = new Array();\n        for (var i: number = 0; i < this.gameObject.components.length; i++) {\n            if (this.CheckType(this.gameObject.components[i], objType)) {\n                var x: T = this.gameObject.components[i] as T;\n                //No need to check if it's about to be destroyed.\n                arr.push(x);\n            }\n        }\n        return arr;\n    }\n\n    GetComponentsInChildren<T extends Component>(objType: new () => T): T[] {\n        var arr = this.GetComponents(objType);\n        for (var i = 0; i < this.transform.ser_children.length; i++) {\n            var child = this.transform.ser_children[i];\n            if (child)\n                arr = arr.concat(child.GetComponentsInChildren(objType));\n        }\n\n        return arr;\n    }\n\n    GetComponentsInParent<T extends Component>(objType: new () => T): T[] {\n        var arr = this.GetComponents(objType);\n        if (this.transform.parent) {\n            arr = arr.concat(this.transform.parent.GetComponentsInParent(objType));\n        }\n\n        return arr;\n    }\n\n\n    //Recursive function to check for base-classes as well\n    CheckType(c: Component, objType: any): boolean {\n        if (c.GetType() === objType.name) {\n            return true;\n        }\n\n        //Stop looking after 'Component' \n        if (c.GetType() == \"Component\") {\n            return false;\n        }\n\n        return this.CheckType(Object.getPrototypeOf(c), objType);\n    }\n\n}"
                    },
                    {
                        "GameObject": "class GameObject extends SceneObject {\n\n    public static FindObjectOfType<T extends Component>(objType: new () => T): T {\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            var comp = objs[i].GetComponent(objType);\n            if (comp) {\n                return comp;\n            }\n        }\n\n        return null;\n    }\n\n    /**To find something*/\n    public static Find(name: string): GameObject {\n        var objs = SceneManager.GetActiveScene().objs;\n        for (var i: number = 0; i < objs.length; i++) {\n            if (objs[i].name == name) {\n                return objs[i];\n            }\n        }\n        return null;\n    }\n\n\n    @SerializeField\n    public name: string;\n\n    @SerializeField\n    components: Component[];\n\n    //TODO we should not refer to the prefab by name...\n    @SerializeField\n    prefabName: string;\n\n    //destroyOnLoad = true;\n\n    private get activeScene(): Scene {\n        return SceneManager.GetActiveScene();\n    }\n\n    //TODO Optimize\n    public get transform(): Transform {\n        return this.GetComponent(Transform);\n    }\n\n    public get activeSelf() {\n        return true;\n    }\n\n    public get activeInHierarchy() {\n        return true;\n    }\n\n    public SetActive(value: boolean) {\n\n    }\n    /** The renderer component is used to display the mesh. If no Renderer component exists, it's automatically added */\n    public get renderer(): Renderer {\n        if (this._renderer == null) {\n            this._renderer = this.GetComponent(Renderer);\n            if (this._renderer == null) {\n                this._renderer = this.AddComponent(Renderer);\n            }\n        }\n        return this._renderer;\n    }\n\n    private _renderer: Renderer;\n\n    public get objectPhysics(): ObjectPhysics {\n        if (this._objectPhysics == null) {\n            this._objectPhysics = new ObjectPhysics();\n            this._objectPhysics.Init(this);\n        }\n        return this._objectPhysics;\n    }\n\n    private _objectPhysics: ObjectPhysics;\n\n    static Destroy(obj: SceneObject) {\n        //Destroy all children before destroying other objects\n        if (obj instanceof GameObject && obj.transform) {\n            obj.transform.ser_children.forEach(c => {\n                if (c)\n                    GameObject.Destroy(c);\n            });\n        }\n        obj.markedForDestroy = true;\n        Engine.toBeDestroyed.push(obj);\n    }\n\n    static Instantiate<T extends MonoBehaviour>(objType: string | (new () => T), startPosition: Vector3 = Vector3.Zero()) {\n        //We first create an empty GameObject\n        var gameObject = null;\n        if (typeof objType === \"string\") {\n            gameObject = Prefab.Create(objType + \".prefab\");\n            gameObject.transform.position = startPosition.clone();\n            return gameObject;\n        }\n        else {\n            gameObject = new GameObject();\n\n            //We add this Component as a default one\n            var defaultComponent = gameObject.AddComponent(objType);\n\n            gameObject.name = \"GameObject (\" + defaultComponent.GetType() + \")\";\n\n            gameObject.transform.position = startPosition.clone();\n\n            return defaultComponent;\n        }\n    }\n\n    constructor() {\n        super();\n        this.InternalPreAwake(this);\n        this.name = \"GameObject\";\n\n        //When creating from a SerializedObject, it does not add these two default components.\n        if (!Serializer.isCreatingGameObject) {\n            //Every GameObject has a Transform & Renderer by default\n            this.AddComponent(Transform);\n            //this.AddComponent(Renderer);\n        }\n\n        this.InternalAwake(this);\n    }\n\n    AddComponent<T extends Component>(objType: (new () => T) | string): T {\n        var newComponent: T = null;\n        if (typeof objType == \"string\") {\n            newComponent = eval(\"new \" + objType + \"()\");\n        } else {\n            newComponent = new objType();\n        }\n        newComponent.InternalPreAwake(this);\n        newComponent.InternalAwake(this);\n        return newComponent;\n    }\n\n    OnCollisionEnter(otherCollider: Collision) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnCollisionEnter(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerEnter(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerEnter(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerStay(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerStay(otherCollider);\n            }\n        }\n    }\n\n    OnTriggerExit(otherCollider: Collider) {\n        if (!this.markedForDestroy) {\n            for (var i = 0; i < this.components.length; i++) {\n                this.components[i].OnTriggerExit(otherCollider);\n            }\n        }\n    }\n\n    InternalPreAwake(go: GameObject) {\n        this.components = new Array();\n        super.InternalPreAwake(go);\n        this.activeScene.objs.push(this);\n        this.activeScene.rootObjs.push(this);\n    }\n\n    InternalStart() {\n        super.InternalStart();\n    }\n\n    InternalUpdate() {\n        super.InternalUpdate();\n        for (var i = 0; i < this.components.length; i++) {\n            this.components[i].InternalUpdate();\n        }\n    }\n\n    InternalFixedUpdate() {\n        super.InternalFixedUpdate();\n        for (var i = 0; i < this.components.length; i++) {\n            this.components[i].InternalFixedUpdate();\n        }\n    }\n\n    InternalDestroy() {\n\n\n        for (var i = this.components.length - 1; i >= 0; i--) {\n            this.components[i].InternalDestroy();\n        }\n\n        if (this._objectPhysics) {\n            this._objectPhysics.OnDestroy();\n        }\n\n        //Remove from objects array\n        const index = this.activeScene.objs.indexOf(this);\n        if (index > -1) {\n            this.activeScene.objs.splice(index, 1);\n        }\n        const index2 = this.activeScene.rootObjs.indexOf(this);\n        if (index2 > -1) {\n            this.activeScene.rootObjs.splice(index2, 1);\n        }\n    }\n}\n\n/*\nfunction DontDestroyOnLoad (obj : SceneObject)\n{\n    obj.gameObject.destroyOnLoad = false;\n}\n*/"
                    },
                    {
                        "Component": "class Component extends SceneObject\n{   \n    public static isc : boolean = true;\n\n    get name ()\n    {\n        return this.gameObject.name;\n    }\n\n    set name (value : string)\n    {\n        this.gameObject.name = value;\n    }\n\n   InternalPreAwake (go : GameObject)\n   {\n       go.components.push(this);  \n       super.InternalPreAwake(go);       \n   }\n\n   InternalDestroy ()\n   {\n       super.InternalDestroy()\n   }\n}\n\n//Attribute that is used to Register a Script as a component\n//This is used as an addition to all scripts that are already registered through the Script name\nfunction RegisterAsComponent(target: Function) {\n    Engine.scripts.push(target.prototype.constructor.name);\n}"
                    },
                    {
                        "MonoBehaviour": "class MonoBehaviour extends Component \r\n{\r\n\r\n}\r\n"
                    },
                    {
                        "Renderer": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Renderer extends Component {\n\n    public onChangedMesh: BABYLON.Observable<number>;\n\n    private meshes: BABYLON.Mesh[] = new Array();\n    @SerializeField\n    private meshName: string = \"\";\n\n    @SerializeField\n    public materialName: string = \"\";\n\n    @SerializeField\n    public scale: number = 1;\n\n    @SerializeField\n    public castShadows: boolean = true;\n\n    private prevCastShadows: boolean = true;\n\n    @SerializeField\n    public receiveShadows: boolean = false;\n\n    @SerializeField\n    public mergeMeshes: boolean = true;\n\n    private prevReceiveShadows: boolean = false;\n\n    private _lastScale: number = 1;\n\n    public material: Material;\n\n    private _animationGroups: BABYLON.AnimationGroup[];\n\n    public get animationGroups () : BABYLON.AnimationGroup[]\n    {\n        return this._animationGroups;\n    }\n\n    private _isVisible: boolean = true;\n\n    public get isVisible(): boolean {\n        return this._isVisible;\n    }\n\n    public set isVisible(value: boolean) {\n        this._isVisible = value;\n        this.meshes.forEach((mesh) => {\n            mesh.isVisible = value;\n        });\n    }\n\n    public isLoadingMesh: boolean = false;\n\n    public scaleFactor: BABYLON.Vector3 = BABYLON.Vector3.One();\n\n    private isSprite: boolean = false;\n    private spriteDisplayed: boolean = false;\n    private lastMeshName: string = \"\";\n    private lastMatName: string = \"\";\n\n    InternalPreAwake(go) {\n        super.InternalPreAwake(go);\n        //We removed the array of meshes for optimization\n        this.onChangedMesh = new BABYLON.Observable();\n    }\n\n    Start() {\n        this.CheckForMeshUpdate();\n    }\n\n    //Check for inspector update.\n    CheckForMeshUpdate() {\n        //If it was deserialized the meshName is set but LoadMesh is never called.\n        if (this.meshName && this.meshName != this.lastMeshName) {\n            this.LoadMesh(this.meshName, this.scale);\n        }\n\n        if (this.materialName && this.materialName != this.lastMatName && this.meshes.length > 0) {\n            this.SetMaterial(Material.Get(this.materialName));\n        }\n    }\n\n    Update() {\n\n        if (this.prevCastShadows != this.castShadows) {\n            this.UpdateShadows();\n            this.prevCastShadows = this.castShadows;\n        }\n        if (this.prevReceiveShadows != this.receiveShadows) {\n            this.UpdateShadows();\n            this.prevReceiveShadows = this.receiveShadows;\n        }\n\n\n        this.CheckForMeshUpdate();\n        this.InternalUpdateMeshes();\n    }\n\n    SetSprite(textureName: string) {\n        this.SetMesh(BABYLON.Mesh.CreatePlane(\"sprite\", 1, Engine.scene));\n\n        //Sprites just have a unique material.\n        this.material = new Material(\"Sprite\");\n        var s = new BABYLON.StandardMaterial(\"Mat\", Engine.scene);\n        s.diffuseTexture = TextureSystem.GetSprite(textureName);\n        s.diffuseTexture.hasAlpha = true;\n        s.emissiveTexture = s.diffuseTexture;\n        s.backFaceCulling = true;\n        this.material.shader = s;\n\n        //Sprite is always a Single Mesh\n        this.GetMesh().material = this.material.shader;\n\n        this.isSprite = true;\n        this.spriteDisplayed = false;\n    }\n\n    InternalUpdateMeshes() {\n        if (this.isSprite) {\n            if (!this.spriteDisplayed) {\n                var s = this.meshes[0].material as BABYLON.StandardMaterial;\n                this.material.shader = s;\n                var size = s.diffuseTexture.getSize();\n                //We need to check the width because the first time it is loaded this value might be 0\n                if (size.width != 0) {\n                    this.scaleFactor = new BABYLON.Vector3(size.width * 0.01, size.height * 0.01, 1);\n                    this.spriteDisplayed = true;\n                    this.UpdateScaling();\n                }\n            }\n        } else {\n            if (this.scale != this._lastScale) {\n                this.scaleFactor = new BABYLON.Vector3(this.scale, this.scale, this.scale);\n                this.UpdateScaling();\n                this._lastScale = this.scale;\n            }\n        }\n\n        /*\n        //We can't use the mesh-callback since we need to reference this.transform\n        if (this.isLoadingMesh) {\n            //We merge the meshes!\n            var meshes: BABYLON.Mesh[] = MeshLoader.GetMesh(this.meshName);\n            if (meshes != null) {\n                //Merge meshes causes errors with GLB files - only merge with .obj\n                if (this.mergeMeshes && this.meshName.endsWith(\".obj\")) {\n                    this.SetMesh(BABYLON.Mesh.MergeMeshes(meshes, true, true, null, false, false));\n                } else {\n                    this.SetMesh(meshes);\n                }\n                this.isLoadingMesh = false;\n            } else {\n                return;\n            }\n        }\n        */\n    }\n\n    UpdateScaling() {\n        this.meshes.forEach((mesh: BABYLON.Mesh) => {\n            mesh.scaling = this.scaleFactor;//this.transform.transformNode.absoluteScaling.clone().multiply(this.scaleFactor);\n        });\n    }\n\n    RemoveMesh() {\n        if (this.meshes) {\n            this.meshes.forEach((mesh: BABYLON.Mesh) => {\n                try {\n                    //print(\"Removing \" + this.mesh.name + \" to meshToObj with id \" +this.mesh.uniqueId);\n                    Engine.meshToObject.delete(mesh.uniqueId);\n\n                    //This is false so when doing a scene reload the textures persist\n                    mesh.dispose(false, false);\n\n                    //If it's not a material from the material system...\n                    if (!Material.Get(this.materialName)) {\n                        mesh.material?.dispose();\n                    }\n                    this.material = null;\n                } catch (e) {\n                    console.warn(\"Failed to dispose mesh of \" + (this.gameObject ? this.gameObject.name : \"<Unknown>\") + \". Has the array of meshes been modified?\")\n                }\n            });\n            this.meshes = new Array();\n        }\n    }\n\n    SetMesh(newMesh: BABYLON.Mesh | BABYLON.Mesh[]) {\n        //Just in case.\n        this.RemoveMesh();\n\n        if (newMesh instanceof BABYLON.Mesh) {\n            this.SetSingleMesh(newMesh);\n        } else {\n            //TODO Implement this.\n            newMesh.forEach((mesh: BABYLON.Mesh) => {\n                this.SetSingleMesh(mesh);\n            });\n        }\n\n        this.UpdateScaling();\n        this.UpdateShadows();\n        this.onChangedMesh.notifyObservers(0);\n    }\n\n    private UpdateShadows() {\n        this.meshes.forEach((mesh: BABYLON.Mesh) => {\n            mesh.receiveShadows = this.receiveShadows;\n\n            if (this.castShadows) {\n                Lighting.AddCastingMesh(mesh);\n            } else {\n                Lighting.RemoveCastingMesh(mesh);\n            }\n\n        });\n\n    }\n\n    private SetSingleMesh(newMesh: BABYLON.Mesh) {\n        this.meshes.push(newMesh);\n\n        Engine.meshToObject.set(newMesh.uniqueId, this.gameObject);\n\n        //Meshes get parented to their transform. A mesh should never be moved by itself, but instead the transform component should be used.\n        newMesh.parent = (this.transform.transformNode);\n\n        newMesh.isVisible = true;\n\n        if (this.materialName)\n            this.SetMaterial(Material.Get(this.materialName));\n    }\n\n    listen_onChange = null;\n\n    SetMaterial(newMat: Material) {\n        this.material?.onChange.remove(this.listen_onChange);\n\n        this.material = newMat;\n        this.meshes.forEach(m => {\n            m.material = this.material.shader;\n        });\n        this.listen_onChange = this.material.onChange.add(matType => {\n            this.meshes.forEach(m => {\n                m.material = this.material.shader;\n            });\n            /*\n            if (matType == \"PBR\") {\n                \n            } else if (matType == \"Standard\") {\n\n            } else {\n                Debug.Log(`Material switched to unrecognized shader ${matType}!`);\n            }*/\n        });\n        this.lastMatName = this.materialName;\n    }\n\n    GetMesh(): BABYLON.Mesh {\n        return this.meshes[0];\n    }\n\n    GetMeshes(): BABYLON.Mesh[] {\n        return this.meshes;\n    }\n\n    LoadMesh(meshName: string, loadedScale: number = 1) {\n        this.RemoveMesh();\n        this.isLoadingMesh = true;\n        this.meshName = meshName;\n        this.lastMeshName = meshName;\n        this.scaleFactor = new BABYLON.Vector3(loadedScale, loadedScale, loadedScale);\n\n        if (meshName === \"box\" || meshName === \"sphere\") {\n\n            var defaultMesh = [];\n            if (meshName == \"box\") {\n                defaultMesh.push(BABYLON.Mesh.CreateBox(name, 1, Engine.scene));\n            } else {\n                defaultMesh.push(BABYLON.Mesh.CreateSphere(name, 8, 1, Engine.scene));\n            }\n            this.SetMesh(defaultMesh);\n            this.isLoadingMesh = false;\n            return;\n        }\n\n        //NEW STUFF\n\n        var modelUrl = URLResult.Create(meshName, FileType.Model);\n        if (modelUrl.baseUrl == null) {\n            print(\"Could not load mesh \" + meshName + \". Are you sure it exists?\");\n            this.isLoadingMesh = false;\n            return;\n        }\n\n        MeshLoader.Load(meshName, (instantiatedEntries : BABYLON.InstantiatedEntries) => {\n            var meshes = instantiatedEntries.rootNodes as BABYLON.Mesh[];\n            for (var i = 0; i <  meshes.length; i++) {\n                 meshes[i].isVisible = false;\n            }\n\n            this._animationGroups = instantiatedEntries.animationGroups;\n\n            for (var i = 0; i < instantiatedEntries.animationGroups.length; i++) {\n                if (Engine.isPlaying) {\n                    instantiatedEntries.animationGroups[i].play();\n                }\n            }\n\n            if (this.mergeMeshes && this.meshName.endsWith(\".obj\")) {\n                this.SetMesh(BABYLON.Mesh.MergeMeshes(meshes, true, true, null, false, false));\n            } else {\n                this.SetMesh(meshes);\n            }\n            this.isLoadingMesh = false;\n        });\n        /*\n        var assetsManager = new BABYLON.AssetsManager(Engine.scene);\n        assetsManager.useDefaultLoadingScreen = false;\n        var meshTask = assetsManager.addMeshTask(\"Loading \" + name, \"\", modelUrl.baseUrl, modelUrl.fullName);\n            \n        assetsManager.onFinish = (task) => {\n            for (var i = 0; i < meshTask.loadedMeshes.length; i++) {\n                meshTask.loadedMeshes[i].isVisible = false;\n            }\n            \n            if (this.mergeMeshes && this.meshName.endsWith(\".obj\")) {\n                this.SetMesh(BABYLON.Mesh.MergeMeshes(meshTask.loadedMeshes as BABYLON.Mesh[], true, true, null, false, false));\n            } else {\n                this.SetMesh(meshTask.loadedMeshes as BABYLON.Mesh[]);\n            }\n\n            MeshLoader.Log(\"Mesh \" + name + \" loaded successfully!\");\n        }\n        assetsManager.load();\n        */\n        /*\n\n        BABYLON.SceneLoader.ImportMesh(\"\", modelUrl.baseUrl, modelUrl.fullName, Engine.scene,\n            (meshes, ps, skeletons) => {\n\n                //Merge meshes causes errors with GLB files - only merge with .obj\n                if (this.mergeMeshes && this.meshName.endsWith(\".obj\")) {\n                    this.SetMesh(BABYLON.Mesh.MergeMeshes(meshes as BABYLON.Mesh[], true, true, null, false, false));\n                } else {\n                    this.SetMesh(meshes as BABYLON.Mesh[]);\n                }\n                this.isLoadingMesh = false;\n            });\n        */\n    }\n\n    InternalDestroy() {\n        super.InternalDestroy();\n        this.castShadows = false;\n        this.receiveShadows = false;\n        this.UpdateShadows();\n        this.RemoveMesh();\n    }\n}\n\n"
                    },
                    {
                        "Transform": "@ExecuteInEditMode\nclass Transform extends Component {    \n\n    //This is a mesh because the Gizmo system does not like TransformNodes\n    transformNode : BABYLON.AbstractMesh;\n\n    @SerializeField\n    private _position : Vector3;\n     \n    @SerializeField\n    private _eulerAngles : Vector3;\n    \n    @SerializeField\n    private _scale : Vector3;\n\n    private _absolutePosition : Vector3 = new Vector3();\n    private _absoluteScale : Vector3= new Vector3();\n    private _absoluteRotation : Quaternion= new Quaternion();\n    private _absoluteEulerAngles : Vector3 = new Vector3();\n    private _absoluteRadians : Vector3 = new Vector3();\n\n    @SerializeField\n    uniqueId : string = \"\";\n\n    //ALL rotation is handled through the _rotation Quaternion\n    //E.g. if Radians are changed, Radians > EulerAngles > Quaternion > Mesh\n    //It has to be like that since Rigidbodies in Babylon set the Quaternion rotation\n    //After the Quaternion has been set, this is the only way to rotate objects in Babylon\n    private _radians : Vector3;\n    private _rotation : Quaternion;\n\n    private _children : GameObject[] = new Array();\n\n    Awake ()\n    {\n        if (this.uniqueId === \"\")\n        {\n            this.uniqueId = uuidv4();\n        }\n        \n        this.transformNode = (new BABYLON.Mesh(this.gameObject.name, Engine.scene));\n        \n        Engine.meshToObject[this.transformNode.uniqueId] = this.gameObject;\n        this.transformNode.rotationQuaternion = new BABYLON.Quaternion();\n        this.localPosition = this._position ? this._position.clone() : Vector3.Zero(); \n        this.localScale = this._scale ? this._scale.clone() : Vector3.One();\n        var rot = this._eulerAngles ? this._eulerAngles.clone() : Vector3.Zero();\n        \n        this.localRotation = new Quaternion(0,0,0,0); \n        this.localEulerAngles = rot;\n    }\n\n    Start ()\n    {\n        \n        //Temp fix for insanely long children lists.\n        //This seems to be caused by prefabs!\n        for (var i = this.ser_children.length - 1; i >= 0; i--)\n        {\n            if (!this.ser_children[i])\n            {\n                this.ser_children.splice(i,1);\n            }\n        }\n    }\n\n    \n    FixedUpdate ()\n    {\n        //This seems redundant but it's calling the setter for all these variables\n        //Because our inspector and serializer use the private variables, this needs to be done\n        //This could be optimized (only selected + when serialized as scene) but is a minor performance overhead.\n        this.transform.localPosition;\n        this.transform.localEulerAngles;\n        this.transform.localScale;\n    }\n\n\n    get parent() : Transform\n    {\n        return this._parent;\n    }\n\n    //ONLY for serialization...\n    //getter only, since these will be set when Transforms are added automatically\n    @SerializeField\n    @HideInInspector\n    public get ser_children () : GameObject[] \n    {\n        return this._ser_children;\n    }\n\n    public set ser_children(value : GameObject[])\n    {\n       //this._ser_children = new Array();\n    }\n\n    public GetAllChildrenRecursively () : GameObject []\n    {\n        var arr = new Array();\n        this.AddChildren(arr, this.ser_children);\n        return arr;\n    }\n\n    private AddChildren (arr : GameObject[], children : GameObject[])\n    {\n        children.forEach(t => {\n            arr.push(t);\n            this.AddChildren(arr, t.transform.ser_children);\n        });\n    }\n\n    private _ser_children : GameObject[] = new Array();\n\n    GetSiblingIndex() : number\n    {\n        var c = this.parent ? this.parent.ser_children : SceneManager.GetActiveScene().rootObjs;\n\n        return c.indexOf(this.gameObject);\n    }\n\n    SetSiblingIndex(index : number)\n    {\n        var c = this.parent ? this.parent.ser_children : SceneManager.GetActiveScene().rootObjs;\n        index = Mathf.Clamp(index, 0, c.length);\n\n        const oldIndex = c.indexOf(this.gameObject);\n        //Remove from old position\n        c.splice(oldIndex, 1);\n        \n        //Add to new position\n        c.splice(index-1, 0, this.gameObject );\n            \n        \n    }\n\n    Find (name : string)\n    {\n        for (var i = 0; i < this.transform.ser_children.length; i++)\n        {\n            var c = this.transform.ser_children[i];\n            if (c)\n            {\n                if (c.name == name)\n                {\n                    return c;\n                }\n                c = c.transform.Find(name);\n                if (c)\n                {\n                    return c;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public SetParent(parent : Transform, worldPositionStays : boolean = true)\n    {\n        if (this.transform == parent)\n        {\n            Debug.Log(\"Can't set \" + this.name + \" to it's own parent.\");\n            return;\n        }\n        //We remove the object from the previous childrern list.\n        if (this._parent)\n        {\n            var x = this._parent.ser_children.indexOf(this.gameObject);\n            this._parent.ser_children.splice(x, 1);\n        } else {\n            var x = SceneManager.GetActiveScene().rootObjs.indexOf(this.gameObject);\n            SceneManager.GetActiveScene().rootObjs.splice(x, 1);\n        }\n        this._parent = parent;\n\n        if (!this._parent)\n        {\n            SceneManager.GetActiveScene().rootObjs.push(this.gameObject);\n        }\n\n        if (parent?.transformNode.nonUniformScaling)\n        {\n            Debug.Log(`Parented ${this.name} to non-uniformly scaled ${parent.name}. This is allowed but not recommended as it can lead to strange distortions.`);\n        }\n\n        if (worldPositionStays)\n        {\n            this.transformNode.setParent(parent?.transformNode);\n        } else {\n            this.transformNode.parent = parent?.transformNode;\n        }\n\n        //This array is auto populated when serializing.\n        if (!Serializer.isSettingParent)\n        {\n           parent?.ser_children.push(this.gameObject);\n        }\n    }\n\n    private _parent : Transform;\n\n\n/*\nPosition, rotation and scale are all stored in the mesh. The Transform component\nis nothing but a wrapper for the user. It will allow the user to easily update\nthe information and set rotation through eulerAngles or radians.\n*/\n\n/*\nThe event listener system for position, scale and rotation is designed\nto pick up on changes on the x,y,z components of these Vectors. Through that,\nusers can change one axis of a Vector, which now automatically updates the information\nin the game.\n*/\n\n// #region position\n    get position () : Vector3\n    {\n        Vector3.BtoV(this.transformNode.absolutePosition, this._absolutePosition);  \n        return this._absolutePosition;\n    }\n\n    set position (value : Vector3)\n    {\n        this._absolutePosition = value;\n\n        this._absolutePosition.onChange.clear();\n\n        this._absolutePosition.onChange.add(() => \n        {\n            this.transformNode.setAbsolutePosition(Vector3.VtoB(this._absolutePosition, new BABYLON.Vector3()));\n        });\n        this._absolutePosition.onChange.notifyObservers(null);    \n    }\n\n    get localPosition(): Vector3 {    \n        Vector3.BtoV(this.transformNode.position, this._position);  \n        return this._position;\n    }\n\n    set localPosition(value: Vector3) {\n        \n        this._position = value;\n\n        this._position.onChange.clear();\n\n        this._position.onChange.add(() => \n        {\n            Vector3.VtoB(this._position, this.transformNode.position);\n        });\n        this._position.onChange.notifyObservers(null);    \n    }\n\n// #endregion    \n\n\n//#region scale\n    get lossyScale() :Vector3\n    {\n        Vector3.BtoV(this.transformNode.absoluteScaling, this._absoluteScale);\n        return this._absoluteScale;        \n    }\n\n    get localScale(): Vector3 {\n\n        Vector3.BtoV(this.transformNode.scaling, this._scale);\n        return this._scale;\n    }\n\n    set localScale(value: Vector3) {\n        this._scale = value;\n\n        this._scale.onChange.clear();\n\n\n        this._scale.onChange.add(() => \n        {\n            Vector3.VtoB(this._scale, this.transformNode.scaling);\n        });\n        this._scale.onChange.notifyObservers(null);\n    }\n\n//#endregion\n\n\n//#region rotation\n\n    get rotation () : Quaternion\n    {\n        return Quaternion.BtoQ(this.transformNode.absoluteRotationQuaternion, this._absoluteRotation);\n    }\n\n    get eulerAngles () : Vector3\n    {\n        return Quaternion.ToEulerAngles(this.rotation, this._absoluteEulerAngles);\n    }\n\n    get radians () : Vector3\n    {\n        //get the eulerAngles\n        this.eulerAngles;\n        this._radians.x = this._absoluteEulerAngles.x * Mathf.Rad2Deg;\n        this._radians.y = this._absoluteEulerAngles.y * Mathf.Rad2Deg;\n        this._radians.z = this._absoluteEulerAngles.z * Mathf.Rad2Deg;\n        return this._radians;\n    }\n    \n    get localEulerAngles(): Vector3 {\n        Quaternion.ToEulerAngles(this.localRotation, this._eulerAngles);     \n    \n        return this._eulerAngles;\n    }\n\n    set localEulerAngles(value: Vector3) {\n        \n        this._eulerAngles = value;\n\n        this._eulerAngles.onChange.clear();\n\n        this._eulerAngles.onChange.add((index : number) => \n        {  \n            //The x eulerAngle needs to be looked at!\n            this.localRotation = Quaternion.Euler(this._eulerAngles.x, this._eulerAngles.y, this._eulerAngles.z, this._rotation);\n        });\n        \n        this._eulerAngles.onChange.notifyObservers(null);\n    }\n   \n\n    //Radians are untested.\n    get localRadians () : Vector3\n    {\n        this._radians.x = this.localEulerAngles.x * Mathf.Rad2Deg;\n        this._radians.y = this.localEulerAngles.y * Mathf.Rad2Deg;\n        this._radians.z = this.localEulerAngles.z * Mathf.Rad2Deg;\n\n        return this._radians;\n    }\n\n    set localRadians(value : Vector3)\n    {\n        this._radians = value;\n\n        this._radians.onChange.clear();\n\n        this._radians.onChange.add((index : number) => \n        {   \n            switch (index)\n            {                \n                case 0:                \n                    this.localEulerAngles.x = this._radians.x * Mathf.Rad2Deg;\n                    break;\n                case 1:\n                    this.localEulerAngles.y = this._radians.y * Mathf.Rad2Deg;\n                    break;\n                case 2:\n                    this.localEulerAngles.z = this._radians.z * Mathf.Rad2Deg;\n                    break;\n                default:\n                    this.localEulerAngles.x = this._radians.x * Mathf.Rad2Deg;\n                    this.localEulerAngles.y = this._radians.y * Mathf.Rad2Deg;\n                    this.localEulerAngles.z = this._radians.z * Mathf.Rad2Deg;\n                    break;\n            }\n        });\n        this._radians.onChange.notifyObservers(null); \n    }\n     \n    get localRotation () : Quaternion\n    {\n        return Quaternion.BtoQ(this.transformNode.rotationQuaternion, this._rotation);\n    }\n\n    set localRotation(value : Quaternion)\n    {\n        this._rotation = value;\n\n        this._rotation.onChange.clear();\n\n        this._rotation.onChange.add(() => \n        {   \n            Quaternion.QtoB(this._rotation, this.transformNode.rotationQuaternion);\n        });\n        this._rotation.onChange.notifyObservers(null); \n    }    \n\n//#endregion\n\n    public Rotate(xAxis: number, yAxis : number, zAxis:number, space?: BABYLON.Space): BABYLON.TransformNode {\n        this.transformNode.rotate(new BABYLON.Vector3(1,0,0), xAxis * Mathf.Deg2Rad, space);\n        this.transformNode.rotate(new BABYLON.Vector3(0,1,0), yAxis* Mathf.Deg2Rad, space);\n        return this.transformNode.rotate(new BABYLON.Vector3(0,0,1), zAxis* Mathf.Deg2Rad, space);\n    }\n\n    public Translate (x : number, y : number, z : number, space?: BABYLON.Space)\n    {\n        this.transformNode.translate(new BABYLON.Vector3(1,0,0), x, space);\n        this.transformNode.translate(new BABYLON.Vector3(0,1,0), y, space);\n        this.transformNode.translate(new BABYLON.Vector3(0,0,1), z, space);\n    }\n\n    private DisposeCurrentTransformNode()\n    {\n        Engine.meshToObject.delete(this.transformNode.uniqueId);\n        this.transformNode.dispose();\n    }\n\n    OnDestroy()\n    {\n        this.SetParent(null);\n        this.DisposeCurrentTransformNode();\n    }   \n}"
                    },
                    {
                        "Camera": "@RegisterAsComponent\n@ExecuteInEditMode\nclass Camera extends MonoBehaviour {\n  public static main: Camera;\n\n\n  public set mode(value: number) {\n    this.bCam.mode = value;\n  }\n\n  public get mode(): number {\n    return this.bCam.mode;\n  }\n\n  public orthoGraphicSize: number = 5;\n\n  //TargetCamera because regular Camera can't update position/rotation\n  public bCam: BABYLON.TargetCamera;\n\n  //This is a bit hacky but that way the camera view doesn't reset in playmode\n  Awake() {\n    if (this.bCam != null) {\n      this.bCam.dispose();\n    }\n    //var cam = new BABYLON.TargetCamera(\"MainCamera\", new BABYLON.Vector3(0, 0, -10), Engine.scene);\n    this.bCam = new BABYLON.TargetCamera(\"Camera\", new BABYLON.Vector3(0, 10, 0), Engine.scene);\n    \n    this.bCam.viewport = new BABYLON.Viewport(0, 0, 1, 1);\n    \n    this.bCam.layerMask = 2;\n\n    //Unshift because we dont want it to be at the top.\n    //If it's on top it will be used for interaction (e.g. picking a mesh through clicking)\n    Engine.scene.activeCameras.unshift(this.bCam);\n\n  \n\n    Camera.main = this;\n  }\n\n  Update() {\n    this.bCam.position = this.transform.transformNode.absolutePosition;\n    this.bCam.rotationQuaternion = this.transform.transformNode.absoluteRotationQuaternion;\n\n    if (Camera.main.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {\n      var vert = this.orthoGraphicSize;\n      var horz = vert * Engine.current.getScreenAspectRatio();\n      this.bCam.orthoTop = vert;\n      this.bCam.orthoBottom = -vert;\n      this.bCam.orthoLeft = -horz;\n      this.bCam.orthoRight = horz;\n    }\n  }\n\n  OnDestroy() {\n    this.bCam.dispose();\n  }\n}"
                    },
                    {
                        "Light": "enum LightType {\n  Directional,\n  Spot,\n  Point\n}\n\n@RegisterAsComponent\n@ExecuteInEditMode\nclass Light extends MonoBehaviour {\n  light: BABYLON.ShadowLight;\n\n  @SerializeEnumField(LightType)\n  public lightType = LightType.Directional;\n\n  private prevLightType = LightType.Directional;\n\n  @SerializeField\n  public color : Color = new Color(1,1,1);\n\n  @SerializeField\n  public castShadows: boolean = true;\n\n  private prevCastShadows: boolean = true;\n\n  @SerializeField\n  public intensity: number = .7;\n\n  @SerializeField\n  public range: number = 25;\n\n\n\n  @SerializeField\n  public coneAngle: number = 25;\n\n  @SerializeField\n  public exponent: number = 25;\n\n  @SerializeField\n  public shadowFrustrumSize: number = 25;\n\n  @SerializeField\n  public shadowFrustrumLength: number = 25;\n\n  \n\n  rot: BABYLON.Vector3;\n\n\n  Awake() {\n    this.UpdateLight();\n\n  }\n\n  private UpdateLight() {\n    if (this.light) {\n      Lighting.RemoveLight(this);\n      this.light.dispose();\n    }\n\n    var dirLight;\n\n    switch (this.lightType) {\n      case LightType.Directional:\n        dirLight = new BABYLON.DirectionalLight(\"Light\", this.transform.transformNode.forward, Engine.scene);\n\n        break;\n      case LightType.Point:\n        dirLight = new BABYLON.PointLight(\"Light\", this.transform.transformNode.absolutePosition.clone(), Engine.scene)\n        break;\n\n      case LightType.Spot:\n        dirLight = new BABYLON.SpotLight(\"Light\", this.transform.transformNode.forward, this.transform.transformNode.absolutePosition.clone(), this.coneAngle * Mathf.Deg2Rad, this.exponent, Engine.scene)\n\n        break;\n      default:\n        break;\n    }\n\n    dirLight.autoUpdateExtends = false;\n    dirLight.shadowFrustumSize = this.shadowFrustrumSize;\n\n    this.light = dirLight;\n    if (this.castShadows) {\n      Lighting.AddLight(this);\n    }\n  }\n\n  Update() {\n\n    if (this.lightType != this.prevLightType) {\n      this.prevLightType = this.lightType;\n      this.UpdateLight();\n    }\n\n    if (this.castShadows != this.prevCastShadows) {\n      this.prevCastShadows = this.castShadows;\n      if (this.castShadows) {\n        Lighting.AddLight(this);\n      } else {\n        Lighting.RemoveLight(this);\n      }\n\n    }\n\n    Vector3.VtoB(this.transform.position, this.light.position);\n    this.light.direction = this.transform.transformNode.forward.clone();\n    this.light.intensity = this.intensity;\n    this.light.range = this.range;\n    \n    this.light.shadowMaxZ = this.shadowFrustrumLength;\n    //Using the same color since why would you want a single light with\n    //two different light types?...\n    Color.UtoB(this.color, this.light.diffuse);\n    Color.UtoB(this.color, this.light.specular);\n\n    switch (this.lightType) {\n      case LightType.Directional:\n        var dirLight = this.light as BABYLON.DirectionalLight;\n        dirLight.shadowFrustumSize = this.shadowFrustrumSize;\n        \n        break;\n      case LightType.Point:\n        var pLight = this.light as BABYLON.PointLight;\n        \n        break;\n\n      case LightType.Spot:\n        var sLight = this.light as BABYLON.SpotLight;\n        sLight.exponent = this.exponent;\n        sLight.angle = this.coneAngle * Mathf.Deg2Rad;\n        break;\n      default:\n        break;\n    }\n\n  }\n\n  OnDestroy() {\n    Lighting.RemoveLight(this);\n    this.light.dispose();\n  }\n}\n\n\n"
                    }
                ]
            },
            {
                "Editor": [
                    {
                        "UnionButton": "class UnionButton extends BABYLON.GUI.Button {\n\n  get textBlock(): BABYLON.GUI.TextBlock {\n    return this._tb;\n  }\n\n  private _tb: BABYLON.GUI.TextBlock;\n\n  constructor(text: string, resizeToText: boolean = true) {\n    super(\"Button_\" + text);\n    this.width = \"100px\";\n    this.height = \"20px\";\n    this.color = UnionEditor.style.darkLineColor.toHexString();\n    this.background = UnionEditor.style.backgroundColor.toHexString();\n\n    this.alpha = 1;\n\n    this.isPointerBlocker = true;\n    // Adding text\n    this._tb = new BABYLON.GUI.TextBlock(name + \"_button\", text);\n    this._tb.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this._tb.paddingTop = \"20%\";\n    this._tb.style = UnionEditor.fontStyle;\n    this._tb.resizeToFit = true;\n\n    this._tb.color = UnionEditor.style.textColor.toHexString();\n\n    this.addControl(this._tb);\n\n    this.onBeforeDrawObservable.add(e => {\n      if (resizeToText) {\n        this.widthInPixels = this._tb.widthInPixels + 20;\n      }\n    });\n\n    var _t = this;\n\n    this.onPointerEnterObservable.add(e => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n    this.onPointerOutObservable.add(e => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n\n    _t.pointerEnterAnimation = function () {\n      _t.background = UnionEditor.style.hoverColor.toHexString();\n    };\n    _t.pointerOutAnimation = function () {\n      _t.background = UnionEditor.style.backgroundColor.toHexString();\n    };\n    _t.pointerDownAnimation = function () {\n      _t.background = UnionEditor.style.darkLineColor.toHexString();\n    };\n    _t.pointerUpAnimation = function () {\n      _t.background = UnionEditor.style.backgroundColor.toHexString();\n    };\n  }\n}\n"
                    },
                    {
                        "MenuButton": "class MenuButton extends UnionButton {\n\n  data: MenuItemData;\n  owner: MenuButtonList;\n  list: MenuButtonList;\n\n  constructor(owner: MenuButtonList, data: MenuItemData) {\n    //Only the top menu resizes\n    super(data.name, owner.owner == null);\n    this.color = UnionEditor.style.backgroundColor.toHexString();\n    this.owner = owner;\n    this.data = data;\n    this.textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.textBlock.style = UnionEditor.fontStyle;\n\n    this.isPointerBlocker = true;\n\n    //Remove the deeper menus when hovering\n    this.onPointerEnterObservable.add(e => {\n\n      owner.children.forEach(c => {\n        var b = c as MenuButton;\n        //We dispose any list since if it's this, a new one will get created\n        //if (b != this)\n        {\n          b.list?.dispose();\n        }\n      });\n\n      //If not top bar\n      if (this.GetTopOwner().isFocused) {\n        this.Expand();\n      }\n    });\n\n\n    this.onPointerClickObservable.add(e => {\n\n      if (!this.GetTopOwner().isFocused) {\n        this.GetTopOwner().isFocused = true;\n        this.Expand();\n      } else {\n        if (this.owner == this.GetTopOwner())\n        {\n          this.Collapse();\n        }\n      }\n\n      if (data.functionToCall) {\n        data.functionToCall();\n        //Clear all menus when clicking somewhere\n        this.Collapse();\n      }\n    });\n\n    this.onDisposeObservable.add(e => {\n      this.list?.dispose();\n    });\n  }\n\n  IsTopButton() {\n    return this.owner == this.GetTopOwner();\n  }\n\n  Collapse() {\n    var owner = this.GetTopOwner() as MenuButtonList;\n    owner.children.forEach(c => {\n      var b = c as MenuButton;\n      b.list?.dispose();\n    })\n    owner.isFocused = false;\n  }\n\n  Expand() {\n    if (this.data.children.length > 0) {\n      this.list = new MenuButtonList(this, this.data.children);\n      var pos = this.getLocalCoordinates(new BABYLON.Vector2()).negate();\n\n      UnionEditor.editorUI.addControl(this.list);\n      this.list.leftInPixels += pos.x;\n      this.list.topInPixels += pos.y;\n    }\n  }\n\n  GetTopOwner(): MenuButtonList {\n    return this.owner.GetTopOwner();\n  }\n}\n\n\nfunction MenuItem(value: string) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    {\n      if (!MenuItemData.main) {\n        MenuItemData.main = new MenuItemData();\n      }\n      MenuItemData.main.AddChild(value.split(\"/\"), descriptor.value);\n    }\n  }\n}\n\nclass MenuItemData {\n  static main: MenuItemData;\n\n  name: string;\n  functionToCall: any;\n  children: MenuItemData[] = new Array();\n\n  constructor() {\n\n  }\n\n  AddChild(items: string[], functionToCall: any) {\n    //Pop off the start of items\n    var name = items.shift();\n\n    var child = null;\n    //If the child already exists, we group them under the same MenuItemData\n    this.children.forEach(c => {\n      if (c.name == name) {\n        child = c;\n      }\n    });\n\n    //If it didn't exist yet in the menu, we add it here\n    if (!child) {\n      child = new MenuItemData();\n      this.children.push(child);\n      child.name = name;\n    }\n\n    //If there are more submenus...\n    if (items.length > 0) {\n      child.AddChild(items, functionToCall);\n    } else {\n      child.functionToCall = functionToCall;\n    }\n  }\n}"
                    },
                    {
                        "Windows": [
                            {
                                "EditorSystem": "//script:EditorSystem\n\nclass EditorSystem\n{\n  constructor ()\n  {\n    UnionEditor.editorSystems.push(this);\n  }\n\n  OnGUI ()\n  {\n\n  }\n}"
                            },
                            {
                                "EditorWindow": "class EditorWindow extends EditorSystem\n{\n  private sv : BABYLON.GUI.ScrollViewer;\n\n  public main : BABYLON.GUI.StackPanel;\n\n  public background : BABYLON.GUI.Rectangle;\n\n  constructor()\n  {\n    super();    \n    this.background = new BABYLON.GUI.Rectangle(\"EditorWindow\");\n    \n    this.background.cornerRadius = 0;\n    this.background.background = UnionEditor.style.backgroundColor.toHexString();\n    this.background.color = UnionEditor.style.backgroundColor.toHexString();\n    \n\n    this.background.onPointerEnterObservable.add((evt) => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n\n    this.background.onPointerOutObservable.add((evt) => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n\n    this.Refresh();\n  }\n\n  OnGUI()\n  {\n\n  }\n\n  Refresh()\n  {\n    this.main?.dispose();\n    this.sv?.dispose();\n\n    this.main = new BABYLON.GUI.StackPanel();\n    \n    this.main.fontSize = 14;\n\n    this.main.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.main.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    \n    this.sv = new BABYLON.GUI.ScrollViewer();\n    //this.sv.color = UnionEditor.style.darkLineColor.toHexString();\n    this.sv.thickness = 0;\n    this.background.addControl(this.sv);\n\n    this.sv.addControl(this.main);\n    this.sv.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.sv.barSize = 15;\n\n    \n    \n    //UnionEditor.editorUI.addControl(this.background);\n  }\n}"
                            },
                            {
                                "TopBarWindow": "class TopBarWindow extends EditorWindow {\n\n  public static items: string[];\n\n  private topPanel: BABYLON.GUI.StackPanel;\n  private breadCrumbs: BABYLON.GUI.StackPanel;\n  public breadCrumbsText: BABYLON.GUI.Button;\n\n\n  @MenuItem(\"GameObject/Create Empty\")\n  static CreateEmpty() {\n    var go: GameObject = new GameObject();\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/Create Child\")\n  static CreateEmptyChild() {\n    var go: GameObject = new GameObject();\n    if (EditorSelection.HasSelection()) {\n      go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n\n  @MenuItem(\"GameObject/Create Parent\")\n  static CreateParent() {\n    var go: GameObject = new GameObject();\n    go.transform.position = EditorSelection.GetCenterPoint();\n    var first = true;\n    EditorSelection.GetSelection().forEach(sgo => {\n      if (first) {\n        first = false;\n        var i: number = sgo.transform.GetSiblingIndex();\n        go.transform.SetParent(sgo.transform.parent, true);\n        go.transform.SetSiblingIndex(i + 1);\n      }\n      sgo.transform.SetParent(go.transform, true);\n    });\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/3D Object/Cube\")\n  static CreateBox() {\n    var go: GameObject = new GameObject();\n    go.name = \"Box\";\n    go.AddComponent(Renderer).LoadMesh(\"box\");\n    go.AddComponent(BoxCollider);\n    go.AddComponent(Rigidbody);\n    if (EditorSelection.HasSelection()) {\n      go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/3D Object/Sphere\")\n  static Sphere() {\n    var go: GameObject = new GameObject();\n    go.name = \"Sphere\";\n    go.AddComponent(Renderer).LoadMesh(\"sphere\");\n    go.AddComponent(SphereCollider);\n    go.AddComponent(Rigidbody);\n    if (EditorSelection.HasSelection()) {\n      go.transform.SetParent(EditorSelection.GetSelection()[0].transform, false);\n    }\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  @MenuItem(\"GameObject/Light/Directional Light\")\n  static CreateLight() {\n    var go: GameObject = new GameObject();\n    go.name = \"Light\";\n    go.AddComponent(Light);\n    go.transform.position = new Vector3(10,14,-10);\n    go.transform.localEulerAngles = new Vector3(45,-45,0);\n    EditorSelection.SetSelectedGameObject(go);\n  }\n\n  constructor() {\n    super()\n    this.background.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.background.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.background.width = \"100%\";\n    this.background.heightInPixels = 60;\n    this.background.background = UnionEditor.style.darkLineColor.toHexString();\n\n    this.breadCrumbs = new BABYLON.GUI.StackPanel();\n\n    this.breadCrumbs.isVertical = false;\n    this.breadCrumbs.height = \"20px\";\n\n    this.breadCrumbs.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.breadCrumbs.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n    this.breadCrumbsText = UnionEditor.CreateButton(\"Breadcrumbs\");\n    this.breadCrumbsText.horizontalAlignment= BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n        this.breadCrumbsText.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n    this.breadCrumbsText.color = UnionEditor.style.backgroundColor.toHexString();\n    this.breadCrumbsText.width = \"200px\";\n    this.breadCrumbs.addControl(this.breadCrumbsText);\n\n    this.background.addControl(this.breadCrumbs);\n    var buttonList = new MenuButtonList(null, MenuItemData.main.children, false);\n    this.breadCrumbs.addControl(buttonList);\n    //buttonList.paddingLeftInPixels += 100;\n\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n        buttonList.children.forEach(c => {\n          var b = c as MenuButton;\n          b.list?.dispose();\n        });\n        buttonList.isFocused = false;\n      }\n    });\n\n    this.topPanel = new BABYLON.GUI.StackPanel();\n\n    this.topPanel.isVertical = false;\n    this.topPanel.height = \"40px\";\n    \n    this.topPanel.fontSize = \"14px\";\n    this.topPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.topPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    this.background.addControl(this.topPanel);\n\n    var playButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"PlayButton\", \"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.play_button.png\");\n    playButton.width = \"25px\"; \n    playButton.height = \"25px\";\n    playButton.image.width = \"20px\";\n    playButton.image.height = \"20px\";\n    playButton.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    playButton.background =UnionEditor.style.backgroundColor.toHexString();\n    playButton.color = UnionEditor.style.darkLineColor.toHexString();\n    playButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    playButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    playButton.topInPixels = 10;\n    this.topPanel.addControl(playButton);\n\n    playButton.onPointerClickObservable.add(() => {\n      //The scene saves when going into PlayMode\n      if (!Engine.isPlaying) {\n        SceneManager.SaveCurrentScene();\n      }\n\n      if (!Engine.isPlaying) {\n        Engine.SwitchToPlayMode();\n        playButton.background =UnionEditor.style.selectionColor.toHexString();\n\n      } else {\n        Engine.StopPlayMode();\n        playButton.background =UnionEditor.style.backgroundColor.toHexString();\n      }\n      EditorSelection.SetSelectedGameObject(null);      \n    });\n\n\n    var pauseButton = BABYLON.GUI.Button.CreateImageOnlyButton(\"PlayButton\", \"https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.pause_button.png\");\n    pauseButton.width = \"25px\"; \n    pauseButton.height = \"25px\";\n    pauseButton.image.width = \"20px\";\n    pauseButton.image.height = \"20px\";\n    pauseButton.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    pauseButton.background =UnionEditor.style.backgroundColor.toHexString();\n    pauseButton.color = UnionEditor.style.darkLineColor.toHexString();\n    pauseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    pauseButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    pauseButton.topInPixels = 10;\n    this.topPanel.addControl(pauseButton);\n\n    pauseButton.onPointerClickObservable.add(() => {\n      print(\"Not yet implemented\");\n    });\n\n  }\n\n}\n"
                            },
                            {
                                "HierarchyWindow": "class HierarchyWindow extends EditorWindow\n{\n  public static refresh : boolean = false;\n\n  public static idToCollapseState: Record<number, boolean> \n\n  lastObjects : number = 0;\n\n  private list : HierarchyList;\n\n\n  constructor ()\n  {\n    super();\n    HierarchyWindow.idToCollapseState = {};\n    SceneManager.onSceneLoaded.add((ev: Scene) => {\n      this.DisplaySceneHierarchy();\n    });\n  }\n\n\n  OnGUI ()\n  {\n    super.OnGUI();\n    var scene = SceneManager.GetActiveScene();\n    //Simple 'isDirty' check\n    if (scene != null && (scene.objs.length != this.lastObjects || HierarchyWindow.refresh))\n    {\n      HierarchyWindow.refresh = false;\n      this.lastObjects = scene.objs.length;\n      this.DisplaySceneHierarchy();\n    }\n  }\n\n  DisplaySceneHierarchy ()\n  {\n    this.Refresh();\n    this.list?.dispose();\n    var scene = SceneManager.GetActiveScene();\n\n    this.list = new HierarchyList(scene.rootObjs, 0, null);\n    this.main.addControl(this.list);\n  }\n}"
                            },
                            {
                                "EditorWindowContainer": "class EditorWindowContainer extends BABYLON.GUI.StackPanel {\n\n  public windows: BABYLON.GUI.Container[] = new Array();\n  public dividers: EditorWindowDivider[] = new Array();\n\n\n  constructor(isVertical: boolean, sizes: number[] = null) {\n    super(\"EditorWindowContainer\")\n    this.isVertical = isVertical;\n\n    Engine.editorScene.onAfterRenderObservable.addOnce(e => {\n      var pos = 0;\n      var i = 0;\n      this.dividers.forEach(d => {\n        if (this.isVertical) {\n          if (sizes?.length > i) {\n            pos = sizes[i];\n\n          } else {\n            pos += this.heightInPixels / this.windows.length;\n\n          }\n          d.topInPixels = pos;\n        } else {\n          if (sizes?.length > i) {\n            pos = sizes[i];\n          } else {\n\n            pos += this.widthInPixels / this.windows.length;\n\n          }\n          print(pos)\n          d.leftInPixels = pos;\n        }\n        i++;\n      });\n\n      this.UpdatePosition();\n    });\n  }\n\n  //** Updates the position of the windows */\n  UpdatePosition() {\n    //this.dividers[0].topInPixels = this.heightInPixels * 0.5;\n    var lastDividerPos = 0;\n    for (var i = 0; i < this.windows.length; i++) {\n      var w = this.windows[i];\n      var newHeight;\n      if (i < this.dividers.length) {\n        newHeight = (this.isVertical ? this.dividers[i].topInPixels : this.dividers[i].leftInPixels) - lastDividerPos;\n        lastDividerPos += (newHeight + EditorWindowDivider.dividerHeight);\n      } else {\n        newHeight = (this.isVertical ? this.heightInPixels : this.widthInPixels) - lastDividerPos;\n      }\n      if (this.isVertical) {\n        w.heightInPixels = newHeight;\n      } else {\n        w.widthInPixels = newHeight;\n      }\n      \n    };\n  }\n\n  public Add(window: BABYLON.GUI.Container) {\n    if (this.windows.length > 0) {\n      var divider = new EditorWindowDivider(this);\n      this.dividers.push(divider);\n    }\n\n    //We have to set these to pixels (as opposed to default perc.) to avoid errors in the console\n    if (this.isVertical) {\n      window.heightInPixels = 0;\n    } else {\n      window.widthInPixels = 0;\n    }\n\n    this.addControl(window);\n    this.windows.push(window);\n  }\n}\n\n\nclass EditorWindowDivider extends BABYLON.GUI.Rectangle {\n\n  static dividerHeight = 3;\n\n  isOverThisControl: boolean = false;\n  pointerObserver: BABYLON.Observer<any>;\n  isAdjustingByMouse: boolean = false;\n\n  private pointerOffset: BABYLON.Vector2 = new BABYLON.Vector2();\n\n  constructor(owner: EditorWindowContainer) {\n    super(\"EditorWindowDivider\");\n    owner.addControl(this);\n    if (owner.isVertical) {\n      this.width = \"100%\";\n      this.heightInPixels = EditorWindowDivider.dividerHeight;\n    } else {\n      this.widthInPixels = EditorWindowDivider.dividerHeight;\n      this.height = \"100%\";\n    }\n    this.thickness = 0;\n    this.background = UnionEditor.style.darkLineColor.toHexString();\n\n    this.onPointerEnterObservable.add((ev) => {\n      EditorUI.SetPointerOverEditor(this);\n      Engine.cursor = owner.isVertical ? \"row-resize\" : \"col-resize\";\n      this.isOverThisControl = true;\n    });\n    this.onPointerOutObservable.add((ev) => {\n      EditorUI.RemovePointerOverEditor(this);\n      Engine.cursor = \"default\";\n      this.isOverThisControl = false;\n    });\n\n    this.pointerObserver = Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.isOverThisControl) {\n            this.isAdjustingByMouse = true;\n            this.pointerOffset.x = pointerInfo.event.x - this.leftInPixels;\n            this.pointerOffset.y = pointerInfo.event.y - this.topInPixels;\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERUP:\n          this.isAdjustingByMouse = false;\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n          if (this.isAdjustingByMouse) {\n            if (owner.isVertical) {\n              this.topInPixels = pointerInfo.event.y - this.pointerOffset.y;\n            } else {\n              this.leftInPixels = pointerInfo.event.x - this.pointerOffset.x;\n            }\n\n            owner.UpdatePosition();\n          }\n          break;\n      }\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      Engine.scene.onPointerObservable.remove(this.pointerObserver);\n    })\n  }\n}"
                            },
                            {
                                "GameViewWindow": "class GameViewWindow extends EditorWindow {\n\n    constructor() {\n        super();\n        this.background.alpha = 0;\n        this.background.isPointerBlocker = false;\n\n\n    }\n\n    OnGUI ()\n    {\n        if (Camera.main)\n        {\n            EditorHelpers.MapCamToGUIContainer(Camera.main.bCam, this.background);\n        }\n    }\n}\n"
                            },
                            {
                                "SceneViewWindow": "class SceneViewWindow extends EditorWindow {\n\n    cam: BABYLON.ArcRotateCamera;\n\n    isAttached: boolean = false;\n\n    constructor() {\n        super();\n        this.background.alpha = 0;\n        this.background.isPointerBlocker = false;\n\n        this.cam = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 1, 0.8, 10, new BABYLON.Vector3(0, 0, 0), Engine.scene);\n\n\n        this.cam.attachControl(Engine.canvas, true);\n        this.cam.layerMask = 4;\n        this.cam.wheelPrecision = 10\n        this.isAttached = true;\n\n        Engine.scene.activeCameras.push(this.cam);\n\n        var keyDownObserver = Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt => {\n            if (evt.sourceEvent.keyCode == 70 /*f-key*/) {\n\n                var hasSelection = EditorSelection.GetSelection()?.length > 0;\n                if (hasSelection) {\n                    this.cam.target = Vector3.VtoB(EditorSelection.GetCenterPoint(), new BABYLON.Vector3());\n                }\n            }\n        }));\n\n        this.cam.onDisposeObservable.addOnce(e => {\n            Engine.scene.actionManager.unregisterAction(keyDownObserver);\n        });\n    }\n\n    OnGUI() {\n        this.UpdateCamViewport();\n\n        var posRatio = Engine.editorScene.pointerY / Engine.canvas.height;\n\n        if (posRatio < 0.5) {\n            Engine.scene.activeCamera = this.cam;\n        } else {\n            if (Camera.main) {\n                Engine.scene.activeCamera = Camera.main.bCam;\n            }\n        }\n\n        //Detach on Update\n        if (this.isAttached && (EditorUI.GetPointerOverEditor() !== this || !Input.GetKey(KeyCode.Alt))) {\n            this.cam.detachControl(Engine.canvas);\n            this.isAttached = false;\n        }\n        else if (!this.isAttached && (EditorUI.GetPointerOverEditor() === this && Input.GetKey(KeyCode.Alt))) {\n            this.cam.attachControl(Engine.canvas, true);\n            this.isAttached = true;\n        }\n    }\n\n    UpdateCamViewport() {\n        EditorHelpers.MapCamToGUIContainer(this.cam, this.background);     \n    }\n}\n"
                            }
                        ]
                    },
                    {
                        "MenuButtonList": "class MenuButtonList extends BABYLON.GUI.StackPanel {\n\n  owner : MenuButton;\n  isFocused : boolean;\n\n  constructor(owner : MenuButton, itemDataList: MenuItemData[], isVertical = true) {\n    super();\n    this.owner = owner;\n    this.isVertical = isVertical;\n    //The first line after the main top bar should be moved down\n    if (owner?.owner && !owner.owner.isVertical)\n    {\n      this.topInPixels += 20;\n    } else {\n      this.leftInPixels += 100;\n    }\n\n    if (isVertical) {\n      this.widthInPixels = 100;\n      \n    } else {\n      this.heightInPixels = 20;\n    }\n    this.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    itemDataList.forEach(itemData => {\n      var button = new MenuButton(this, itemData);\n      this.addControl(button);\n    });\n\n  }\n\n  GetTopOwner () : MenuButtonList {\n    if (!this.owner)\n      return this;\n    return this.owner.GetTopOwner();\n  }\n}\n"
                    },
                    {
                        "EditorHelpers": "class EditorHelpers {\n    public static MapCamToGUIContainer(cam: BABYLON.Camera, cont: BABYLON.GUI.Control) {\n        var width = UnionEditor.editorUI.getSize().width;\n        var height = UnionEditor.editorUI.getSize().height;\n        var p = 0;//p is a minor pixel padding\n        var x = (cont.centerX - cont.widthInPixels * 0.5 + p) / width;\n        var y = 1 - ((cont.centerY + cont.heightInPixels * 0.5 - p) / height);\n        cam.viewport = new BABYLON.Viewport(\n            x,\n            y,\n            (cont.widthInPixels - p * 2) / width,\n            (cont.heightInPixels - p * 2) / height);\n    }\n}\n\n\nclass FPSCounter extends MonoBehaviour {\n    nFrameUpdateInterval: number = 10;\n\n    text: TextLabel;\n    average: number = 0;\n    nFramesSinceUpdate: number = 0;\n\n    Start() {\n        this.text = this.gameObject.AddComponent(TextLabel);\n        this.transform.position.x = 4;\n        this.transform.position.y = 4;\n    }\n\n    Update() {\n        this.nFramesSinceUpdate++;\n        this.average += Time.deltaTime;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval) {\n            this.text.text = \"FPS: \" + (1 / (this.average / this.nFrameUpdateInterval)).toFixed(0);\n            this.average = 0;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n\n    OnDestroy() {\n\n    }\n}\n\n\nclass ObjCounter extends MonoBehaviour {\n\n    nFrameUpdateInterval: number = 1;\n\n    text: TextLabel;\n    nFramesSinceUpdate: number = 0;\n\n    Start() {\n        this.text = this.gameObject.AddComponent(TextLabel);\n        this.transform.position.x = 4;\n        this.transform.position.y = 4.5;\n    }\n\n    Update() {\n        this.nFramesSinceUpdate++;\n        if (this.nFramesSinceUpdate >= this.nFrameUpdateInterval) {\n            this.text.text = \"Objs \" + SceneManager.GetActiveScene().objs.length;\n            this.nFramesSinceUpdate = 0;\n        }\n    }\n\n}"
                    },
                    {
                        "EditorGizmos": "class EditorGizmos extends EditorSystem {\n  //gizmoManager: BABYLON.GizmoManager;\n\n  private gizmoMode: Mode;\n\n  private prevMode: Mode;\n\n  //Since the GizmoManager requires a mesh to attach the pivot to, we will just use a dummy Mesh\n  private dummyMesh: BABYLON.Mesh;\n\n  private canSelect: boolean;\n\n  private isMoving: boolean;\n  private isRotating: boolean;\n  private isScaling: boolean;\n\n  private lastPos: BABYLON.Vector3 = new BABYLON.Vector3();\n  private lastRot: BABYLON.Vector3 = new BABYLON.Vector3();\n\n  constructor() {\n    super()\n    \n    this.dummyMesh = new BABYLON.Mesh(\"GizmoDummyMesh\", Engine.scene);\n\n\n    // Initialize GizmoManager\n   // Engine.gizmoManager = new BABYLON.GizmoManager(Engine.scene);\n    // Initialize all gizmos\n    Engine.gizmoManager.positionGizmoEnabled = true;\n    Engine.gizmoManager.attachToMesh(this.dummyMesh);\n\n    Engine.gizmoManager.keepDepthUtilityLayer.setRenderCamera(UnionEditor.sceneView.cam);\n    Engine.gizmoManager.utilityLayer.setRenderCamera(UnionEditor.sceneView.cam);\n    Engine.gizmoManager.attachToMesh(this.dummyMesh);\n    Engine.gizmoManager.usePointerToAttachGizmos = false;\n        \n    //Need to enable once to access gizmos\n    Engine.gizmoManager.positionGizmoEnabled = true;\n    Engine.gizmoManager.rotationGizmoEnabled = true;\n    Engine.gizmoManager.scaleGizmoEnabled = true;\n\n    Engine.gizmoManager.clearGizmoOnEmptyPointerEvent = false;\n\n    Engine.gizmoManager.gizmos.scaleGizmo.sensitivity = 10;\n\n    Engine.gizmoManager.gizmos.positionGizmo.onDragStartObservable.add((ev) => {\n      this.lastPos = this.dummyMesh.position.clone();\n      this.isMoving = true;\n    });\n    Engine.gizmoManager.gizmos.positionGizmo.onDragEndObservable.add((ev) => {\n      this.isMoving = false;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    Engine.gizmoManager.gizmos.rotationGizmo.onDragStartObservable.add((ev) => {\n      this.lastRot = this.dummyMesh.rotationQuaternion.toEulerAngles().clone();\n      this.isRotating = true;\n    });\n    Engine.gizmoManager.gizmos.rotationGizmo.onDragEndObservable.add((ev) => {\n      this.isRotating = false;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    Engine.gizmoManager.gizmos.scaleGizmo.onDragStartObservable.add((ev) => {\n      this.lastPos = this.dummyMesh.scaling.clone();\n      this.isScaling = true;\n    });\n    Engine.gizmoManager.gizmos.scaleGizmo.onDragEndObservable.add((ev) => {\n      this.isScaling = false;\n      SceneManager.MarkSceneAsDirty();\n    });\n\n    Engine.gizmoManager.positionGizmoEnabled = false;\n    Engine.gizmoManager.rotationGizmoEnabled = false;\n    Engine.gizmoManager.scaleGizmoEnabled = false;\n\n    this.gizmoMode = Mode.Translate;\n\n    Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.canSelect) {\n            var pickResult = Engine.scene.pick(Engine.scene.pointerX, Engine.scene.pointerY);\n            var go: GameObject = null;\n            if (pickResult.hit) {\n              var mesh = pickResult.pickedMesh;\n              go = !mesh?.parent ? null : Engine.meshToObject[mesh.parent.uniqueId];\n              go = EditorSelection.GetPrefabParent(go);\n            }\n            if (Input.GetKey(KeyCode.Control)) {\n              EditorSelection.ToggleSelectedGameObject(go);\n            } else {\n              if (go) {\n                EditorSelection.SetSelectedGameObject(go);\n\n              } else {\n                EditorSelection.SetSelectedGameObject(null);\n              }\n            }\n\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n\n          break;\n      }\n    });\n\n\n  }\n\n  OnGUI() {\n    var selection = EditorSelection.GetSelection();\n\n    var hasSelection = selection?.length > 0;\n    if (hasSelection) {\n\n      if (this.isMoving) {\n        //How much the gizmo moved\n        var offset = this.dummyMesh.position.subtract(this.lastPos);\n\n        selection.forEach(go => {\n          if (!go.prefabParent || go.prefabParent == go) {\n            //For some reason I need to set the entire Vector. The change is not recognized otherwise? 0_o\n            go.transform.position = new Vector3(\n              go.transform.position.x + offset.x,\n              go.transform.position.y + offset.y,\n              go.transform.position.z + offset.z\n            );\n          }\n        });\n\n        this.lastPos = this.dummyMesh.position.clone();\n      }\n      else {\n        Vector3.VtoB(EditorSelection.GetCenterPoint(), this.dummyMesh.position);\n      }\n      if (this.isRotating) {\n        var offset2 = this.dummyMesh.rotationQuaternion.toEulerAngles().subtract(this.lastRot)\n\n        selection.forEach(go => {\n          if (!go.prefabParent || go.prefabParent == go) {\n            //We set each individual value so the inspector displays it properly\n            go.transform.localEulerAngles.x = go.transform.localEulerAngles.x + offset2.x * Mathf.Rad2Deg;\n            go.transform.localEulerAngles.y = go.transform.localEulerAngles.y + offset2.y * Mathf.Rad2Deg;\n            go.transform.localEulerAngles.z = go.transform.localEulerAngles.z + offset2.z * Mathf.Rad2Deg;\n          }\n\n        });\n\n        this.lastRot = this.dummyMesh.rotationQuaternion.toEulerAngles().clone();\n      } else {\n        //Just use the rotation of the first selected object...\n        this.dummyMesh.rotationQuaternion = EditorSelection.GetSelection()[0].transform.transformNode.absoluteRotationQuaternion.clone();\n      }\n\n      if (this.isScaling) {\n        var offset3 = this.dummyMesh.scaling.subtract(this.lastPos)\n\n        selection.forEach(go => {\n          if (!go.prefabParent || go.prefabParent == go) {\n            go.transform.localScale.x = go.transform.localScale.x + offset3.x;\n            go.transform.localScale.y = go.transform.localScale.y + offset3.y;\n            go.transform.localScale.z = go.transform.localScale.z + offset3.z;\n          }\n        });\n\n        this.lastPos = this.dummyMesh.scaling.clone();\n      }\n    }\n\n\n    Engine.gizmoManager.positionGizmoEnabled = this.gizmoMode == Mode.Translate && hasSelection;\n    Engine.gizmoManager.rotationGizmoEnabled = this.gizmoMode == Mode.Rotate && hasSelection;\n    Engine.gizmoManager.scaleGizmoEnabled = this.gizmoMode == Mode.Scale && hasSelection;\n    Engine.gizmoManager.boundingBoxGizmoEnabled = false;\n    \n    if (Input.GetKeyDown(KeyCode.W)) {\n      this.gizmoMode = Mode.Translate;\n    }\n\n    if (Input.GetKeyDown(KeyCode.E)) {\n      this.gizmoMode = Mode.Rotate;\n    }\n\n    if (Input.GetKeyDown(KeyCode.R)) {\n      this.gizmoMode = Mode.Scale;\n    }\n\n    if (EditorUI.GetPointerOverEditor() === UnionEditor.sceneView && !Input.GetKey(KeyCode.Alt) ) {\n      this.canSelect = true;\n      //Engine.gizmoManager.clearGizmoOnEmptyPointerEvent = false;\n      //Engine.gizmoManager.usePointerToAttachGizmos = false;\n    } else {\n      this.canSelect = false;\n      //Engine.gizmoManager.clearGizmoOnEmptyPointerEvent = true;\n      //Engine.gizmoManager.usePointerToAttachGizmos = true;\n\n    }\n\n    if (Input.GetKeyDown(KeyCode.Escape)) {\n      EditorSelection.SetSelectedGameObject(null);\n    }\n\n  }\n\n}\n\nenum Mode {\n  Translate,\n  Rotate,\n  Scale\n}"
                    },
                    {
                        "EditorSelection": "class EditorSelection extends EditorSystem {\n  constructor() {\n    super();\n    EditorSelection.onSelected = new BABYLON.Observable();\n  }\n\n  private static selected: GameObject[] = new Array();\n\n  public static onSelected: BABYLON.Observable<SelectionData>\n\n\n  public static IsSelected(value: GameObject, includeParent: boolean = false): boolean {\n    while (!this.IsSelectedSelf(value))\n    {\n      if (!includeParent || !value.transform.parent)\n      {\n        return false;\n      }\n      //Check if the parent is selected instead\n      value = value.transform.parent.gameObject;\n    }\n    return true;\n  }\n\n  private static IsSelectedSelf(value: GameObject) {\n    return this.selected.indexOf(value) > -1;\n  }\n\n  public static HasSelection(): boolean {\n    return this.GetSelection().length > 0;\n  }\n\n  public static currentSelectedGameObject;\n\n  public static GetSelection(): GameObject[] {\n    return this.selected;\n  }\n\n  public static GetCenterPoint(): Vector3 {\n    var v = new Vector3();\n    this.selected.forEach((s: GameObject) => {\n      v.x += s.transform.position.x;\n      v.y += s.transform.position.y;\n      v.z += s.transform.position.z;\n    });\n\n    v.x /= this.selected.length;\n    v.y /= this.selected.length;\n    v.z /= this.selected.length;\n    return v;\n  }\n\n  public static ToggleSelectedGameObject(go: GameObject) {\n    if (EditorSelection.IsSelected(go)) {\n      EditorSelection.RemoveSelectedGameObject(go);\n    } else {\n      EditorSelection.AddSelectedGameObject(go);\n    }\n  }\n\n  public static AddSelectedGameObject(params: GameObject | GameObject[]) {\n    if (!params)\n      return;\n\n    if (params instanceof GameObject)\n      params = new Array(params);\n\n    params.forEach(value => {\n      //value = this.GetSelectableParent(value);\n\n      if (this.selected.indexOf(value) == -1) {\n        this.selected.push(value);\n        this.onSelected.notifyObservers({ obj: value, isSelected: true });\n      }\n    });\n  }\n\n  public static GetPrefabParent (v: GameObject) {\n    if (!v)\n      return null;\n    if (v.prefabParent)\n      return v.prefabParent;\n    return v;\n  }\n\n  public static RemoveSelectedGameObject(params: GameObject | GameObject[]) {\n    if (!params)\n      return;\n\n    if (params instanceof GameObject)\n      params = new Array(params);\n\n    params.forEach(value => {\n      const index = this.selected.indexOf(value);\n      if (index > -1) {\n        this.selected.splice(index, 1);\n        this.onSelected.notifyObservers({ obj: value, isSelected: false });\n      }\n    });\n  }\n\n  private static ClearSelection() {\n    //Clear old selection\n    this.selected.forEach((s: GameObject) => {\n      this.onSelected.notifyObservers({ obj: s, isSelected: false });\n    });\n\n    this.selected = new Array();\n  }\n\n  public static SetSelectedGameObject(params: GameObject | GameObject[]) {\n    this.ClearSelection();\n\n    this.AddSelectedGameObject(params);\n  }\n}\n\nclass SelectionData {\n  obj: BaseObject;\n  isSelected: boolean;\n}"
                    },
                    {
                        "UnionEditor": "\nclass UnionEditor {\n\n  public static style: EditorStyle;\n\n  public static editorUI: BABYLON.GUI.AdvancedDynamicTexture;\n\n  public static sceneView: SceneViewWindow;\n  public static gameView: GameViewWindow;\n\n  public static editorSystems: EditorSystem[];\n\n  public static fontStyle: BABYLON.GUI.Style;\n  public static fontStyleBold: BABYLON.GUI.Style;\n\n  private static uiCam: BABYLON.TargetCamera;\n\n  private static topBar: TopBarWindow;\n\n  public static CreateButton(name: string): BABYLON.GUI.Button {\n    var button = new UnionButton(name);\n    return button;\n  }\n\n  public static SetTitle(name: string) {\n    this.topBar.breadCrumbsText.textBlock.text = name;\n  }\n\n  private static mainPanel: EditorWindowContainer;\n\n  private static defaultInspectorWidth = 270;\n\n  \n\n  public static Init() {\n    this.style = new EditorStyle();\n\n    this.editorSystems = new Array();\n\n    //Here to render the User Interface\n    this.uiCam = new BABYLON.TargetCamera(\"uiCam\", new BABYLON.Vector3(999999, 0, 999999), Engine.editorScene);\n    this.uiCam.viewport = new BABYLON.Viewport(0, 0, 1, 1);\n    this.uiCam.attachControl(Engine.canvas, true);\n\n    Engine.editorScene.activeCameras.push(this.uiCam);\n\n    this.editorUI = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\", true, Engine.editorScene);\n    this.editorUI.layer.layerMask = 1;\n    this.editorUI.renderAtIdealSize = true;\n\n    this.fontStyle = new BABYLON.GUI.Style(this.editorUI);\n    this.fontStyle.fontSize = 12;\n    this.fontStyle.fontFamily = \"Roboto\";\n\n    this.fontStyleBold = new BABYLON.GUI.Style(this.editorUI);\n    this.fontStyleBold.fontSize = 13;\n    this.fontStyleBold.fontWeight = \"bold\";\n    this.fontStyleBold.fontFamily = \"Roboto\";\n\n    var mainStack = new BABYLON.GUI.StackPanel();\n    mainStack.height = \"100%\";\n    UnionEditor.editorUI.addControl(mainStack);\n\n    this.topBar = new TopBarWindow();\n    mainStack.addControl(this.topBar.background);\n\n    this.mainPanel = new EditorWindowContainer(false, [UnionEditor.editorUI.getSize().width - this.defaultInspectorWidth]);\n    mainStack.addControl(this.mainPanel);\n    this.mainPanel.width = \"100%\";\n\n    var leftBar = new EditorWindowContainer(true);\n    leftBar.height = \"100%\";\n    this.mainPanel.Add(leftBar);\n\n    this.sceneView = new SceneViewWindow();\n    leftBar.Add(this.sceneView.background);\n    this.gameView = new GameViewWindow();\n    leftBar.Add(this.gameView.background);\n\n    var rightBar = new EditorWindowContainer(true);\n    //rightBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n    rightBar.height = \"100%\";\n    this.mainPanel.Add(rightBar);\n\n    new EditorSelection();\n    new EditorGizmos();\n\n    //TODO clean this up. Should windows inherit from Container/Rectangle?\n    rightBar.Add(new HierarchyWindow().background);\n    rightBar.Add(new InspectorWindow().background);\n\n    Engine.scene.onKeyboardObservable.add((keybrd) => {\n\n      if (keybrd.type == BABYLON.KeyboardEventTypes.KEYDOWN && keybrd.event.key == \"d\") {\n        if (keybrd.event.ctrlKey) {\n          keybrd.event.preventDefault();\n\n          var sel = EditorSelection.GetSelection();\n\n          /*\n          //Prefabs only have a single root-object\n          if (SceneManager.prefabLoaded && !c.transform.parent)\n          {\n            Debug.Log(\"Can't duplicate the root-object of a prefab!\");\n            return;\n          }\n          */\n          EditorSelection.SetSelectedGameObject(null);\n          sel.forEach(c => {\n            var jsonData: string = Serializer.ToJSON(c);\n            //Create a clone from data read from the string.\n            var clone: GameObject = Serializer.FromJSON(jsonData) as GameObject;\n            clone.transform.SetParent(c.transform.parent, false);\n            EditorSelection.AddSelectedGameObject(clone);\n          });\n        }\n      }\n    });\n    Undo.Init();\n  }\n\n  static prevWidth = 0;\n  static prevHeight = 0;\n\n  static updateNextFrame = 0;\n\n  public static Update() {\n\n    if (this.editorUI.getSize().width != this.prevWidth || this.editorUI.getSize().height != this.prevHeight) {\n      this.prevWidth = this.editorUI.getSize().width;\n      this.prevHeight = this.editorUI.getSize().height;\n      this.updateNextFrame = 0;\n    }\n    if (this.updateNextFrame < 2) {\n      this.updateNextFrame++;\n    }\n    //We need wait two frames for the width to update.\n    if (this.updateNextFrame === 2) {\n      this.mainPanel.heightInPixels = this.prevHeight - this.topBar.background.heightInPixels;\n      this.mainPanel.UpdatePosition();\n    }\n\n    if (Input.GetKeyDown(KeyCode.Delete)) {\n      var sel = EditorSelection.GetSelection();\n      sel.forEach(c => {\n        Destroy(c);\n        EditorSelection.SetSelectedGameObject(null);\n      });\n    }\n\n    this.editorSystems.forEach((window: EditorWindow) => {\n      window.OnGUI();\n    });\n  }\n\n\n\n}\n\nclass EditorStyle {\n\n  //Unity grey\n  backgroundColor = new BABYLON.Color3(0.219607843, 0.219607843, 0.219607843);\n  componentBackgroundColor = new BABYLON.Color3(0.2431372549, 0.2431372549, 0.2431372549);\n  lineColor = new BABYLON.Color4(0, 0, 0, 0);\n  semiDarkLineColor = new BABYLON.Color3(0.19215686274, 0.19215686274, 0.19215686274);\n  darkLineColor = new BABYLON.Color3(0.1, 0.1, 0.1);\n  textColor = new BABYLON.Color3(0.8, 0.8, 0.8);\n  selectedTextColor = new BABYLON.Color3(1, 1, 1);\n  selectionColor = new BABYLON.Color3(0.17254902, 0.364705882, 0.529411765);\n  hoverColor = new BABYLON.Color3(0.270588235, 0.270588235, 0.270588235);\n  buttonColor = new BABYLON.Color3(0.34509803921,0.34509803921,0.34509803921);\n}\n\n"
                    },
                    {
                        "HierarchyItem": "\nclass BaseHierarchyItem {\n\n    background: BABYLON.GUI.Rectangle;\n    parentList: HierarchyList;\n\n    constructor (parentList: HierarchyList)\n    {\n        this.parentList = parentList;\n        this.background = new BABYLON.GUI.Rectangle(\"HierarchyItem\");\n        this.background.color = UnionEditor.style.backgroundColor.toHexString();\n        this.background.width = \"100%\";\n        //Needs to block the pointer for the Gizmos to work.\n        this.background.isPointerBlocker = true;\n    }\n\n    OnReleased ()\n    {\n        \n    }\n}\n\n\nclass HierarchyItem extends BaseHierarchyItem {\n\n    public static justClicked: HierarchyItem = null;\n\n    public onChange: BABYLON.Observable<string>;\n    public onSelect: BABYLON.Observable<boolean>;\n\n    //Tweakables\n    itemHeight: number = 17;\n\n    maxDoubleClickDelay: number = 0.3;\n\n    //Gameplay Vars\n    public static currentDraggedItem: HierarchyItem = null;\n    public static currentHoveredItem: BaseHierarchyItem = null;\n\n    lastClickTime: number;\n    isSelected: boolean;\n    obj: GameObject;\n    isCollapsed = true;\n\n    //References\n    public p: BABYLON.GUI.StackPanel;\n    private collapseButton: BABYLON.GUI.Button;\n    childrenList: HierarchyList;\n\n    private nameField : BABYLON.GUI.TextBlock;\n\n    constructor(parentList: HierarchyList, obj: GameObject) {\n        super(parentList);\n        \n        this.obj = obj;\n\n        \n\n        this.onChange = new BABYLON.Observable();\n        this.onSelect = new BABYLON.Observable();\n\n        this.p = new BABYLON.GUI.StackPanel();\n        this.p.width = \"100%\";\n        this.p.heightInPixels = this.itemHeight;\n        this.p.isVertical = true;\n        this.p.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT\n\n\n        var item = new BABYLON.GUI.Container();;\n        item.width = \"100%\";\n        item.height = \"20px\";\n        //item.isVertical = false;\n        this.p.addControl(item);  \n\n        if (obj.transform.ser_children.length > 0) {\n            this.collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n            this.collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n            this.collapseButton.width = \"20px\";\n            this.collapseButton.color = UnionEditor.style.lineColor.toHexString();\n            this.collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n            this.background.addControl(this.collapseButton);\n\n            this.collapseButton.onPointerUpObservable.add((evt) => {\n                this.SetCollapse(!this.isCollapsed);\n            });\n        }\n\n        this.nameField = new BABYLON.GUI.TextBlock(\"\", obj.name);\n        this.nameField.style = UnionEditor.fontStyle;\n        this.nameField.paddingLeft = \"25px\";\n        this.nameField.color = obj.prefabParent ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.textColor.toHexString();\n        this.nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n        this.background.addControl(this.nameField);\n\n\n        var nameInput: BABYLON.GUI.InputText = null;\n\n        this.background.onPointerDownObservable.add((ev) => {\n            HierarchyItem.currentDraggedItem = this;\n            HierarchyItem.currentHoveredItem = this;\n        });\n\n        //This pointerUp is called when releasing a the pointer \n        //but NOT on the object the poitner is released, but rather where it was released from\n        this.background.onPointerUpObservable.add((ev) => {\n            var hover = HierarchyItem.currentHoveredItem;\n            \n            if (!hover) {\n               \n               //If not hovering over itself\n            } else if (this != hover) {\n                hover.OnReleased();                \n                HierarchyWindow.refresh = true;\n            }\n\n            HierarchyItem.currentDraggedItem = null;\n        });\n\n        Engine.scene.onPointerObservable.add((pointerInfo) => {\n            if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n                if (this != HierarchyItem.currentDraggedItem)\n                    return;\n            }\n        });\n\n        this.background.onPointerEnterObservable.add((ev) => {\n            if (HierarchyItem.currentDraggedItem) {\n\n                if (HierarchyItem.currentDraggedItem != this) {\n                    HierarchyItem.currentHoveredItem = this;\n                    this.background.background = UnionEditor.style.hoverColor.toHexString();\n                }\n            }\n        });\n\n        this.background.onPointerOutObservable.add((ev) => {\n            if (HierarchyItem.currentHoveredItem == this) {\n                HierarchyItem.currentHoveredItem = null;\n                if (!EditorSelection.IsSelected(this.obj)) {\n                    this.background.background = UnionEditor.style.backgroundColor.toHexString();\n                }\n            }\n        });\n\n\n        this.background.onPointerClickObservable.add((ev) => {\n            HierarchyItem.justClicked = this;\n            var clickDelay = Time.time - this.lastClickTime;\n            //Double click\n            if (clickDelay < this.maxDoubleClickDelay) {\n\n                if (nameInput == null) {\n                    nameInput = new BABYLON.GUI.InputText();\n                    nameInput.text = this.nameField.text;\n                    nameInput.width = 1;\n                    nameInput.height = 1;\n                    nameInput.color = UnionEditor.style.selectedTextColor.toHexString();\n                    nameInput.textHighlightColor = UnionEditor.style.selectionColor.toHexString();\n                    nameInput.onFocusSelectAll = true;\n                    nameInput.style = UnionEditor.fontStyle;\n\n                    this.background.addControl(nameInput);\n                    UnionEditor.editorUI.moveFocusToControl(nameInput);\n                    nameInput.onBlurObservable.add((ev) => {\n                        this.nameField.text = nameInput.text;\n                        nameInput.dispose();\n                        nameInput = null;\n                        obj.name = this.nameField.text;\n                        this.onChange.notifyObservers(obj.name);\n                    });\n                }\n                //Single click\n            } else {\n                this.onSelect.notifyObservers(this.isSelected);\n            }\n\n            this.lastClickTime = Time.time;\n\n        });\n\n        item.addControl(this.background);\n        item.paddingBottomInPixels = -3;\n        item.paddingTopInPixels = -3;\n        EditorSelection.onSelected.add((data: SelectionData) => {\n            if (data.obj === obj) {\n                this.SetSelected(data.isSelected);\n            }\n        });\n\n        var collapsed = HierarchyWindow.idToCollapseState[obj.transform.uniqueId];\n        if (collapsed == undefined)\n            collapsed = true;\n        this.SetCollapse(collapsed);\n        this.SetSelected(EditorSelection.IsSelected(obj));\n    }\n\n\n    SetCollapse(value: boolean) {\n        //Can't collapse if it has no children\n        if (value == this.isCollapsed || this.obj.transform.ser_children.length == 0)\n            return;\n\n        \n        this.isCollapsed = value;\n        HierarchyWindow.idToCollapseState[this.obj.transform.uniqueId] = value;\n        this.collapseButton.textBlock.text = this.isCollapsed ? \">\" : \"v\";\n        if (this.isCollapsed) {\n            //We collapse all children before we collapse a parent\n            this.childrenList.items.forEach(item => {\n                item.SetCollapse(true);\n            });\n            this.childrenList.dispose();\n            this.AddToHeight(-this.obj.transform.ser_children.length);\n        } else {\n            //TODO Clean this up! The HierarchyWindow shouldn't clean the child list\n            this.obj.transform.ser_children = this.obj.transform.ser_children.filter(function (el) {\n                return el != null;\n            });\n            \n            this.childrenList = new HierarchyList(this.obj.transform.ser_children, this.parentList.tabSize, this);\n            this.p.addControl(this.childrenList);\n            this.AddToHeight(this.obj.transform.ser_children.length);\n        }\n    }\n\n    public AddToHeight(nElements: number) {\n        this.p.heightInPixels += nElements * (this.itemHeight + 5); //5 because of HierarchySplitItemWidth <- FIX THIS!\n        this.p.heightInPixels += nElements > 0 ? 5 : -5;\n        if (this.parentList.parentItem) {\n            this.parentList.parentItem.AddToHeight(nElements);\n        }\n    }\n\n    OnReleased ()\n    {\n        //After releasing, parent all selected objects to here.\n        EditorSelection.GetSelection().forEach(go =>\n        {\n            go.transform.SetParent( this.obj.transform, true);\n        });\n    }\n\n    SetSelected (value : boolean)\n    {\n        if (value) {\n            this.background.background = UnionEditor.style.selectionColor.toHexString();\n            this.nameField.color = UnionEditor.style.textColor.toHexString();\n        } else {\n            this.background.background = UnionEditor.style.backgroundColor.toHexString();\n            this.nameField.color = this.obj.prefabParent ? UnionEditor.style.selectionColor.toHexString() : UnionEditor.style.textColor.toHexString();\n        }\n    }\n}\n\nclass HierarchySplitItem extends BaseHierarchyItem {\n\n    siblingIndex : number;\n\n    constructor(parentList : HierarchyList, siblingIndex : number) {\n        super(parentList);\n\n        this.siblingIndex = siblingIndex;\n\n        this.background.heightInPixels = 5;\n        this.background.color = UnionEditor.style.lineColor.toHexString();\n        \n        this.background.onPointerEnterObservable.add((ev) => {\n            if (HierarchyItem.currentDraggedItem) {\n                HierarchyItem.currentHoveredItem = this;\n                this.background.background = UnionEditor.style.selectionColor.toHexString();                \n            }\n        });\n\n        this.background.onPointerOutObservable.add((ev) => {\n            if (HierarchyItem.currentHoveredItem == this) {\n                HierarchyItem.currentHoveredItem = null;\n                this.background.background = UnionEditor.style.lineColor.toHexString();\n            }\n        });\n    }\n\n    //The SplitItem returns it's parent since that will be the new parent for a dragged on object\n    OnReleased ()\n    {\n        //After releasing, parent all objects to my parent and set the sibling index\n        //TODO The splitter item should also know the parent\n        EditorSelection.GetSelection().forEach(go => \n        {\n            var i = go.transform.GetSiblingIndex();\n            var parentChange = go.transform.parent != this.parentList?.parentItem?.obj.transform;\n\n            go.transform.SetParent(this.parentList?.parentItem?.obj.transform, true);\n            \n            //Only if the parent didn't change, and we moved it from a higher spot to a lower spot\n            //We have to adjust our sibling index\n            if (parentChange || i > this.siblingIndex)\n            {\n                this.siblingIndex += 1;\n            }\n            \n            go.transform.SetSiblingIndex(this.siblingIndex);\n        });\n    }\n}\n\n"
                    },
                    {
                        "EditorUI": "//TODO is this Editor only?\nclass EditorUI {\n  //A variety of objects (such as EditorWindows, but also ColorPicker) use this\n  //private static objs: any[] = new Array();\n\n  private static curr: any;\n\n  public static SetPointerOverEditor(obj: any) {\n    //Debug.Log(\"Pointer over \" + this.curr)\n    this.curr = obj;\n    /*\n    if (this.objs.indexOf(obj) == -1) {\n      this.objs.push(obj);\n    }\n    */\n  }\n\n  public static RemovePointerOverEditor(obj: any) {\n    //Debug.Log(\"Pointer not over \" + this.curr);\n    if (this.curr === obj) {\n      this.curr = null;\n    }\n    /*\n    var i = this.objs.indexOf(obj);\n    if (i != -1) {\n      this.objs.splice(i, 1);\n    }\n    */\n  }\n\n  public static GetPointerOverEditor () : any{\n    return this.curr;\n  }\n\n  public static IsPointerOverEditor(): boolean {\n    return this.curr != null;\n\n    //return this.objs.length != 0;\n  }\n\n}"
                    },
                    {
                        "EditorCam": ""
                    },
                    {
                        "Dropdown": "class Dropdown extends BABYLON.GUI.StackPanel\n{\n  public isSearchable : boolean;\n  public maxOptions : number;\n  public onSelect : BABYLON.Observable<string>;\n\n  options : string[] = new Array();\n  searchInput : BABYLON.GUI.InputText;\n\n  optionStack : BABYLON.GUI.StackPanel;\n\n  filteredOptions : string[] = new Array();\n\n constructor (maxOptions : number = -1)\n {\n   super();\n   this.maxOptions = maxOptions;\n   this.onSelect = new BABYLON.Observable();\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type == BABYLON.PointerEventTypes.POINTERUP) {\n        this.dispose();\n      }\n    });\n\n    \n    this.onPointerEnterObservable.add((evt) => {\n      EditorUI.SetPointerOverEditor(this);\n    });\n\n    this.onPointerOutObservable.add((evt) => {\n      EditorUI.RemovePointerOverEditor(this);\n    });\n    \n\n    this.widthInPixels = 150;\n    this.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n }\n\n public SetOptions (options: string[])\n {\n    this.options = options;\n    this.Refresh();\n }\n\n Refresh ()\n {\n    this.searchInput = new EditorInputText();\n    this.addControl(this.searchInput);\n    this.searchInput.text = \"\";\n    this.searchInput.widthInPixels = this.widthInPixels;\n    \n    this.searchInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.searchInput.onTextChangedObservable.add((ev) => {\n      this.RefreshOptions();\n    });\n\n    this.searchInput.onKeyboardEventProcessedObservable.add((ev) =>\n    {\n      if (ev.keyCode == KeyCode.Enter)\n      {\n        if (this.filteredOptions.length > 0)\n        {\n          this.onSelect.notifyObservers(this.filteredOptions[0]);\n        }\n      }\n    });\n    this.RefreshOptions();\n    //We have to wait one frame or else we get error messages?\n    this.Focus();\n }\n\n async Focus ()\n {\n    await null;\n    UnionEditor.editorUI.moveFocusToControl(this.searchInput);\n }\n\n RefreshOptions () \n {\n   this.optionStack?.dispose();\n\n   this.optionStack = new BABYLON.GUI.StackPanel;\n   this.addControl(this.optionStack);\n   var filter = \"\";\n   if (this.isSearchable)\n   {\n     filter = this.searchInput.text;\n   }\n\n   var i = 0;\n   this.filteredOptions = new Array();\n   this.options.forEach((option : string) => {\n    if (option.toLowerCase().includes(filter.toLowerCase()))\n    {\n      if (i != -1 && i >= this.maxOptions)\n      {\n        return;\n      }\n      i++;\n      this.filteredOptions.push(option);\n      \n    }\n   });\n\n    this.filteredOptions.forEach((option : string) => {\n        var optionButton = new UnionButton(option, false);\n        optionButton.widthInPixels = this.widthInPixels;        \n        optionButton.height = \"20px\";\n        optionButton.color = UnionEditor.style.darkLineColor.toHexString();\n        optionButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n        optionButton.onPointerClickObservable.add(() =>\n        {\n          this.onSelect.notifyObservers(option);\n        });\n        this.optionStack.addControl(optionButton);\n    });\n }\n}\n"
                    },
                    {
                        "Inspector": [
                            {
                                "PropertyInspector": "class PropertyInspector extends BABYLON.GUI.StackPanel {\n\n  public onValueChanged: BABYLON.Observable<any> = new BABYLON.Observable();\n\n  //This is a variable used to store which PropertyInspector was last created\n  //We can use that to tab through the Inspectors after\n  //Currently only setup in the Text Inspector\n  public static lastCreated: PropertyInspector;\n\n  protected previous: PropertyInspector;\n  public next: PropertyInspector;\n\n  isAdjustingByMouse: boolean = false;\n  isOverThisControl: boolean = false;\n\n  //The object that 'owns' this property\n  owner: any;\n  prop: SerializedProperty;\n  valueInput: any;\n\n  public nameField: BABYLON.GUI.TextBlock;\n\n  get value(): any {\n    return this._value;\n  }\n\n  set value(v: any) {\n    this._value = v;\n  }\n\n  _value: any;\n\n  constructor(owner: any, prop: SerializedProperty, value: any) {\n    super()\n\n    this.isVertical = false;\n    //this.adaptWidthToChildren = true;\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.owner = owner;\n    this.prop = prop;\n    this.value = value;\n    this.isPointerBlocker = false;\n\n    this.heightInPixels = 22;\n    this.paddingBottom = 1;\n    this.paddingTop = 1;\n    this.nameField = new BABYLON.GUI.TextBlock(\"\", this.ConvertToInspectorName(prop.name));\n    this.nameField.paddingLeft = \"5px\";\n    this.nameField.color = UnionEditor.style.textColor.toHexString();\n    this.nameField.style = UnionEditor.fontStyle;\n    this.nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    if (owner instanceof Component) {\n      //  this.nameField.width = \"60px\"\n    }\n    else {\n      // this.nameField.resizeToFit = true;\n    }\n    this.nameField.widthInPixels = 100;\n    this.nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(this.nameField);\n    this.nameField.isPointerBlocker = false;\n\n  }\n\n  ConvertToInspectorName(value: string) {\n    var v = value.toString();\n    v = v.replace(\"_\", \" \");\n    v = v.trim();\n    //Start with uppercase\n    v = v[0].toUpperCase() + v.substring(1, v.length);\n    //padding\n    v = \"  \" + v;\n    return v;\n  }\n\n  Init() {\n\n  }\n\n  UpdateProperty(markAsDirty: boolean = true) {\n    this.owner[this.prop.name] !== this.value\n    {\n      this.owner[this.prop.name] = this.value;\n      this.onValueChanged.notifyObservers(this.value);\n      if (markAsDirty) {\n        SceneManager.MarkSceneAsDirty();\n      }\n    }\n\n  }\n\n  public static Create(c: any, key: SerializedProperty, value: any): PropertyInspector {\n    var propInspector: PropertyInspector = null;\n    //TODO using declarations in the Inspector classes this could be a bit prettier.      \n    if (key.propType != null) {\n      propInspector = new EnumInspector(c, key, value);\n    } else if (value === null) {\n      return;\n    } else if (typeof value === 'number') {\n      propInspector = new NumberInspector(c, key, value);\n    } else if (typeof value === 'string') {\n      propInspector = new TextInspector(c, key, value);\n    } else if (typeof value === 'boolean') {\n      propInspector = new BoolInspector(c, key, value);\n    } else if (value instanceof Array) {\n      propInspector = new ArrayInspector(c, key, value);\n    } else if (value instanceof Vector3) {\n      propInspector = new Vector3Inspector(c, key, value);\n    } else if (value instanceof Color) {\n      propInspector = new ColorInspector(c, key, value);\n    } else {\n      Debug.Log(\"Creating generic text inspector for \" + typeof value);\n      propInspector = new TextInspector(c, key, value);\n    }\n    propInspector.Init();\n    return propInspector;\n  }\n\n}"
                            },
                            {
                                "EnumInspector": "class EnumInspector extends PropertyInspector {\n\n  dropDown: Dropdown;\n\n  Init() {\n    super.Init();\n\n    var values: string[] = [];\n    for (var enumMember in this.prop.propType) {\n      if (typeof this.prop.propType[enumMember] === 'number') {\n        values.push(enumMember);\n      }\n    }\n\n    var v = UnionEditor.CreateButton(values[this.value]);\n\n    this.valueInput = v;\n    v.paddingLeftInPixels = 2;\n    v.paddingRightInPixels = 2;\n    v.width = \"35px\";\n    v.height = \"20px\";\n    v.color = UnionEditor.style.darkLineColor.toHexString();\n    //v.textBlock.color = UnionEditor.style.textColor.toHexString();\n    v.background = UnionEditor.style.buttonColor.toHexString();\n\n\n    \n    v.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(v);\n\n    v.onPointerClickObservable.add(() => {\n      this.dropDown?.dispose();\n      this.dropDown = new Dropdown(3);\n      this.dropDown.isSearchable = true;\n\n      this.dropDown.SetOptions(values);\n      UnionEditor.editorUI.addControl(this.dropDown);\n      this.dropDown.leftInPixels = v.centerX * 0.5 - this.widthInPixels * 0.5;\n      this.dropDown.topInPixels = v.centerY + this.heightInPixels * 0.5;\n      //Debug.Log(UnionEditor.editorUI.getSize().height)\n      this.dropDown.isPointerBlocker = true;\n      this.dropDown.onSelect.addOnce((selected: string) => {\n        this.value = this.prop.propType[selected];\n        v.textBlock.text = values[this.value];\n        this.dropDown.dispose();\n        this.UpdateProperty();\n      });\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      this.dropDown?.dispose();\n    });\n\n  }\n\n}\n"
                            },
                            {
                                "TextInspector": "class TextInspector extends PropertyInspector\n{\n  Init()\n  {\n    super.Init();\n\n    if (PropertyInspector.lastCreated)\n    {\n      //We set this up to tab through this afterwards\n      this.previous = PropertyInspector.lastCreated;\n      PropertyInspector.lastCreated.next = this;\n    }\n    PropertyInspector.lastCreated = this;\n\n    var vInput = new BABYLON.GUI.InputText();\n    this.valueInput = vInput;\n    \n    vInput.style = UnionEditor.fontStyle;\n   // vInput.paddingLeftInPixels = 2;\n   // vInput.paddingRightInPixels = 2;\n    vInput.margin = \"2px\";\n    vInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    vInput.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n    var x = new BABYLON.GUI.InputText();\n    vInput.text = this.value ? this.value : \"\";\n    vInput.width = \"100px\";\n    vInput.color =  UnionEditor.style.textColor.toHexString();\n    vInput.thickness = 0;\n    this.valueInput.onFocusSelectAll = true;\n    //When inspector inputfield is changed, update value\n    this.valueInput.onBlurObservable.add((ev) => {\n      this.UpdateValueFromText();\n    });\n\n    vInput.onKeyboardEventProcessedObservable.add((event) => {\n      if (event.key == \"Tab\")\n      {\n        var nextSelected : PropertyInspector = this.next;\n        if (event.shiftKey)\n        {\n          nextSelected = this.previous;\n        }\n        if (nextSelected)\n        {\n          UnionEditor.editorUI.moveFocusToControl(nextSelected.valueInput);\n          event.preventDefault();\n        }\n      }\n    });    \n\n    this.addControl(this.valueInput);\n    //Update the value every frame in the inspector\n    var beforeRenderObserver = Engine.editorScene.onBeforeRenderObservable.add(() =>\n    {\n       this.UpdateTextFromValue ();\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      Engine.editorScene.onBeforeRenderObservable.remove(beforeRenderObserver);\n      vInput.onKeyboardEventProcessedObservable.clear();\n      vInput.onBlurObservable.clear();\n    })\n  }\n\n  UpdateValueFromText()\n  {\n    if (this.value != this.valueInput.text)\n    {\n      this.value = this.valueInput.text;\n      this.UpdateProperty();\n    }\n  }\n\n  UpdateTextFromValue ()\n  {  \n    //this.value is checked since it may be removed (e.g. when downsizing an array)\n    if (this.value && this.owner[this.prop.name] && this.value != this.owner[this.prop.name])\n    {\n      this.value = this.owner[this.prop.name];\n      this.valueInput.text = this.value;\n    }\n  }\n}"
                            },
                            {
                                "NumberInspector": "//script:NumberInspector\nclass NumberInspector extends TextInspector {\n\n  mouseAdjustSensitivity: number = 0.01;\n\n  pointerObserver: BABYLON.Observer<any>;\n\n\n  public Init() {\n    super.Init();\n    if (this.valueInput.text == \"\") {\n      this.valueInput.text = \"0\";\n    }\n    this.valueInput.width = \"30px\";\n\n    this.onPointerEnterObservable.add((ev) => {\n      Engine.cursor = \"ew-resize\";\n      this.isOverThisControl = true;\n    });\n    this.onPointerOutObservable.add((ev) => {\n      Engine.cursor = \"default\";\n      this.isOverThisControl = false;\n    });\n\n    this.pointerObserver = Engine.scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERDOWN:\n          if (this.isOverThisControl) {\n            this.isAdjustingByMouse = true;\n            Engine.current.enterPointerlock();\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERUP:\n          if (this.isAdjustingByMouse) {\n            this.isAdjustingByMouse = false;\n            Engine.current.exitPointerlock();\n            //If adjusted, this should send a propertyUpdate\n            this.UpdateProperty();\n          }\n          break;\n        case BABYLON.PointerEventTypes.POINTERMOVE:\n          if (this.isAdjustingByMouse) {\n            this.value += pointerInfo.event.movementX * this.mouseAdjustSensitivity;\n            this.valueInput.text = this.value;\n            this.UpdateProperty(false);\n          }\n          break;\n      }\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      Engine.scene.onPointerObservable.remove(this.pointerObserver);\n    })\n  }\n\n  UpdateTextFromValue() {\n    super.UpdateTextFromValue();\n\n  }\n\n\n  //Convert the text into a number\n\n  UpdateValueFromText() {\n    \n    if (this.value !== +this.valueInput.text) {\n      var x = +this.valueInput.text;\n      if (Number.isNaN(x)) {\n        this.valueInput.text = \"0\";\n        x = 0;\n      }\n\n      this.value = x;\n      this.UpdateProperty();\n    }\n  }\n\n}"
                            },
                            {
                                "ArrayInspector": "class ArrayInspector extends PropertyInspector {\n\n  collapseButton: BABYLON.GUI.Button;\n  arrayList: BABYLON.GUI.StackPanel;\n\n  Init() {\n    super.Init();\n\n    this.collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n    this.collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.collapseButton.width = \"20px\";\n    this.collapseButton.color = UnionEditor.style.backgroundColor.toHexString();\n    this.collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    //Remove and re-add to place the collapse button in front of the name.\n    this.removeControl(this.nameField);\n    this.addControl(this.collapseButton);\n    this.addControl(this.nameField);\n\n    //Size field\n    this.valueInput = new BABYLON.GUI.InputText();\n    var vInput: BABYLON.GUI.InputText = this.valueInput;\n\n    vInput.style = UnionEditor.fontStyle;\n    vInput.paddingLeftInPixels = 10;\n    vInput.paddingRightInPixels = 2;\n    vInput.margin = \"2px\";\n    vInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    vInput.width = \"100px\";\n    vInput.height = \"20px\";\n    vInput.color = UnionEditor.style.textColor.toHexString();\n\n    vInput.onFocusSelectAll = true;\n\n    this.UpdateTextFromValue();\n    //When inspector inputfield is changed, update value\n    vInput.onBlurObservable.add((ev) => {\n      this.UpdateValueFromText();\n    });\n\n    this.addControl(this.valueInput);\n\n    this.collapseButton.onPointerUpObservable.add((evt) => {\n      if (this.arrayList) {\n        this.arrayList.dispose();\n        this.arrayList = null;\n      } else {\n        this.RefreshArrayList();\n      }\n      this.collapseButton.textBlock.text = this.arrayList ? \"v\" : \">\";\n    });\n\n    this.onDisposeObservable.addOnce(e => {\n      this.collapseButton.onPointerUpObservable.clear();\n    })\n  }\n\n  RefreshArrayList() {\n    //We remove this so it doesn't get desotryyed\n    this.arrayList?.dispose();\n\n    this.arrayList = new BABYLON.GUI.StackPanel();\n    this.arrayList.isVertical = true;\n    this.arrayList.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.arrayList.heightInPixels = (this.value.length + 1) * 20;\n\n    for (var i = 0; i < this.value.length; i++) {\n      var v = this.value[i];\n      //Null values get converted into empty strings\n      if (!v)\n        v = \"\";\n      this.arrayList.addControl(PropertyInspector.Create(this.value, {name: i.toString(), propType : null} , v));\n    }\n\n    if (this.parent) {\n      this.parent.addControl(this.arrayList);\n      this.arrayList.widthInPixels = this.parent.widthInPixels;\n    }\n  }\n\n  GetDefaultValue ()\n  {\n    if (this.value.length > 0)\n    {\n      var v = this.value[this.value.length-1];\n      if (v)\n        return v;\n    }\n    return \"\";\n  }\n\n  UpdateTextFromValue() {\n    this.valueInput.text = this.value.length;\n  }\n\n  UpdateValueFromText() {\n    if (this.value.length != +this.valueInput.text) {\n      var x = +this.valueInput.text;\n      \n      if (Number.isNaN(x)) {\n        this.UpdateTextFromValue();\n        return;\n      }\n\n      this.arrayList?.dispose();\n      \n      while (this.value.length > x) { this.value.pop(); }\n      while (this.value.length < x) { this.value.push(this.GetDefaultValue()); }\n\n      this.RefreshArrayList();\n\n      this.UpdateProperty();\n    }\n  }\n}\n"
                            },
                            {
                                "ColorInspector": "class ColorInspector extends PropertyInspector {\n\ncurrentPicker : BABYLON.GUI.ColorPicker;\n\nInit()\n  {\n    super.Init();\n\n    var colorButton : BABYLON.GUI.Button = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \"\");\n    \n    colorButton.paddingLeftInPixels = 2;\n    colorButton.paddingRightInPixels = 2;\n    colorButton.width = \"15px\";\n    colorButton.height = \"10px\";\n    colorButton.color = \"white\";\n\n    var c : BABYLON.Color3 = new BABYLON.Color3();\n    Color.UtoB(this.value, c);\n    \n    colorButton.background = c.toHexString();    \n    colorButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.addControl(colorButton);\n\n    colorButton.onPointerClickObservable.add((ev) => {  \n      this.TryDisposeColorPicker();\n      this.currentPicker = new BABYLON.GUI.ColorPicker(\"Color Picker\");\n      this.currentPicker.value = c;\n      this.currentPicker.onValueChangedObservable.add(() => {\n        Color.BtoU(this.currentPicker.value, this.value);\n        this.UpdateProperty();\n        colorButton.background = this.currentPicker.value.toHexString();        \n      });\n      this.currentPicker.onPointerEnterObservable.add((ev) => {\n        EditorUI.SetPointerOverEditor(this.currentPicker);\n      })\n      this.currentPicker.onPointerOutObservable.add((ev) => {\n        EditorUI.RemovePointerOverEditor(this.currentPicker);\n      })\n      UnionEditor.editorUI.addControl(this.currentPicker);\n    });\n\n    Engine.editorScene.onPointerObservable.add((pointerInfo) => {\n      if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP) {        \n        this.TryDisposeColorPicker();\n      }\n    });\n\n    \n\n    this.onDisposeObservable.add(() => {\n      this.TryDisposeColorPicker();\n    });\n    /*\n    this.valueInput.color = this.value;\n    this.valueInput.onValueChangedObservable.add(() => {\n      this.value = this.valueInput.color;\n      this.UpdateProperty();\n    });\n    \n    //Update the value every frame in the inspector\n    Engine.scene.onBeforeRenderObservable.add(() =>\n    {\n      if (this.valueInput.color != this.value)\n      {\n        SceneManager.MarkSceneAsDirty();\n        this.valueInput.color = this.value;\n      }\n        \n    });\n    */\n  }\n\n  TryDisposeColorPicker () \n  {\n    if (this.currentPicker)\n      {\n        this.currentPicker.dispose();\n        this.currentPicker = null;\n        return;\n      }\n  }\n\n}\n"
                            },
                            {
                                "BoolInspector": "class BoolInspector extends PropertyInspector\n{\n  Init()\n  {\n    super.Init();\n    \n    this.valueInput = new BABYLON.GUI.Checkbox(\"Checkbox\");\n    this.valueInput.paddingLeftInPixels = 2;\n    this.valueInput.paddingRightInPixels = 2;\n    this.valueInput.margin = \"2px\";\n    this.valueInput.width = \"15px\";\n    this.valueInput.height = \"10px\";\n    this.valueInput.color = \"white\";\n    \n    this.valueInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.addControl(this.valueInput);\n    \n    this.valueInput.isChecked = this.value;\n    this.valueInput.onIsCheckedChangedObservable.add(() => {\n      this.value = this.valueInput.isChecked;\n      this.UpdateProperty();\n    });\n    \n    //Update the value every frame in the inspector\n    Engine.editorScene.onBeforeRenderObservable.add(() =>\n    {\n      if (this.valueInput.isChecked != this.value)\n      {\n        this.valueInput.isChecked = this.value;\n        SceneManager.MarkSceneAsDirty();\n      }\n        \n    });\n    \n  }\n\n  \n}"
                            },
                            {
                                "Vector3Inspector": "//script:Vector3Inspector\nclass Vector3Inspector extends PropertyInspector\n{\n  Init ()\n  {\n    super.Init();\n    Serializer.GetPropValues(this.value, true).forEach((value: any, key: SerializedProperty) => {\n      var prop = PropertyInspector.Create(this.value, key, value);\n      prop.nameField.widthInPixels = 20;\n      this.addControl(prop);\n    });\n  }\n\n  Update()\n  {\n    \n  }\n\n}\n"
                            },
                            {
                                "MaterialInspector": "class MaterialInspector extends BABYLON.GUI.StackPanel {\n\n  material : Material;\n\n  propertiesPanel : BABYLON.GUI.StackPanel;\n\n  materialName : string;\n\n constructor(materialName : string) {\n    super()\n    \n    this.materialName = materialName;\n\n    var material = Material.Get(materialName);\n\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    \n    this.material = material;\n    \n    this.propertiesPanel = new BABYLON.GUI.StackPanel();\n    this.propertiesPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.propertiesPanel.isVisible = true;\n    \n    this.addControl(this.propertiesPanel);  \n\n    Serializer.GetPropValues(material, false).forEach((value: any, key: SerializedProperty) => {\n      var propInspector: PropertyInspector = PropertyInspector.Create(material, key, value);      \n      this.propertiesPanel.addControl(propInspector);\n      propInspector.onValueChanged.add((ev) => {\n        Material.SaveToJSON(this.materialName);\n      });\n    });\n   \n }\n\n \n}\n"
                            },
                            {
                                "ComponentInspector": "//script:ComponentInspector\n\nclass ComponentInspector extends BABYLON.GUI.StackPanel {\n\n  propertiesPanel: BABYLON.GUI.StackPanel;\n\n  constructor(parent: InspectorWindow, c: Component) {\n    super()\n    this.width = \"100%\";\n\n    this.AddLine(this, 2, UnionEditor.style.backgroundColor);\n    this.AddLine(this, 1, UnionEditor.style.darkLineColor);\n    this.AddLine(this, 2, UnionEditor.style.backgroundColor);\n\n    var topBar = new BABYLON.GUI.Container(\"ComponentTopBar\");\n    topBar.heightInPixels = 20;\n    topBar.width = \"100%\";\n    topBar.background = UnionEditor.style.componentBackgroundColor.toHexString();\n    this.addControl(topBar);\n\n    var namePanel = new BABYLON.GUI.StackPanel();\n\n    namePanel.isVertical = false;\n    topBar.addControl(namePanel);\n\n    var collapseButton = BABYLON.GUI.Button.CreateSimpleButton(\"B\", \">\");\n    collapseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    collapseButton.width = \"20px\";\n    collapseButton.color = UnionEditor.style.backgroundColor.toHexString();\n    collapseButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    namePanel.addControl(collapseButton);\n\n    collapseButton.onPointerUpObservable.add((evt) => {\n      this.propertiesPanel.isVisible = !this.propertiesPanel.isVisible;\n      collapseButton.textBlock.text = this.propertiesPanel.isVisible ? \"v\" : \">\";\n    });\n\n\n    var nameField = new BABYLON.GUI.TextBlock(\"\", c.constructor.name);\n\n    nameField.paddingLeft = \"5px\";\n    nameField.style = UnionEditor.fontStyleBold;\n    nameField.color = UnionEditor.style.textColor.toHexString();\n    nameField.width = \"140px\";\n    nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    nameField.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    namePanel.addControl(nameField);\n    namePanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    this.propertiesPanel = new BABYLON.GUI.StackPanel();\n    this.propertiesPanel.isVisible = true;\n\n    this.AddLine(this.propertiesPanel, 1, UnionEditor.style.semiDarkLineColor);\n    this.AddLine(this.propertiesPanel, 2, UnionEditor.style.backgroundColor);\n    this.addControl(this.propertiesPanel);\n\n    Serializer.GetPropValues(c, false).forEach((value: any, key: SerializedProperty) => {\n      var propInspector: PropertyInspector = PropertyInspector.Create(c, key, value);\n\n      this.propertiesPanel.addControl(propInspector);\n    });\n\n\n    if (c.GetType() == \"Transform\") {\n      //TODO DRY this up\n      this.propertiesPanel.isVisible = true;\n\n    } else {\n      //Transforms can't be removed\n      var deleteButton = BABYLON.GUI.Button.CreateSimpleButton(\"deleteButton\", \"x\");\n      deleteButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n      deleteButton.width = \"20px\";\n      deleteButton.color = UnionEditor.style.darkLineColor.toHexString();\n      deleteButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n      topBar.addControl(deleteButton);\n\n      deleteButton.onPointerUpObservable.add((evt) => {\n        var go: GameObject = c.gameObject;\n        Destroy(c);\n        parent.RefreshGOInspector(go);\n        /*\n        var dropDown = new Dropdown();\n          dropDown.AddOption(\"Remove Component\");\n          dropDown.linkOffsetXInPixels = 50;\n          UnionEditor.editorUI.addControl(dropDown);\n          dropDown.onSelect.add((selected: string) =>\n          {\n            if (selected == \"Remove Component\")\n            {\n              \n            }\n            \n          });       \n          */\n      });\n\n    }\n\n    collapseButton.textBlock.text = this.propertiesPanel.isVisible ? \"v\" : \">\";\n\n  }\n\n  AddLine(parent : BABYLON.GUI.Container, height: number, color: BABYLON.Color3) {\n    var topLine = new BABYLON.GUI.Rectangle(\"TopLine\");\n    topLine.heightInPixels = height;\n    topLine.thickness = 0;\n    topLine.background = color.toHexString();\n    parent.addControl(topLine);\n  }\n}"
                            },
                            {
                                "InspectorWindow": "class InspectorWindow extends EditorWindow {\n  static current: InspectorWindow;\n  currentGameObject: GameObject;\n\n  constructor() {\n    super()\n    InspectorWindow.current = this;\n    EditorSelection.onSelected.add((data: SelectionData) => {\n\n      if (data.isSelected) {\n        this.RefreshGOInspector(data.obj as GameObject);\n      } else {\n        this.Refresh();\n      }\n    });\n\n    PixelPADEvents.onAssetClicked.add((asset: string[]) => {\n      this.Refresh();\n      switch (asset[0]) {\n        case \"material\":\n          EditorSelection.SetSelectedGameObject(null);\n          this.main.addControl(new MaterialInspector(asset[1]));\n          break;\n        case \"prefab\":\n          this.Refresh();\n          this.main.addControl(new PrefabInspector(asset[1]));\n          break;\n        case \"model\":\n          this.main.addControl(new FileViewer(asset[1]));\n        break;\n        case \"texture\":\n          this.main.addControl(new FileViewer(asset[1]));\n        break;\n        case \"sound\":\n        break;\n      }\n\n    });\n\n  }\n\n  OnViewModel() {\n    this.Refresh();\n  }\n\n  OnGUI() {\n    //When a GO is about to be deleted, we should clear the inspector\n    if (this.currentGameObject && this.currentGameObject.markedForDestroy) {\n      this.Refresh();\n    }\n  }\n\n  RefreshGOInspector(go: GameObject) {\n    this.Refresh();\n    this.currentGameObject = go;\n\n    go.components.forEach((c: Component) => {\n      if (!c.markedForDestroy) {\n        this.main.addControl(new ComponentInspector(this, c));\n      }\n    });\n\n    var addButton = BABYLON.GUI.Button.CreateSimpleButton(\"\", \"Add Component\");\n    addButton.width = \"80%\";\n    addButton.height = \"25px\";\n    addButton.background = UnionEditor.style.buttonColor.toHexString();\n    addButton.color = UnionEditor.style.darkLineColor.toHexString();\n    addButton.textBlock.color = UnionEditor.style.textColor.toHexString();\n    this.main.addControl(addButton);\n    addButton.onPointerClickObservable.add(() => {\n      var dropDown = new Dropdown(3);\n      dropDown.isSearchable = true;\n\n      dropDown.SetOptions(this.GetAvailableComponents());\n      this.main.addControl(dropDown);\n      dropDown.onSelect.add((selected: string) => {\n        go.AddComponent(selected);\n        this.RefreshGOInspector(go);\n      });\n    });\n\n    //Can't edit prefabs directly.\n    if (go.prefabParent && go.prefabParent != go) {\n      let coverPanel = new BABYLON.GUI.Rectangle();\n      coverPanel.widthInPixels = this.background.widthInPixels;\n      coverPanel.heightInPixels = this.background.heightInPixels;\n      coverPanel.background = UnionEditor.style.backgroundColor.toHexString() + \"88\";\n      this.background.addControl(coverPanel);\n    }\n  }\n\n  //TODO reconsider the hackiness of this.\n  //Can be done through Serializable Fields\n  GetAvailableComponents(): string[] {\n    var components: string[] = new Array();\n    var scripts: string[] = Engine.scripts;\n    scripts.forEach((script: string) => {\n      try {\n        if (eval(script + \".isc\") == true) {\n          components.push(script);\n        }\n      } catch (e) {\n\n      }\n    });\n    return components;\n  }\n\n\n  Refresh() {\n    this.currentGameObject = null;\n    super.Refresh();\n  }\n\n}"
                            },
                            {
                                "PrefabInspector": "class PrefabInspector extends BABYLON.GUI.StackPanel {\n\n   propertiesPanel: BABYLON.GUI.StackPanel;\n\n   name: string;\n\n   constructor(prefabName: string) {\n      super()\n\n      this.name = prefabName;\n\n      var prefab = Prefab.Get(prefabName);\n\n      this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n      var nameField = new BABYLON.GUI.TextBlock(\"\", prefabName);\n\n      nameField.paddingLeft = \"5px\";\n      nameField.style = UnionEditor.fontStyleBold;\n      nameField.color =  UnionEditor.style.textColor.toHexString();\n      nameField.width = \"160px\";\n      nameField.heightInPixels = 25;\n      nameField.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n      nameField.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n\n      \n      this.heightInPixels = 400;\n      this.paddingTopInPixels = 3;\n      this.paddingBottomInPixels = 5;\n\n      this.propertiesPanel = new BABYLON.GUI.StackPanel();\n      this.propertiesPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n      this.propertiesPanel.isVisible = true;\n      \n      this.addControl(this.propertiesPanel);\n\n      this.propertiesPanel.addControl(nameField);\n\n      var createPrefabButton = UnionEditor.CreateButton(\"Create\");\n      createPrefabButton.widthInPixels = 100;\n      this.propertiesPanel.addControl(createPrefabButton);\n      createPrefabButton.onPointerClickObservable.add((ev) => {\n         Prefab.Create(prefabName);\n      });\n\n      /*\n      var savePrefabButton = UnionEditor.CreateButton(\"Save Selection\");\n      this.propertiesPanel.addControl(savePrefabButton);\n      savePrefabButton.onPointerClickObservable.add((ev) => {\n         if (!EditorSelection.currentSelectedGameObject)\n         {\n            Debug.Log(\"Select a GameObject to save\");\n         } else {\n            var prefabJson = Serializer.ToJSON(EditorSelection.currentSelectedGameObject);\n            savePrefab(prefabName, prefabJson);\n         }\n      });\n      */\n\n      var openPrefabButton = UnionEditor.CreateButton(\"Open Prefab\");\n      this.propertiesPanel.addControl(openPrefabButton);\n      openPrefabButton.onPointerClickObservable.add((ev) => {\n         if (SceneManager.GetActiveScene().isDirty)\n         {\n            alert(\"Save scene first you dumb dumb!\");\n         } else {\n            SceneManager.LoadPrefab(prefabName);\n         }\n      });\n   }\n\n\n}\n"
                            },
                            {
                                "FileViewer": "class FileViewer extends BABYLON.GUI.StackPanel {\n\n  img: BABYLON.GUI.Image;\n\n  valueInput: BABYLON.GUI.InputText;\n\n  isValidFile: boolean = false;\n  url: string;\n\n  fileType: FileType = FileType.Texture;\n\n  constructor(fileName: string) {\n    super()\n\n\n    var downloadButton = UnionEditor.CreateButton(\"Download\");\n    downloadButton.paddingTopInPixels = 10;\n    downloadButton.heightInPixels = 30;\n    this.addControl(downloadButton);\n\n    var urlButton = UnionEditor.CreateButton(\"Print URL\");\n    urlButton.paddingTopInPixels = 10;\n\n    urlButton.heightInPixels = 30;\n    this.addControl(urlButton);\n\n    urlButton.onPointerClickObservable.add(ev => {\n      //if (this.isValidFile) {\n      print(this.url);\n      //}\n    });\n\n    downloadButton.onPointerClickObservable.add(ev => {\n      // if (this.isValidFile) {\n      window.open(this.url);\n      //}\n    });\n\n    this.url = \"\";\n    if (fileName.endsWith(\".obj\")\n      || fileName.endsWith(\".gltf\")\n      || fileName.endsWith(\".glb\")\n      || fileName.endsWith(\".babylon\")) {\n\n      this.fileType = FileType.Model;\n\n\n      var scene = new BABYLON.Scene(Engine.current);\n      scene.autoClear = false;\n      scene.clearColor = new BABYLON.Color4(1, 1, 1, 1);\n\n      this.onDisposeObservable.add(e => {\n        scene.dispose();\n      });\n\n      var cam = new BABYLON.ArcRotateCamera(\"ArcRotateCamera\", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);\n      cam.position = new BABYLON.Vector3(0, 0, -25);\n      cam.wheelPrecision = 10;\n      scene.activeCamera = cam;\n\n      var bg = BABYLON.Mesh.CreatePlane(\"Background\", 100000, scene);\n      bg.rotate(new BABYLON.Vector3(0, 0, 1), Math.PI * 0.5);\n      bg.position.z = 500;\n      var m = new BABYLON.StandardMaterial(\"BackgroundMat\", scene);\n      m.disableLighting = true;\n      bg.material = m;\n      //Parented so it follows when the camera zooms/rotates\n      bg.setParent(cam);\n\n      var light = new BABYLON.DirectionalLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\n      light.intensity = .7;\n\n      this.url = getModel(fileName);\n\n      //Load the model\n      var urlObj = URLResult.Create(fileName, FileType.Model);\n      var viewedObject = new BABYLON.TransformNode(\"ViewedObject\", scene);\n\n      BABYLON.SceneLoader.ImportMesh(\"\", urlObj.baseUrl, urlObj.fullName, scene, (meshes) => {\n        meshes.forEach(m => {\n          m.setParent(viewedObject);\n        });\n        viewedObject.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n      });\n\n\n      this.RecreateTextureImage();\n\n      var isAttached = false;\n\n      this.img.onPointerEnterObservable.add(e => {\n        if (!isAttached) {\n          cam.attachControl(Engine.canvas, false);\n          isAttached = true;\n        }\n      });\n\n      this.img.onPointerOutObservable.add(e => {\n        if (isAttached)\n        {\n          cam.detachControl(Engine.canvas);\n          isAttached = false;\n        }\n      });\n      //Render \n      Engine.editorScene.onAfterRenderObservable.add(e => {\n        light.setDirectionToTarget(bg.absolutePosition);\n        //Map Camera to the texture\n        EditorHelpers.MapCamToGUIContainer(cam, this.img);\n        scene.render();\n      });\n\n\n    } else if (fileName.endsWith(\".png\") || fileName.endsWith(\".jpg\")) {\n      this.fileType = FileType.Texture;\n\n      this.RecreateTextureImage();\n\n      this.url = getTexture(fileName);\n\n      //Load the texture\n      this.img.source = this.url;\n\n    } else {\n      Debug.Log(\"Unrecognized file-format.\");\n      return;\n    }\n    if (!this.url) {\n      Debug.Log(\"Unrecognized filename\");\n      return;\n    }\n  }\n\n  RecreateTextureImage() {\n    this.img?.dispose();\n    this.img = new BABYLON.GUI.Image(\"TextureViewer\");\n    this.img.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n    this.img.width = \"150px\";\n    this.img.height = \"150px\";\n    this.img.paddingTop = \"10px\";\n    this.img.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM;\n    this.addControl(this.img);\n  }\n\n\n}\n"
                            }
                        ]
                    },
                    {
                        "EditorInputText": "class EditorInputText extends BABYLON.GUI.InputText {\n\n  constructor ()\n  {\n    super(\"EditorInputText\");\n    this.style = UnionEditor.fontStyle;\n    this.paddingLeftInPixels = 2;\n    this.paddingRightInPixels = 2;\n    this.margin = \"2px\";\n    this.width = \"150px\"\n    this.height = \"20px\";\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n    this.color = \"white\";\n  }\n}\n"
                    },
                    {
                        "HierarchyList": "class HierarchyList extends BABYLON.GUI.StackPanel {\n\n  tabSize: number = 10;\n  parentItem: HierarchyItem\n  items: HierarchyItem[];\n\n  constructor(objs: GameObject[], offset: number, parentItem: HierarchyItem) {\n    super(\"HierarchyList\");\n\n    this.parentItem = parentItem;\n    this.leftInPixels = offset;\n\n\n    this.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;\n\n    var i: number = 0;\n    this.items = new Array();\n\n    objs.forEach((obj: GameObject) => {\n      if (!obj)\n        return;\n\n\n      var splitItem = new HierarchySplitItem(this, i);\n      this.addControl(splitItem.background);\n      i++;\n\n      var item = new HierarchyItem(this, obj);\n      this.items.push(item);\n      this.addControl(item.p);\n      \n      item.onSelect.add(() => {\n        if (Input.GetKey(KeyCode.Control)) {\n          EditorSelection.ToggleSelectedGameObject(obj);\n\n        } else if (Input.GetKey(KeyCode.Shift)) {\n          if (EditorSelection.HasSelection()) {\n            var sel = EditorSelection.GetSelection();\n            var lastSelectedObject = sel[sel.length - 1];\n\n            this.state = 0;\n            this.GoThroughSelection(SceneManager.GetActiveScene().rootObjs, lastSelectedObject, item.obj);\n          }\n        } else {\n          EditorSelection.SetSelectedGameObject(obj);\n        }\n\n\n      });\n\n      //Slighly hacky way to ensure the newly created object is selected.\n      /*\n      if (obj == EditorSelection.currentSelectedGameObject) {\n        EditorSelection.SetSelectedGameObject(null);\n        EditorSelection.SetSelectedGameObject(obj);\n      }\n      */\n    });\n\n    //One split item at the bottom\n    var splitItem = new HierarchySplitItem(this, i);\n    this.addControl(splitItem.background);\n  }\n\n  state: number = 0;\n\n  GoThroughSelection(siblings: GameObject[], go1: GameObject, go2: GameObject) {\n\n    //state starts at 0: which means don't select items\n    //when it hits either GameObject, start selecting\n    //when it hits the next GameObject, stop everything.\n\n    //We collapse all children before we collapse a parent\n    siblings.forEach(item => {\n      if (item == null)\n        return;\n        \n      if (this.state > 1)\n        return;\n\n      if (item === go1 || item === go2) {\n        EditorSelection.AddSelectedGameObject(item);\n        this.state++;\n      }\n\n      if (this.state == 1) {\n        EditorSelection.AddSelectedGameObject(item);\n      }\n\n      this.GoThroughSelection(item.transform.ser_children, go1, go2);\n\n\n\n    });\n  }\n}\n\n"
                    },
                    {
                        "Undo": "class Undo {\n\n  public static isUndoing: boolean;\n  private static scores: Map<string, UndoData> = new Map();\n\n  public static Init() {\n    Engine.scene.onKeyboardObservable.add((keybrd) => {\n      if (Engine.isPlaying || SceneManager.isReloading) {\n        return;\n      }\n      if (keybrd.type == BABYLON.KeyboardEventTypes.KEYDOWN) {\n        if (keybrd.event.ctrlKey || keybrd.event.metaKey) {\n          keybrd.event.preventDefault();\n          if (keybrd.event.key === \"z\") {\n            Undo.PerformUndo();\n          } else if (keybrd.event.key === \"y\") {\n            Undo.PerformRedo();\n          }\n        }\n      }\n\n    });\n\n  }\n\n  public static RecordState() {\n    if (Engine.isPlaying || SceneManager.isReloading) {\n      return;\n    }\n    let history = Undo.GetHistory();\n    let sceneData = Serializer.ToJSON(SceneManager.GetActiveScene(), false);\n    //We slice the list off, in case some actions were undone, and then we continue working\n    history.actionList = history.actionList.slice(0, history.index + 1);\n    history.actionList.push(new UndoActionData(UndoType.Action, sceneData));\n    history.index = history.actionList.length - 1;\n  }\n\n  public static RecordSelection() {\n    //let history = Undo.GetHistory();\n  }\n\n  @MenuItem(\"Edit/Undo\")\n  public static PerformUndo() {\n    \n    if (Engine.isPlaying || SceneManager.isReloading) {\n      return;\n    }\n\n    let history = Undo.GetHistory();\n\n    //If it's the 'first' undo, we mark as dirty so the last state is also saved!\n    //if (history.index >= history.actionList.length-1)\n    {\n      //  print(\"THIS IS IT\");\n      // SceneManager.MarkSceneAsDirty();\n      //  history.index = history.actionList.length-1;\n    }\n    \n    if (history.index > 0) {\n      history.index--;\n    }\n    Undo.LoadScene();\n  }\n\n  @MenuItem(\"Edit/Redo\")\n  public static PerformRedo() {\n    if (Engine.isPlaying || SceneManager.isReloading) {\n      return;\n    }\n    let history = Undo.GetHistory();\n    if (history.index < history.actionList.length - 1) {\n      history.index++;\n    }\n    Undo.LoadScene();\n  }\n\n  private static LoadScene() {\n    if (Engine.isPlaying || SceneManager.isReloading) {\n      return;\n    }\n\n    let history = Undo.GetHistory();\n\n    SceneManager.LoadSceneData(history.actionList[history.index].undoData);\n  }\n\n  private static GetHistory(): UndoData {\n    let sceneName = SceneManager.GetActiveScene().name;\n    let history: UndoData;\n    if (Undo.scores.has(sceneName)) {\n      history = Undo.scores.get(sceneName);\n    } else {\n      history = new UndoData();\n      Undo.scores.set(sceneName, history);\n    }\n\n    return history;\n  }\n\n\n\n}\n\nclass UndoData {\n  index: number = 0;\n  actionList: UndoActionData[] = new Array();\n}\n\nclass UndoActionData {\n  constructor(undoType: UndoType, undoData: string) {\n    this.undoType = undoType;\n    this.undoData = undoData;\n  }\n\n  undoType: UndoType;\n  undoData: string;\n}\n\nenum UndoType {\n  Action,\n  Selection\n}\n"
                    }
                ]
            },
            {
                "PhysicsDir": [
                    {
                        "Physics": "//script:Physics\n\nclass Physics {\n  public static gravity: BABYLON.Vector3 = new BABYLON.Vector3(0, -9.81, 0);\n\n  static Init() {\n    Engine.scene.onBeforeStepObservable.add(() => {\n\n      Physics.BeforePhysicsUpdate();\n    });\n  }\n\n  public static GetOp(obj: BABYLON.IPhysicsEnabledObject): ObjectPhysics {\n    var x = obj as BABYLON.AbstractMesh;\n    var go: GameObject = Engine.meshToObject[x.uniqueId];\n    return go.objectPhysics;\n  }\n\n  private static BeforePhysicsUpdate() {\n\n    var imposters = Engine.scene._physicsEngine.getImpostors();\n\n    //We reset all trigger bools\n    for (var i = 0; i < imposters.length; i++) {\n      var op = this.GetOp(imposters[i].object);\n      op?.triggerMap?.forEach((value: boolean, key: number) => {\n        op.triggerMap.set(key, false);\n      });\n    }\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = this.GetOp(imposters[i].object);\n      if (op?.rb) {\n        //Gravity\n        if (op.rb.useGravity) {\n          imposters[i].applyForce(Physics.gravity.scale(imposters[i].mass), imposters[i].getObjectCenter());\n        }\n        for (var j = 0; j < imposters.length; j++) {\n          var op2 = this.GetOp(imposters[j].object);\n          if (op?.coll?.hasStarted && op2?.coll?.hasStarted && op.coll.boundsMesh.uniqueId != op2.coll.boundsMesh.uniqueId) {\n            if (op.coll.isTrigger || op2.coll.isTrigger) {\n              if (this.Intersects(op, op2)) {\n                //Avoid double triggering of two rigidbodies\n                if (!op2.triggerMap.get(op.coll.boundsMesh.uniqueId)) {\n                  //If was already triggering...\n                  if (op.triggerMap.has(op2.coll.boundsMesh.uniqueId)) {\n                    try {\n                      op.coll.gameObject.OnTriggerStay(op2.coll);\n                    } catch (e) { Debug.Log(e); }\n                    try {\n                      op2.coll.gameObject.OnTriggerStay(op.coll);\n                    } catch (e) { Debug.Log(e); }\n                  } else {\n                    try {\n                      op.coll.gameObject.OnTriggerEnter(op2.coll);\n                    } catch (e) { Debug.Log(e); }\n                    try {\n                      op2.coll.gameObject.OnTriggerEnter(op.coll);\n                    } catch (e) { Debug.Log(e); }\n                  }\n                  op.triggerMap.set(op2.coll.boundsMesh.uniqueId, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n\n    for (var i = 0; i < imposters.length; i++) {\n      var op = this.GetOp(imposters[i].object);\n      op?.triggerMap?.forEach((value: boolean, key: number) => {\n        //If it was not set to true, it means it did not trigger this frame\n        if (!value) {\n\n          if (ObjectPhysics.colliderMap.has(key)) {\n            var otherCollider = ObjectPhysics.colliderMap.get(key);\n            //otherCollider is null when the PhysicsImpostor is not set up yet\n            if (otherCollider) {\n              try {\n                op.coll.gameObject.OnTriggerExit(otherCollider);\n              } catch (e) { Debug.Log(e); }\n              try {\n                otherCollider.gameObject.OnTriggerExit(op.coll);\n              } catch (e) { Debug.Log(e); }\n              op.triggerMap.delete(key);\n            }\n          }\n        }\n      });\n    }\n  }\n\n  private static Intersects(op: ObjectPhysics, op2: ObjectPhysics): boolean {\n\n    var box: number = BABYLON.PhysicsImpostor.BoxImpostor;\n    var sphere: number = BABYLON.PhysicsImpostor.SphereImpostor;\n\n    if (op.coll.GetImpostor() == box && op2.coll.GetImpostor() == box) {\n      return (op.mesh.intersectsMesh(op2.mesh, true));\n    }\n\n    if (op.coll.GetImpostor() == box && op2.coll.GetImpostor() == sphere) {\n      return this.BoxSphereIntersects(op, op2);\n    }\n\n    if (op.coll.GetImpostor() == sphere && op2.coll.GetImpostor() == box) {\n      return this.BoxSphereIntersects(op2, op);\n    }\n\n    if (op.coll.GetImpostor() == sphere && op2.coll.GetImpostor() == sphere) {\n      return this.SphereToSphere(op2.mesh.position, this.GetSphereRadius(op2.mesh), op.mesh.position, this.GetSphereRadius(op.mesh));\n    }\n\n    return false;\n  }\n\n  private static BoxSphereIntersects(op: ObjectPhysics, op2: ObjectPhysics): boolean {\n    //We get the maxScale of the sphere, since we only allow the sphere to be perfectly round\n    var radius = this.GetSphereRadius(op2.mesh);\n\n    return this.SphereToAABB(op2.mesh.position, radius, op.mesh);\n  }\n\n  private static SphereToAABB(position: BABYLON.Vector3, radius: number, box: BABYLON.AbstractMesh): boolean {\n    //Make the position relative to the box\n    var p = position.subtract(box.absolutePosition);\n\n    //Rotate the resulting Vector by the inverted box rotation (to make the comparison axis aligned)\n    p.rotateByQuaternionToRef(BABYLON.Quaternion.Inverse(box.absoluteRotationQuaternion), p);\n\n    var s = box.absoluteScaling;\n\n    //Getting the closest point is easy since it's axis aligned\n    var closesPoint = new BABYLON.Vector3(\n      Mathf.Clamp(p.x, -s.x * 0.5, s.x * 0.5),\n      Mathf.Clamp(p.y, -s.y * 0.5, s.y * 0.5),\n      Mathf.Clamp(p.z, -s.z * 0.5, s.z * 0.5));\n\n\n    var dSqrd = BABYLON.Vector3.DistanceSquared(p, closesPoint);\n\n    return radius * radius > dSqrd;\n  }\n\n  private static SphereToSphere(p1: BABYLON.Vector3, r1: number, p2: BABYLON.Vector3, r2: number): boolean {\n    return BABYLON.Vector3.DistanceSquared(p1, p2) < (r1 + r2) * (r1 + r2);\n  }\n\n  public static OverlapSphere(position: Vector3, radius: number): Collider[] {\n    var imposters = Engine.scene._physicsEngine.getImpostors();\n\n    var colliders: Collider[] = new Array();\n\n    var box: number = BABYLON.PhysicsImpostor.BoxImpostor;\n    var sphere: number = BABYLON.PhysicsImpostor.SphereImpostor;\n\n    for (var j = 0; j < imposters.length; j++) {\n      var op = this.GetOp(imposters[j].object);\n      if (op.coll != null) {\n        if (op.coll.GetImpostor() == box) {\n          if (this.SphereToAABB(Vector3.VtoB(position, new BABYLON.Vector3()), radius, op.mesh)) {\n            colliders.push(op.coll);\n          }\n        } else if (op.coll.GetImpostor() == sphere) {\n          if (this.SphereToSphere(Vector3.VtoB(position, new BABYLON.Vector3()), radius, op.mesh.position, this.GetSphereRadius(op.mesh))) {\n            colliders.push(op.coll);\n          }\n        }\n      }\n    }\n\n    return colliders;\n  }\n\n  private static GetSphereRadius(mesh: BABYLON.AbstractMesh) {\n    return Math.max(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z) * 0.5;\n  }\n\n\n\n\n}"
                    },
                    {
                        "Rigidbody": "@RegisterAsComponent\nclass Rigidbody extends Component {\n\n  private _vel: Vector3 = new Vector3();\n  private _angularVel: Vector3 = new Vector3();\n\n  private get objectPhysics(): ObjectPhysics {\n    return this.gameObject.objectPhysics;\n  }\n\n  //region mass\n  public get mass(): number {\n    return this._mass;\n  }\n\n  public set mass(value: number) {\n    //Setting the mass to 0 will break the physics\n    if (value === 0) {\n      value = 0.00001;\n    }\n\n    this._mass = value;\n    this.UpdateMass();\n  }\n\n  get velocity(): Vector3 {\n    if (this.objectPhysics.physicsImpostor) {\n      Vector3.BtoV(this.objectPhysics.physicsImpostor.getLinearVelocity(), this._vel);\n    }\n    return this._vel;\n  }\n\n  set velocity(value: Vector3) {\n\n    this._vel = value;\n    this._vel.onChange.add(() => {\n      if (this.objectPhysics.physicsImpostor) {\n        this.objectPhysics.physicsImpostor.setLinearVelocity(Vector3.VtoB(this._vel, new BABYLON.Vector3()));\n      }\n    });\n\n    this._vel.onChange.notifyObservers(null);\n  }\n\n  get angularVelocity(): Vector3 {\n    if (this.objectPhysics.physicsImpostor) {\n      Vector3.BtoV(this.objectPhysics.physicsImpostor.getAngularVelocity(), this._angularVel);\n    }\n    return this._angularVel;\n  }\n\n  set angularVelocity(value: Vector3) {\n\n    this._angularVel = value;\n    this._angularVel.onChange.add(() => {\n      if (this.objectPhysics.physicsImpostor) {\n        this.objectPhysics.physicsImpostor.setAngularVelocity(Vector3.VtoB(this._angularVel, new BABYLON.Vector3()));\n      }\n    });\n    this._angularVel.onChange.notifyObservers(null);\n  }\n\n  @SerializeField\n  private _mass: number = 10;\n  //endregion\n\n  //region restitution\n\n  public get restitution(): number {\n    return this._restitution;\n  }\n\n  public set restitution(value: number) {\n    if (this.objectPhysics.physicsImpostor && this.objectPhysics.physicsImpostor.restitution != value) {\n      this.objectPhysics.physicsImpostor.restitution = value;\n    }\n    this._restitution = value;\n  }\n\n  @SerializeField\n  private _restitution: number = 0.5;\n\n  //endregion\n\n  //region friction\n  public get friction(): number {\n    return this._friction;\n  }\n\n  public set friction(value: number) {\n    //Multiply by 10 to have similar numbers as before.\n    if (this.objectPhysics.physicsImpostor != null) {\n      this.objectPhysics.physicsImpostor.friction = value * 10;\n    }\n    this._friction = value;\n  }\n\n  @SerializeField\n  private _friction: number = 0.5;\n  //endregion\n\n  //region isKinematic\n  public get isKinematic(): boolean {\n    return this._isKinematic;\n  }\n\n  public set isKinematic(value: boolean) {\n\n    //Only update when changed.\n    //We need a wasKinematic since isKinematic is the serialized value\n    if (this._wasKinematic != value) {\n      this._wasKinematic = value;\n      this._isKinematic = value;\n      //We check for the impostor since the setter in objectPhysics needs it\n      if (this.objectPhysics.physicsImpostor) {\n        {\n          this.UpdateMass();\n          if (value) {\n            //Reset velocity.\n            this.objectPhysics.MarkForUpdate();\n          }\n        }\n      }\n    }\n\n  }\n\n  @SerializeField\n  private _isKinematic: boolean = false;\n  private _wasKinematic: boolean = false;\n  //endregion\n\n  UpdateMass() {\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.mass = this.isKinematic ? 0 : this._mass;\n    }\n  }\n\n  //Works! Cannon.js had to be modified to not calculate friction based on gravity\n  useGravity: boolean = true;\n\n\n  Awake() {\n    this.objectPhysics.MarkForUpdate();\n  }\n\n  FixedUpdate() {\n    //Force setter\n    if (this._isKinematic != this._wasKinematic) {\n      this.isKinematic = this._isKinematic;\n    }\n    this.restitution = this.restitution;\n    this.friction = this.friction;\n  }\n\n  OnDestroy() {\n\n    this.objectPhysics.MarkForUpdate();\n\n  }\n\n  //When the mesh changes, we need to recreate the Impostor\n  //With a Rigidbody, we only need to change some values.\n  UpdateValuesToImpostor() {\n    //force setters\n    this.mass = this.mass;\n    this.restitution = this.restitution;\n\n    this.friction = this.friction;\n    this.isKinematic = this.isKinematic;\n  }\n}\n"
                    },
                    {
                        "Collider": "class Collider extends Component {\n  //Only used for it's uniqueId\n  public boundsMesh: BABYLON.TransformNode;\n\n  protected bounds: BABYLON.BoundingInfo;\n  protected boundingBoxLines: BABYLON.LinesMesh;\n\n\n  protected get objectPhysics(): ObjectPhysics {\n    return this.gameObject.objectPhysics;\n  }\n\n  //Overridden by Specific Colliders (e.g. BoxCollider)\n  public GetImpostor(): number {\n    return -1;\n  }\n\n  public get isTrigger(): boolean {\n    return this._isTrigger;\n  }\n\n  public set isTrigger(value: boolean) {\n    this._isTrigger = value;\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionResponse = this.isTrigger ? 0 : 1;\n    }\n  }\n\n  @SerializeField\n  _isTrigger = false;\n\n  wasTrigger = false;\n\n  public get layer(): number {\n    return this._layer;\n  }\n\n  public set layer(value: number) {\n    this._layer = value;\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionFilterGroup = value;\n    }\n  }\n\n  @SerializeField\n  _layer: number = 1;\n\n  public get layerMask(): number {\n    return this._layerMask;\n  }\n\n  public set layerMask(value: number) {\n    this._layerMask = value;\n    if (this.objectPhysics.physicsImpostor) {\n      this.objectPhysics.physicsImpostor.physicsBody.collisionFilterMask = value;\n    }\n  }\n\n  @SerializeField\n  _layerMask: number = 1;\n\n\n  Awake() {\n    this.boundsMesh = new BABYLON.TransformNode(\"BoundsMesh\", Engine.scene);\n\n    var min = new BABYLON.Vector3(-0.5, -0.5, -0.5);\n    var max = new BABYLON.Vector3(0.5, 0.5, 0.5);\n    this.bounds = new BABYLON.BoundingInfo(min, max);\n    //We make it a child to it scales along with transform\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n\n      //Scaling is not supported by PhysicsImpostors. Every time the scale changes we should update it\n      this.transform.localScale.onChange.add((i: number) => {\n        this.objectPhysics.UpdatePhysicsImpostor();\n      });\n    }\n  }\n\n\n  FixedUpdate() {\n    if (Engine.isPlaying) {\n      //Pretty hacky solution to allow for Inspector Updates.\n      if (this._isTrigger != this.wasTrigger) {\n        this.isTrigger = this._isTrigger;\n        this.wasTrigger = this._isTrigger;\n      }\n      this.layer = this.layer;\n      this.layerMask = this.layerMask;\n    }\n    if (this.boundingBoxLines)\n      this.boundingBoxLines.setEnabled(EditorSelection.IsSelected(this.gameObject, true));\n  }\n\n  OnDestroy() {\n    if (Engine.isPlaying) {\n      this.objectPhysics.MarkForUpdate();\n    }\n\n    this.boundsMesh?.dispose();\n    this.boundingBoxLines?.dispose();\n  }\n\n  //When the mesh changes, we need to recreate the Impostor\n  //With a Rigidbody, we only need to change some values.\n  UpdateValuesToImpostor() {\n    this.objectPhysics.physicsImpostor.type = this.GetImpostor();\n    this.isTrigger = this.isTrigger;\n  }\n\n}"
                    },
                    {
                        "BoxCollider": "//script:BoxCollider\n@ExecuteInEditMode\n@RegisterAsComponent\nclass BoxCollider extends Collider {\n\n  @SerializeField\n  _size: Vector3 = new Vector3(1, 1, 1);\n\n  resizeObserver : BABYLON.Observer<any>;\n  recenterObserver : BABYLON.Observer<any>;\n\n  get size(): Vector3 {\n    return this._size;\n  }\n\n  set size(value: Vector3) {\n    this._size?.onChange.remove(this.resizeObserver);\n    this._size = value;\n    this.resizeObserver = this._size.onChange.add(() => {\n      this.ReconstructMeshLines();\n    });\n    this._size.onChange.notifyObservers(null);\n  }\n\n  @SerializeField\n  _center: Vector3 = new Vector3(0, 0, 0);\n\n  get center(): Vector3 {\n    return this._center;\n  }\n\n  set center(value: Vector3) {\n    this._size?.onChange.remove(this.recenterObserver);\n    this._center = value;\n    this._center.onChange.add(() => {\n      this.ReconstructMeshLines();\n    });\n    this._center.onChange.notifyObservers(null);\n  }\n\n  ReconstructMeshLines() {\n    this.bounds.reConstruct(\n      new BABYLON.Vector3(this.center.x + this.size.x * -0.5, this.center.y + this.size.y * -0.5, this.center.z + this.size.z * -0.5),\n      new BABYLON.Vector3(this.center.x + this.size.x * 0.5, this.center.y + this.size.y * 0.5, this.center.z + this.size.z * 0.5));\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n    if (Engine.isPlaying) {\n      this.objectPhysics.UpdatePhysicsImpostor();\n    }\n    //Drawing bounding boxes\n    var myPoints = [\n      this.bounds.minimum,\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      this.bounds.minimum,\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.maximum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.minimum.z),\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.maximum.y, this.bounds.minimum.z),\n      this.bounds.maximum,\n      new BABYLON.Vector3(this.bounds.maximum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      this.bounds.maximum,\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.minimum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.maximum.z),\n      new BABYLON.Vector3(this.bounds.minimum.x, this.bounds.maximum.y, this.bounds.minimum.z)\n    ];\n\n    if (this.boundingBoxLines)\n      this.boundingBoxLines.dispose();\n\n    this.boundingBoxLines = BABYLON.MeshBuilder.CreateLines(\"lines\", { points: myPoints }, Engine.scene);\n    this.boundingBoxLines.setParent(this.transform.transformNode);\n    this.boundingBoxLines.color = BABYLON.Color3.Green();\n    this.boundingBoxLines.position = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.rotation = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.scaling = BABYLON.Vector3.One();\n    this.boundingBoxLines.setEnabled(false);\n  }\n\n  Awake() {\n    super.Awake();\n    this.size = this._size ? this._size.clone() : Vector3.One();\n    this.center = this._center ? this._center.clone() : Vector3.Zero();\n  }\n\n  public GetImpostor(): number {\n    return BABYLON.PhysicsImpostor.BoxImpostor;\n  }\n\n  FixedUpdate() {\n    super.FixedUpdate();\n    //Simple setter for SerializeField\n    this.size;\n    this.center;\n  }\n\n  OnDestroy()\n  {\n    this._size?.onChange.remove(this.resizeObserver);\n    this._center?.onChange.remove(this.recenterObserver);\n    this.boundingBoxLines?.dispose();\n  }\n\n}"
                    },
                    {
                        "SphereCollider": "@ExecuteInEditMode\n@RegisterAsComponent\nclass SphereCollider extends Collider {\n\n  @SerializeField\n  radius: number = 1;\n  private prevRadius: number = 0;\n\n  //Increase to get more round gizmos\n  private gizmoPrecision = 150;\n\n  //This is a magical number to allow for the drawn gizmos to be the same as the radius in engine\n  private radiusMultiplier = 75;\n\n  public GetImpostor(): number {\n    return BABYLON.PhysicsImpostor.SphereImpostor;\n  }\n\n  FixedUpdate() {\n    if (this.radius != this.prevRadius) {\n      this.prevRadius = this.radius;\n      this.ReconstructMeshLines();\n    }\n    super.FixedUpdate();\n\n  }\n\n  ReconstructMeshLines() {\n    this.bounds.reConstruct(\n      new BABYLON.Vector3(-this.radius * 0.5,-this.radius * 0.5, -this.radius * 0.5), \n      new BABYLON.Vector3(this.radius * 0.5,this.radius * 0.5, this.radius * 0.5));\n    this.transform.transformNode.setBoundingInfo(this.bounds);\n    if (Engine.isPlaying)\n    {\n      this.objectPhysics.UpdatePhysicsImpostor();\n    }\n\n    this.boundingBoxLines?.dispose();\n    this.boundingBoxLines = new BABYLON.LinesMesh(\"SphereBounds\", Engine.scene);\n    this.boundingBoxLines.parent = this.transform.transformNode;\n    this.boundingBoxLines.setEnabled(false);\n    \n    this.DrawCircle(0);\n    this.DrawCircle(1);\n    this.DrawCircle(2);\n  }\n\n  DrawCircle (axis : number)\n  {\n    var tess = this.gizmoPrecision;\n    \n    var radius = this.radius * this.radiusMultiplier;\n    var pi2 = Math.PI * 2;\n    var p = [];\n    for (var i = 0; i <= tess; i++) {\n        var ang = i * pi2 / tess;\n        var c1 = radius * Math.cos(ang) / tess;\n        var c2 = radius * Math.sin(ang) / tess;\n        var x = axis == 0 ? 0 : c1;\n        var y = axis == 1 ? 0 : c2;\n        var z = axis == 2 ? 0 : axis == 1 ? c2 : c1;\n        p.push(new BABYLON.Vector3(x,y,z));\n    }\n\n    \n    var circle = BABYLON.Mesh.CreateLines('circle', p, Engine.scene);\n    circle.parent = this.boundingBoxLines;\n    circle.color = new BABYLON.Color3(0, 1, 0);\n\n  }\n\n  \n\n\n}"
                    },
                    {
                        "ObjectPhysics": "\n//ObjectPhysics handling the connection of Colliders & Rigidbodies.\n//Because Babylon combines all of that in a PhysicsImpostor, both colliders and rigidbodies affect the same ObjectPhysics\nclass ObjectPhysics /*implements BABYLON.IPhysicsEnabledObject */{\n\n  public static colliderMap: Map<number, Collider> = new Map();\n  public triggerMap: Map<number, boolean> = new Map();\n\n  public get isKinematic(): boolean {\n    return this._isKinematic;\n  }\n\n  public set isKinematic(value: boolean) {\n    this._isKinematic = value;\n  }\n\n  private _isKinematic: boolean;\n\n  private go: GameObject;\n  public get physicsImpostor (): BABYLON.PhysicsImpostor\n  {\n    return this.go.transform?.transformNode.physicsImpostor;\n  };\n\n  public set physicsImpostor (value: BABYLON.PhysicsImpostor)\n  {\n    if (this.go.transform)\n      this.go.transform.transformNode.physicsImpostor = value;\n  };\n\n  private refresh: boolean = false;\n\n  public get rb(): Rigidbody {\n    if (this._rb == null || this._rb.markedForDestroy) {\n      this._rb = this.go.GetComponent(Rigidbody);\n    }\n    return this._rb;\n  }\n\n  private _rb: Rigidbody;\n\n  public get coll(): Collider {\n    if (this._coll == null || this._coll.markedForDestroy) {\n      this._coll = this.go.GetComponent(Collider);\n    }\n    return this._coll;\n  }\n\n  private _coll: Collider;\n\n  private collidingImpostors: BABYLON.PhysicsImpostor[];\n\n  private afterStepObserver : BABYLON.Observer<any>;\n\n  Init(go: GameObject) {\n    this.go = go;\n     this.afterStepObserver = Engine.scene.onAfterStepObservable.add(() => {\n      if (this.refresh) {\n        this.refresh = false;\n        this.UpdatePhysicsImpostor();\n      }\n    });\n  }\n\n  public MarkForUpdate() {\n    this.refresh = true;\n  }\n\n  TryDisposePhysicsImpostor() {\n    //We have to remove the old physicsImposter\n    if (this.physicsImpostor != null) {\n      if (this.coll) {\n        ObjectPhysics.colliderMap.delete(this.coll.boundsMesh.uniqueId);\n      }\n      this.physicsImpostor.dispose();\n      this.physicsImpostor = null;\n    }\n  }\n\n  UpdatePhysicsImpostor() {\n    this.TryDisposePhysicsImpostor();\n\n    //This is usually just when the GameObject is being Destroyed.\n    if (this.go.markedForDestroy || this.go.transform == null) {\n      return;\n    }\n\n    //Justs a Rigidbody collides with nothing\n    var imposterType = BABYLON.PhysicsImpostor.NoImpostor;\n    if (this.coll != null) {\n      imposterType = this.coll.GetImpostor();\n    }\n\n    var mass = this.rb ? this.rb.mass : 0;\n    \n    //We unparent before creating the physics impostor\n    //This is because of a bug where the parents rotation is not considered properly when creating a physics impostor\n    var prevParent = this.go.transform.parent;\n    this.go.transform.SetParent(null, true);\n\n    this.physicsImpostor = new BABYLON.PhysicsImpostor(this.go.transform.transformNode,\n      imposterType,\n      //Set to mass here so setMass(0) actually updates\n      { mass: mass, restitution: 1, ignoreParent : true},\n      Engine.scene);\n\n    //We have to call this setter once in order for friction to work...\n    this.physicsImpostor.friction = 0.5;\n    this.go.transform.SetParent(prevParent, true);\n\n\n    if (this.coll != null && this.rb != null) {\n      this.collidingImpostors = Engine.scene._physicsEngine.getImpostors();\n      this.physicsImpostor.registerOnPhysicsCollide(this.collidingImpostors, (main, collided) => {\n        this.InternalOnCollide(collided);\n      });\n    }\n\n\n    if (this.coll != null) {\n      this.coll.UpdateValuesToImpostor();\n      ObjectPhysics.colliderMap.set(this.coll.boundsMesh.uniqueId, this.coll);\n    }\n\n    if (this.rb != null) {\n      this.rb.UpdateValuesToImpostor();\n    }\n  }\n\n  InternalOnCollide(collided: BABYLON.PhysicsImpostor) {\n    var otherObjPhysics = Physics.GetOp(collided.object);\n    var otherCollider: Collider = otherObjPhysics.coll;\n    if (!this.coll || !otherObjPhysics.coll)\n      return;\n\n    if (this.coll.isTrigger || otherCollider.isTrigger) {\n      //OnTriggerEvents are handled in the Physics class\n    }\n    else {\n      var c1 = new Collision();\n      c1.collider = otherCollider;\n      c1.gameObject = otherCollider.gameObject;\n      c1.transform = otherCollider.transform;\n      c1.rigidbody = otherCollider.GetComponent(Rigidbody);\n\n      var myVel = this.rb ? this.rb.velocity : new Vector3();\n      var theirVel = c1.rigidbody ? c1.rigidbody.velocity : new Vector3();\n      c1.relativeVelocity = new Vector3(myVel.x - theirVel.x, myVel.y - theirVel.y, myVel.z - theirVel.z);\n\n      var c2 = new Collision();\n      c2.collider = this.coll;\n      c2.gameObject = this.go;\n      c2.transform = this.go.transform;\n      c2.rigidbody = this.rb;\n      c2.relativeVelocity = new Vector3(-c1.relativeVelocity.x, -c1.relativeVelocity.y, -c1.relativeVelocity.z);\n      try {\n        this.go.OnCollisionEnter(c1);\n      } catch (e) {\n        Debug.Log(e);\n      }\n      try {\n        otherCollider.gameObject.OnCollisionEnter(c2);\n      } catch (e) {\n        Debug.Log(e);\n      }\n    }\n  }\n\n  OnDestroy() {\n    this.TryDisposePhysicsImpostor();\n    Engine.scene.onAfterStepObservable.remove(this.afterStepObserver);\n  }\n  \n  get mesh(): BABYLON.AbstractMesh {\n    return this.go.transform.transformNode;\n  }\n/*\n  get position(): BABYLON.Vector3 {\n    return this.mesh.position;\n  }\n\n  set position(value: BABYLON.Vector3) {\n    this.mesh.position = value;\n  }\n\n  get rotationQuaternion(): BABYLON.Quaternion {\n    return this.mesh.rotationQuaternion;\n  }\n\n  set rotationQuaternion(value: BABYLON.Quaternion) {\n    this.mesh.rotationQuaternion = value;\n  }\n\n  get scaling(): BABYLON.Vector3 {\n    return this.mesh.scaling;\n  }\n\n  set scaling(value: BABYLON.Vector3) {\n    this.mesh.scaling = value;\n  }\n\n  getBoundingInfo(): BABYLON.BoundingInfo {\n    var b = this.mesh.getBoundingInfo();\n    return b;\n  }\n\n  computeWorldMatrix(force?: boolean): BABYLON.Matrix {\n    return this.mesh.computeWorldMatrix(true);\n  }\n\n  getVerticesData(kind: string): BABYLON.FloatArray {\n    return this.mesh.getVerticesData(kind);\n  }\n\n  getAbsolutePivotPoint(): BABYLON.Vector3 {\n    return this.mesh.getAbsolutePivotPoint();\n  }\n\n  getAbsolutePosition(): BABYLON.Vector3 {\n    return this.mesh.getAbsolutePosition();\n  }\n\n  rotate(axis: BABYLON.Vector3, amount: number, space?: BABYLON.Space): BABYLON.TransformNode {\n    return this.mesh.rotate(axis, amount, space);\n  }\n\n  translate(axis: BABYLON.Vector3, distance: number, space?: BABYLON.Space): BABYLON.TransformNode {\n    return this.mesh.translate(axis, distance, space);\n  }\n\n  setAbsolutePosition(absolutePosition: BABYLON.Vector3): BABYLON.TransformNode {\n    return this.mesh.setAbsolutePosition(absolutePosition);\n  }\n\n  getClassName(): string {\n    return this.mesh.getClassName();\n  }\n  */\n}\n\nclass Collision {\n  collider: Collider;\n  rigidbody: Rigidbody;\n  transform: Transform;\n  gameObject: GameObject;\n  relativeVelocity: Vector3;\n}"
                    }
                ]
            },
            {
                "UserSystems": [
                    {
                        "Time": "class Time {\n    static timeStarted: number = 0;\n\n    private static date: Date;\n\n    private static lastFrameTime;\n\n    private static _deltaTime;\n\n    static Init() {\n        this.date = new Date();\n        this.timeStarted = this.date.getTime();\n    }\n\n    static get deltaTime() {\n        return this._deltaTime;\n    }\n\n    static get time() {\n        return (new Date().getTime() - this.timeStarted) * 0.001;\n    }\n\n    static Update() {\n        this._deltaTime = this.time - this.lastFrameTime;\n        this.lastFrameTime = Time.time;\n    }\n}"
                    },
                    {
                        "Input": "class Input {\n    private static codeToKeyState: Record<number, number>\n\n    private static nameToKeyState: Record<string, number>\n\n    private static indexToMouseButtonState : Record <number, number>\n\n    private static mouseDelta : BABYLON.Vector2 = new BABYLON.Vector2();\n    \n    private static keyAxisRaw : BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static keyAxis : BABYLON.Vector2 = new BABYLON.Vector2();\n\n    private static sensitivity : number = 0.1;\n\n    private static mouseSensitivity = 0.1;\n\n\n\n\n    static Init() {\n        //Stores all input keys\n        //0 = down, 1 = held, 2 = up, 3 = none\n        Input.codeToKeyState = {};\n        Input.nameToKeyState = {};\n        Input.indexToMouseButtonState = {}\n\n        Engine.scene.actionManager = new BABYLON.ActionManager(Engine.scene);\n\n        Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {\n            if (Input.codeToKeyState[evt.sourceEvent.keyCode] != 1) {\n                Input.codeToKeyState[evt.sourceEvent.keyCode] = 0;\n                Input.nameToKeyState[evt.sourceEvent.key] = 0;\n            }\n        }));\n\n        Engine.scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {\n            Input.codeToKeyState[evt.sourceEvent.keyCode] = 2;\n            Input.nameToKeyState[evt.sourceEvent.key] = 2;\n        }));\n\n\n        Engine.scene.onAfterRenderObservable.add((ev) => {\n            //We reset this every frame because pointermove does not call when not moving\n            this.mouseDelta.x = 0;\n            this.mouseDelta.y = 0;\n        });\n\n        Engine.scene.onPointerObservable.add((pointerInfo) => {\n        \n            switch (pointerInfo.type) {\n                case BABYLON.PointerEventTypes.POINTERMOVE:\n                    this.mouseDelta.x = pointerInfo.event.movementX * this.mouseSensitivity;\n                    this.mouseDelta.y = pointerInfo.event.movementY * this.mouseSensitivity;\n                break;\n\n                case BABYLON.PointerEventTypes.POINTERDOWN:\n                   if (Input.indexToMouseButtonState[pointerInfo.event.button] != 1) {\n                        Input.indexToMouseButtonState[pointerInfo.event.button] = 0 ;\n                    }\n                break;\n\n                case BABYLON.PointerEventTypes.POINTERUP:\n                    Input.indexToMouseButtonState[pointerInfo.event.button] = 2; \n                    \n                break;\n            }\n        });\n\n        \n    }\n\n    static Update() {\n\n        this.ProcessAxes();\n\n        for (let k in Input.codeToKeyState) {\n            if (Input.codeToKeyState[k] == 0 || Input.codeToKeyState[k] == 2) {\n                Input.codeToKeyState[k]++;\n            }\n        }\n\n        for (let k in Input.nameToKeyState) {\n            if (Input.nameToKeyState[k] == 0 || Input.nameToKeyState[k] == 2) {\n                Input.nameToKeyState[k]++;\n            }\n        }\n\n        for (let k in Input.indexToMouseButtonState) {\n            if (Input.indexToMouseButtonState[k] == 0 || Input.indexToMouseButtonState[k] == 2) {\n                Input.indexToMouseButtonState[k]++;\n            }\n        }\n    }\n\n    static ProcessAxes ()\n    {\n        this.keyAxisRaw.x = 0;\n        this.keyAxisRaw.y = 0;\n\n        if (this.GetKey(KeyCode.LeftArrow) || this.GetKey(KeyCode.A))\n        {\n            this.keyAxisRaw.x -= 1;\n        }\n        if (this.GetKey(KeyCode.RightArrow) || this.GetKey(KeyCode.D))\n        {\n            this.keyAxisRaw.x += 1;\n        } \n\n        if (this.GetKey(KeyCode.UpArrow) || this.GetKey(KeyCode.W))\n        {\n            this.keyAxisRaw.y += 1;\n        }\n        if (this.GetKey(KeyCode.DownArrow) || this.GetKey(KeyCode.S))\n        {\n            this.keyAxisRaw.y -= 1;\n        }\n        \n        this.keyAxis.x = Mathf.MoveTowards(this.keyAxis.x, this.keyAxisRaw.x, this.sensitivity);\n        this.keyAxis.y = Mathf.MoveTowards(this.keyAxis.y, this.keyAxisRaw.y, this.sensitivity);\n    }\n\n    static GetMouseButton (button : number) : boolean\n    {\n        return Input.indexToMouseButtonState[button] == 0 || Input.indexToMouseButtonState[button] == 1;;\n    }\n\n    static GetMouseButtonDown (button : number) : boolean\n    {\n        return Input.indexToMouseButtonState[button] == 0;\n    }\n\n    static GetMouseButtonUp (button : number) : boolean\n    {\n        return Input.indexToMouseButtonState[button] == 2;\n    }\n\n    static GetKey(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 0 || Input.nameToKeyState[key] == 1;\n        }\n        return Input.codeToKeyState[key] == 0 || Input.codeToKeyState[key] == 1;\n    }\n\n    static GetKeyDown(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 0;\n        }\n        return Input.codeToKeyState[key] == 0;\n    }\n\n    static GetKeyUp(key: string | KeyCode) {\n        if (typeof key == \"string\") {\n            return Input.nameToKeyState[key] == 2;\n        }\n        return Input.codeToKeyState[key] == 2;\n    }\n\n    static GetAxis(axisName: string) : number{\n        switch (axisName) {\n            case \"Mouse X\":\n                return this.mouseDelta.x;\n            case \"Mouse Y\":\n                return this.mouseDelta.y;\n            case \"Horizontal\":\n                return this.keyAxis.x;\n            case \"Vertical\":\n                return this.keyAxis.y;\n            default:\n                Debug.Log(`Axisname ${axisName} does not exist! Currently the only options are Mouse X, Mouse Y, Horizontal & Vertical`);\n            break;\n        }\n    }\n\n}\n\nenum KeyCode {\n    Break = 3,\n    Backspace = 8,\n    Tab = 9,\n    Clear = 12,\n    Enter = 13,\n    Shift = 16,\n    Control = 17,\n    Alt = 18,\n    Pause = 19,\n    CapsLock = 20,\n    Hangul = 21,\n    Hanja = 25,\n    Escape = 27,\n    Conversion = 28,\n    NonConversion = 29,\n    Space = 32,\n    PageUp = 33,\n    PageDown = 34,\n    End = 35,\n    Home = 36,\n    LeftArrow = 37,\n    UpArrow = 38,\n    RightArrow = 39,\n    DownArrow = 40,\n    Select = 41,\n    Print = 42,\n    Execute = 43,\n    PrintScreen = 44,\n    Insert = 45,\n    Delete = 46,\n    Help = 47,\n    Alpha0 = 48,\n    Alpha1 = 49,\n    Alpha2 = 50,\n    Alpha3 = 51,\n    Alpha4 = 52,\n    Alpha5 = 53,\n    Alpha6 = 54,\n    Alpah7 = 55,\n    Alpha8 = 56,\n    Alpha9 = 57,\n    Colon = 58,\n    Semicolon = 59,\n    LessThan = 60,\n    Equals = 61,\n    Beta = 63,\n    CommercialAt = 64,\n    A = 65,\n    B = 66,\n    C = 67,\n    D = 68,\n    E = 69,\n    F = 70,\n    G = 71,\n    H = 72,\n    I = 73,\n    J = 74,\n    K = 75,\n    L = 76,\n    M = 77,\n    N = 78,\n    O = 79,\n    P = 80,\n    Q = 81,\n    R = 82,\n    S = 83,\n    T = 84,\n    U = 85,\n    V = 86,\n    W = 87,\n    X = 88,\n    Y = 89,\n    Z = 90,\n    WindowsKey = 91,\n    LeftCommand = 91,\n    RightWindow = 92,\n    RightCommand = 93,\n    Sleep = 95,\n    Keypad0 = 96,\n    Keypad1 = 97,\n    Keypad2 = 98,\n    Keypad3 = 99,\n    Keypad4 = 100,\n    Keypad5 = 101,\n    Keypad6 = 102,\n    Keypad7 = 103,\n    Keypad8 = 104,\n    Keypad9 = 105,\n    KeypadMultiply = 106,\n    KeypadAdd = 107,\n    KeypadPeriod = 108,\n    KeypadSubtract = 109,\n    DecimalPoint = 110,\n    KeypadDivide = 111,\n    F1 = 112,\n    F2 = 113,\n    F3 = 114,\n    F4 = 115,\n    F5 = 116,\n    F6 = 117,\n    F7 = 118,\n    F8 = 119,\n    F9 = 120,\n    F10 = 121,\n    F11 = 122,\n    F12 = 123,\n    F13 = 124,\n    F14 = 125,\n    F15 = 126,\n    F16 = 127,\n    F17 = 128,\n    F18 = 129,\n    F19 = 130,\n    F20 = 131,\n    F21 = 132,\n    F22 = 133,\n    F23 = 134,\n    F24 = 135,\n    F25 = 136,\n    F26 = 137,\n    F27 = 138,\n    F28 = 139,\n    F29 = 140,\n    F30 = 141,\n    F31 = 142,\n    F32 = 143,\n    NumLock = 144,\n    ScrollLock = 145,\n    AirplaneMode = 151,\n    CircumFlex = 160,\n    ExclamationMark = 161,\n    ArabicSemicolon = 162,\n    Hash = 163,\n    DollarSign = 164,\n    PageBackward = 166,\n    PageForward = 167,\n    Refresh = 168,\n    Asterisk = 170,\n}"
                    },
                    {
                        "Random": "/**\nThe Random class can give you random values\n */\nclass Random\n{\n    static get value ()\n    {\n        return Math.random();\n    }\n\n    static Range (min : number, max : number, wholeNumber : boolean = false)\n    {\n        var r : number = (Math.random() * (max-min)) + min;\n        if (wholeNumber)\n        {\n            return Math.floor(r);\n        }\n        return r;\n    }\n}"
                    },
                    {
                        "Mathf": "class Mathf\n{\n  //TODO Optimize?\n  static get Rad2Deg () : number\n  {\n    return 180 / Math.PI;\n  }\n\n  static get Deg2Rad () : number\n  {\n        return Math.PI / 180;\n  }\n\n  static Lerp(v1: number, v2: number, value: number): number {\n    return Mathf.Clamp(this.LerpUnclamped(v1, v2, value), v1, v2);\n  }\n\n  static LerpUnclamped(v1: number, v2: number, value: number): number {\n\n    return v1 + ((v2 - v1) * value);\n  }\n\n  static Clamp (value : number, min : number, max : number) : number\n  {\n    if (min > max)\n    {\n      var t = max;\n      max = min;\n      min = t;\n    }\n    return Math.min(Math.max(value, min), max);\n  }\n\n  static Min (value : number, min : number) : number\n  {\n    return Math.min(value, min);\n  }\n\n  static Max (value : number, max : number) : number\n  {\n    return Math.max(value, max);\n  }\n\n  static MoveTowards (current : number, target : number, maxDelta : number) : number\n  {\n    if (current < target - maxDelta)\n    {\n      return current + maxDelta;\n    } else if (current > target + maxDelta)\n    {\n      return current - maxDelta;\n    }\n    return target;\n  }\n}"
                    },
                    {
                        "Debug": "class Debug\n{\n  public static includeStackTraceByDefault : boolean = false;\n\n  static Log (info : any, includeStackTrace? : boolean)\n  {\n    if (!includeStackTrace)\n      includeStackTrace = Debug.includeStackTraceByDefault;\n      \n    var msg = (Time.time.toFixed(3).toString() + \": \" + info);\n    if (includeStackTrace)\n    {\n      consolelog(new Error(msg).stack);\n    } else {\n      consolelog(msg);\n    }\n  }\n}"
                    },
                    {
                        "SceneManager": "//TODO rewrite this into a proper scene system\nclass SceneManager {\n\n    public static onSceneLoaded: BABYLON.Observable<Scene> = new BABYLON.Observable();\n    public static onPreSceneLoaded: BABYLON.Observable<Scene> = new BABYLON.Observable();\n\n    public static GetActiveScene(): Scene {\n        return this.activeScene;\n    }\n\n    private static activeScene: Scene;\n\n    static isReloading: boolean;\n\n    private static activeSceneName: string;\n\n    public static prefabLoaded: boolean;\n\n    public static sceneJSONData: string\n\n    private static recordStateAfterReload: boolean = false;\n\n    private static selectedGameObjects: string[];\n\n    public static SaveCurrentScene() {\n        if (Engine.isPlaying) {\n            print(\"Can't save during playmode\");\n        } else {\n            this.activeScene.Save();\n        }\n    }\n\n    static Init() {\n        PixelPADEvents.onSceneClicked.add(name => {\n            if (SceneManager.activeScene) {\n                SceneManager.activeScene.Unload();\n            }\n            SceneManager.LoadScene(name);\n        });\n\n        PixelPADEvents.onSaveClicked.add(ev => {\n            SceneManager.SaveCurrentScene();\n        });\n    }\n\n    static ReloadCurrentScene() {\n\n        if (this.activeScene != null) {\n            var newName = this.activeScene.name;\n            this.LoadScene(newName);\n        }\n        else {\n            Debug.Log(\"No scene is currently loaded\")\n        }\n    }\n\n    public static LoadPrefab(name: string) {\n        this.LoadSceneOrPrefab(name);\n    }\n\n    public static LoadScene(name: string) {\n        this.LoadSceneOrPrefab(name);\n    }\n\n    /** Helper function to load a scene based on JSON Data */\n    public static LoadSceneData(data: string) {\n        this.selectedGameObjects = new Array();\n        EditorSelection.GetSelection().forEach(e => {\n            this.selectedGameObjects.push(e.transform.uniqueId);\n        });\n        EditorSelection.SetSelectedGameObject(null);\n        if (this.activeScene != null) {\n            this.activeScene.Unload();\n        }\n\n        this.sceneJSONData = data;\n\n        //Using this bool so Scenes are only reloaded at the very end of a frame\n        SceneManager.isReloading = true;\n    }\n\n    public static LoadSceneOrPrefab(name: string) {\n        //One day we should do this better.\n        this.prefabLoaded = !name.endsWith(\".scn\");\n\n        if (SceneManager.isReloading) {\n            return;\n        }\n\n        this.activeSceneName = name;\n        if (ENABLE_EDITOR) {\n            UnionEditor.SetTitle(name);\n        }\n        if (!Engine.isPlaying) {\n            Project.data.loadedSceneOrPrefab = name;\n        }\n\n        if (this.prefabLoaded) {\n            this.LoadSceneData(getPrefab(name));\n        } else {\n            this.LoadSceneData(getScene(name));\n        }\n\n        this.recordStateAfterReload = true;\n\n    }\n\n    private static LoadSceneImmdiate() {\n\n        SceneManager.isReloading = true;\n        this.activeScene = new Scene();\n        this.activeScene.name = this.activeSceneName;\n\n        SceneManager.onPreSceneLoaded.notifyObservers(this.activeScene);\n\n        //This loads all objects into the activeScene\n        Serializer.FromJSON(this.sceneJSONData, false);\n        /*\n        //If the sceneData is null, this is probably an empty scene/prefab\n        if (this.prefabLoaded && (!sceneData || sceneData.rootObjs.length == 0))\n        {\n            this.activeScene.rootObj = new GameObject();\n            this.activeScene.name = Prefab.SimpleName(name);\n        } else {\n            this.activeScene.rootObj = sceneData.rootObjs[0];\n        }        \n        */\n        \n        this.selectedGameObjects.forEach(sGoId => {\n            this.activeScene.objs.forEach(obj => {\n                if (obj.transform.uniqueId === sGoId) {\n                    this.justReloaded = true;\n                    EditorSelection.AddSelectedGameObject(obj as GameObject);\n                }\n            });\n        });\n\n        SceneManager.isReloading = false;\n        SceneManager.onSceneLoaded.notifyObservers(this.activeScene);\n\n\n\n        if (this.recordStateAfterReload) {\n            Undo.RecordState();\n            this.recordStateAfterReload = false;\n        }\n\n\n    }\n\n    public static MarkSceneAsDirty() {\n        if (!Engine.isPlaying && !SceneManager.isReloading) {\n            Undo.RecordState();\n            markSceneDirty();\n        }\n    }\n\n    private static justReloaded = false;\n    static Update() {\n        if (SceneManager.isReloading) {\n            this.LoadSceneImmdiate();\n        }\n        if (SceneManager.justReloaded) {\n            SceneManager.justReloaded = false;\n\n        }\n    }\n}"
                    },
                    {
                        "PlayerPrefs": "//script:Serializer\n\nclass PlayerPrefs {\n\n\n  public static Save(jsonData: string) {\n\n    Engine.current.getHostDocument().cookie = jsonData + \"|||\";\n  }\n\n  public static Load(): string {\n    var cookie: string = Engine.current.getHostDocument().cookie;\n\n    if (cookie.startsWith(\"{\")) {\n      cookie = cookie.split(\"|||\")[0];\n      return cookie;\n    }\n    return null;\n  }\n\n  public static Clear() {\n    this.Save(\"{}\");\n\n  }\n}\n\nclass Project {\n  public static data: ProjectData;\n\n  public static Init() {\n    this.data = JSON.parse(PlayerPrefs.Load()) as ProjectData;\n    if (!this.data)\n      this.data = new ProjectData();\n  }\n\n  public static Save() {\n   // PlayerPrefs.Save(JSON.stringify(this.data));\n  }\n}\n\nclass ProjectData {\n\n  get loadedSceneOrPrefab(): string {\n    return this._loadedSceneOrPrefab;\n  };\n\n  set loadedSceneOrPrefab(value: string) {\n    this._loadedSceneOrPrefab = value;\n    Project.Save();\n  };\n\n  _loadedSceneOrPrefab: string = \"\";\n\n}"
                    },
                    {
                        "Lighting": "class Lighting {\n\n  public static mainLight : BABYLON.Light;\n\n  private static shadowGenerators : BABYLON.ShadowGenerator[] = new Array();\n\n  private static casters : BABYLON.Mesh[] = new Array();\n\n  public static RemoveCastingMesh (m : BABYLON.Mesh)\n  {    \n    const index = this.casters.indexOf(m);\n    if (index > -1) {\n     \n      var removedMesh = this.casters.splice(index, 1)[0];\n      this.shadowGenerators.forEach((gen) => {\n        gen.removeShadowCaster(removedMesh);\n      });\n    }\n  }\n\n  public static AddCastingMesh(m : BABYLON.Mesh)\n  {\n    const index = this.casters.indexOf(m);\n    if (index == -1) {\n      this.casters.push(m);\n      this.shadowGenerators.forEach((gen) => {\n        gen.addShadowCaster(m, true);\n      });\n    }\n  }\n\n  public static AddLight (l : Light)\n  {\n    var generator = new BABYLON.ShadowGenerator(1024, l.light, true);\n    generator.useExponentialShadowMap = true;  \n    this.shadowGenerators.push(generator);\n    //We add all previous casters to our new light\n    this.casters.forEach((m : BABYLON.Mesh) => {\n      generator.addShadowCaster(m, true);\n    });\n  }\n\n  public static RemoveLight (l : Light)\n  {\n    let index = -1;\n    this.shadowGenerators.forEach((gen) => {\n      if (gen.getLight() == l.light)\n      {\n        index = this.shadowGenerators.indexOf(gen);\n        gen.dispose();\n      }\n    });\n\n    //Remove the generator from our array\n    if (index > -1) {\n      this.shadowGenerators.splice(index, 1);\n    }\n  }\n\n  //Start is called before the first frame update\n  static Init() {\n    \n    //Create main light\n    Lighting.mainLight = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), Engine.scene);\n    Lighting.mainLight.intensity = .3;\n\n    SceneManager.onPreSceneLoaded.add(scene => {\n     \n    });\n  }\n}\n"
                    },
                    {
                        "Cursor": "class Cursor {\n\n  static Init ()\n  {\n     \n    Engine.scene.onPrePointerObservable.add((ev) => {\n      //When the cursor is unlocked somehow, we reset it to none here      \n      if (!Engine.current.isPointerLock && Cursor.lockState == CursorLockMode.Locked)\n      {\n        Cursor.lockState = CursorLockMode.None;\n      }\n\n      //We avoid moving the mouse when it's locked.\n      if (Cursor.lockState == CursorLockMode.Locked)\n      {\n        if (ev.type == BABYLON.PointerEventTypes.POINTERMOVE)\n        {\n          //Disabled this since it prevented mouse movement?\n          //ev.skipOnPointerObservable = true;\n        }\n      }\n    });\n  }\n\n\n  static get lockState (): CursorLockMode{\n    return this._lockState;\n  }\n\n  static set lockState(value:CursorLockMode)\n  {\n    Cursor._lockState = value;\n    switch(value)\n    {\n      case CursorLockMode.Locked:\n        Engine.current.enterPointerlock();\n      break;\n      case CursorLockMode.None:\n        Engine.current.exitPointerlock();\n      break;\n      case CursorLockMode.Confined:\n        Debug.Log(\"Confined lockmode is currently not supported\")\n    }\n  }\n\n  private static _lockState : CursorLockMode;\n}\n\nenum CursorLockMode\n{\n  Locked,\n  Confined,\n  None\n}"
                    }
                ]
            },
            {
                "InternalSystems": [
                    {
                        "PixelPADEvents": "/*\nAll External events coming from the PixelPAD website go through this wrapper\nThe only exception is the stop button - since this is handled directly in the engine.\n*/\n\n//TODO Clean this up into objects of a PixePADEventListenerClass\nclass PixelPADEvents {\n\n  public static onSceneClicked: BABYLON.Observable<string>;\n  public static onSaveClicked: BABYLON.Observable<string>;\n  public static onAssetClicked: BABYLON.Observable<string[]>;\n\n  //Start is called before the first frame update\n  static AddAllListeners() {\n    PixelPADEvents.onSceneClicked = new BABYLON.Observable();\n    PixelPADEvents.onSaveClicked = new BABYLON.Observable();\n    PixelPADEvents.onAssetClicked = new BABYLON.Observable();\n\n    document.addEventListener(\"saveClicked\", this.OnSaveClicked);\n    document.addEventListener(\"assetClicked\", this.OnAssetClicked);\n  }\n\n  static ClearAllListeners() {\n    document.removeEventListener(\"saveClicked\", this.OnSaveClicked);\n    document.removeEventListener(\"assetClicked\", this.OnAssetClicked);\n\n\n    PixelPADEvents.onSceneClicked.clear();\n    PixelPADEvents.onSaveClicked.clear();\n    PixelPADEvents.onAssetClicked.clear();\n  }\n\n  private static OnResize (e : any)\n  {\n    print(1)\n  }\n\n  private static OnAssetClicked(e: CustomEvent) {\n    switch (e.detail.assetType) {\n      case \"scene\":\n        PixelPADEvents.onSceneClicked.notifyObservers(e.detail.assetName);\n        break;\n        //Ignore scripts\n      case \"script\":\n        break;       \n      default:\n        PixelPADEvents.onAssetClicked.notifyObservers([e.detail.assetType, e.detail.assetName]);\n\n        break;\n\n    }\n  }\n\n  private static OnSaveClicked(e: CustomEvent) {\n    PixelPADEvents.onSaveClicked.notifyObservers(null);\n  }\n\n}\n\n"
                    },
                    {
                        "TextureSystem": "class TextureSystem\n{\n    //TODO This should be cached\n    public static GetSprite(shortName : string) : BABYLON.Texture\n    {\n        var url = getTexture(shortName);\n        if (!url)\n        {\n            return null;\n        }\n        var texture = new BABYLON.Texture(url, Engine.scene);\n        \n        return texture;\n    }\n}"
                    },
                    {
                        "MeshLoader": "//Helps loading and caches meshes\nclass MeshLoader {\n    static enableLogging: boolean = true;\n    private static assetContainers: Map<string, BABYLON.AssetContainer>;\n    private static finishCallbacks: Map<string, { (data: BABYLON.InstantiatedEntries): void; }[]>;\n\n    //TODO move into base class\n    static Log(msg) {\n        if (MeshLoader.enableLogging) {\n            print(msg)\n        }\n    }\n\n    static Init() {\n        MeshLoader.assetContainers = new Map();\n        MeshLoader.finishCallbacks = new Map();\n    }\n\n    //** Cached way of loading meshes*/\n    public static Load(name: string, onLoaded: (models: BABYLON.InstantiatedEntries) => void) {\n        if (MeshLoader.assetContainers.has(name)) {\n\n            let container = MeshLoader.assetContainers.get(name);\n            if (container) {\n                //If the container was already loaded, this is simple\n                //Creates a clone\n                onLoaded(container.instantiateModelsToScene());\n                return;\n            }\n        } else {\n            //For unloaded meshes - load from cache\n            let modelUrl = URLResult.Create(name, FileType.Model);\n            if (modelUrl.baseUrl == null) {\n                print(\"Could not load mesh \" + name + \". Are you sure it exists?\");\n                return;\n            }\n            MeshLoader.assetContainers.set(name, null);\n            MeshLoader.finishCallbacks.set(name, []);\n            //Using a container allows us to load the asset before adding to a scene\n            //In this case, it prevents a single frame flicker where the mesh would show up\n            BABYLON.SceneLoader.LoadAssetContainer(modelUrl.baseUrl, modelUrl.fullName, Engine.scene, (container) => {\n\n                MeshLoader.assetContainers.set(name, container);\n                for (var i = 0; i < container.animationGroups.length; i++) {\n                    container.animationGroups[i].pause();\n                }\n\n                //When the file is actually loaded, all requests will receive a loaded update at the same time\n                MeshLoader.finishCallbacks.get(name).forEach(fCb => {\n                    fCb(MeshLoader.assetContainers.get(name).instantiateModelsToScene());\n                });\n                MeshLoader.finishCallbacks[name] = [];\n            });\n        }\n        //This could happen if I request a mesh that is currnetly being loaded.\n        //We push this to the list of finishcallbacks\n        MeshLoader.finishCallbacks.get(name).push(onLoaded);\n\n        //MeshLoader.Log(\"Loading mesh \" + modelUrl.baseUrl + name + \"...\");\n    }\n\n    /*\n    //Tries and gets the mesh for the different objects\n    static GetMesh(name) {\n        //Bit hacky\n        if (name === \"box\" || name === \"sphere\") {\n            var defaultMesh = [];\n            if (name == \"box\") {\n                defaultMesh.push(BABYLON.Mesh.CreateBox(name, 1, Engine.scene));\n            } else {\n                defaultMesh.push(BABYLON.Mesh.CreateSphere(name, 8, 1, Engine.scene));\n            }\n            return defaultMesh;\n        }\n\n\n        //meshTaskToMap has a list of all loading/loading meshes\n        //If it's not in there, it should be loaded at that time.\n        var meshTask: BABYLON.MeshAssetTask = MeshLoader.assetContainers[name];\n\n        if (meshTask == null) {\n            this.LoadMesh(name);\n            return null;\n        }\n\n        if (!meshTask.isCompleted) {\n            return null;\n        }\n\n        //If the mesh has been loaded, we return a copy of it.\n        //This ensures the mesh is only loaded once!\n        var meshes = [...MeshLoader.meshTaskMap[name].loadedMeshes];\n        for (var i = 0; i < meshes.length; i++) {\n            meshes[i] = meshes[i].clone(\"Clone_\" + i, null);\n        }\n\n        return meshes;\n    }\n    */\n}\n\n"
                    }
                ]
            },
            {
                "UI": [
                    {
                        "TextLabel": "class TextLabel extends MonoBehaviour\n{\n  //MUST HAVE A DEFAULT VALUE OR MIGHT CRASH!\n  public text : string = \"\";\n\n  private label : BABYLON.GUI.TextBlock;\n\n  Awake ()\n  {\n    this.label = new BABYLON.GUI.TextBlock();\n    this.label.color = \"white\";\n    this.label.fontSize = 30;\n    this.label.outlineColor = \"black\";\n    this.label.outlineWidth = 3;\n    this.label.shadowColor = \"black\";\n    this.label.shadowOffsetX = 2;\n    this.label.shadowOffsetY = 2;\n\n    Canvas.main.addControl(this.label);\n    this.label.linkWithMesh(this.renderer.GetMesh());\n  }\n\n  Update ()\n  {\n    this.label.text = this.text;\n    \n  }\n}"
                    },
                    {
                        "NewCanvas": "@ExecuteInEditMode\nclass NewCanvas extends MonoBehaviour {\n\n  boundingBoxLines : BABYLON.LinesMesh;\n\n  private _gameView : BABYLON.GUI.Control;\n\n  //Singleton pattern\n  public static get instance (): NewCanvas\n  {\n    if (NewCanvas._instance == null || NewCanvas._instance == undefined)\n    {\n      NewCanvas._instance = Instantiate(NewCanvas);      \n    }\n    return NewCanvas._instance;\n  }\n\n  private static _instance : NewCanvas;  \n\n  public get main () : BABYLON.GUI.AdvancedDynamicTexture[]\n  {\n    return this._main;\n  }\n\n  private _main : BABYLON.GUI.AdvancedDynamicTexture[];\n\n  private _editorCanvas : BABYLON.GUI.AdvancedDynamicTexture;\n  private _editorRenderPlane : BABYLON.Mesh;\n\n  Awake ()\n  {\n    this._main = new Array();\n    //Editor Canvas\n    this._editorRenderPlane = BABYLON.Mesh.CreatePlane(\"plane\", 1, Engine.scene);\n    this._editorRenderPlane.layerMask = 4; //\n    this._editorRenderPlane.setParent(this.transform.transformNode);\n    this._gameView = UnionEditor.gameView.background;\n    \n    print(this._gameView.widthInPixels)\n    this._editorCanvas = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(this._editorRenderPlane, this._gameView.widthInPixels, this._gameView.heightInPixels, true);\n    \n    this._main.push(this._editorCanvas);\n\n    //2D scene Canvas\n    var canvas = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"Canvas\", true, Engine.scene);\n    canvas.layer.layerMask = 3;\n    this._main.push(canvas);\n\n    \n  }\n\n  Update ()\n  {\n    this._editorRenderPlane.scaling = new BABYLON.Vector3(this._gameView.widthInPixels, this._gameView.heightInPixels, 0);\n     //print(this._main[1].getSize().width);\n     this.RedrawOutline();\n  }\n\n  RedrawOutline()\n  {\n    var b = this._editorRenderPlane.getBoundingInfo().boundingBox;\n\n    var myPoints = [\n      b.minimum, \n      new BABYLON.Vector3(b.minimum.x, b.maximum.y, 0),\n      b.maximum,\n      new BABYLON.Vector3(b.maximum.x, b.minimum.y, 0),\n      b.minimum\n     ];\n\n    if (this.boundingBoxLines)\n      this.boundingBoxLines.dispose();\n\n    this.boundingBoxLines = BABYLON.MeshBuilder.CreateLines(\"lines\", { points: myPoints }, Engine.scene);\n    this.boundingBoxLines.setParent(this.transform.transformNode);\n    this.boundingBoxLines.color = BABYLON.Color3.White();\n    this.boundingBoxLines.position = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.rotation = BABYLON.Vector3.Zero();\n    this.boundingBoxLines.scaling = BABYLON.Vector3.One();\n    this.boundingBoxLines.layerMask = 4;\n  }\n\n  \n\n  OnDestroy ()\n  {\n    this._main.forEach(canvas => {\n      canvas.dispose();\n    });\n\n    NewCanvas._instance = null;\n  }\n}\n"
                    },
                    {
                        "Button": "@ExecuteInEditMode\nclass Button extends MonoBehaviour {\n\n  private _canvas: NewCanvas;\n\n  private _babControls: BABYLON.GUI.Control[];\n\n  //Start is called before the first frame update\n  Start() {\n    this._canvas = this.GetComponentInParent(NewCanvas);\n    if (!this._canvas) {\n      this._canvas = GameObject.FindObjectOfType(NewCanvas);\n    }\n    if (!this._canvas) {\n      this._canvas = Instantiate(NewCanvas);\n    }\n\n    //this.transform.SetParent(this._canvas.transform);\n    this.CreateBabGUI();\n  }\n\n  CreateBabGUI() {\n    this._babControls = new Array();\n    this._canvas.main.forEach(advancedTexture => {\n      var button = BABYLON.GUI.Button.CreateSimpleButton(\"but1\", \"Click Me\");\n      button.width = \"200px\";\n      button.height = \"80px\";\n      button.color = \"white\";\n      button.fontSize = 50;\n      button.background = \"green\";\n      this._babControls.push(button);\n      \n      advancedTexture.addControl(button);\n    });\n    //this._babControls[0].linkWithMesh(this.transform.transformNode);\n  }\n\n  //Update is called once per frame\n  Update() {\n    \n    this._babControls[0].leftInPixels = this.transform.localPosition.x * this._canvas.main[0].getSize().width / 10;\n    this._babControls[0].topInPixels = -this.transform.localPosition.y * this._canvas.main[0].getSize().height / 10;\n    //Replicate in other view\n    this._babControls[1].leftInPixels = this._babControls[0].leftInPixels;\n    this._babControls[1].topInPixels = this._babControls[0].topInPixels;\n      //\n      //babControl.topInPixels = -this.transform.localPosition.y * Engine.canvas.height * 0.5;\n\n   //});\n  }\n}\n"
                    },
                    {
                        "Label": "class Label extends MonoBehaviour {\n\n  //Start is called before the first frame update\n  Start() {\n  \n  }\n  \n  //Update is called once per frame\n  Update() {\n  \n  }\n}\n"
                    },
                    {
                        "Canvas": "//script:GUITest\n\nclass Canvas extends MonoBehaviour\n{\n  //Singleton pattern\n  public static get instance (): Canvas\n  {\n    if (Canvas._instance == null || Canvas._instance == undefined)\n    {\n      Canvas._instance = Instantiate(Canvas);      \n    }\n    return Canvas._instance;\n  }\n\n  private static _instance: Canvas;  \n\n  public static get main (): BABYLON.GUI.AdvancedDynamicTexture\n  {\n    return Canvas.instance.main;\n  }\n\n  private main : BABYLON.GUI.AdvancedDynamicTexture;\n\n  Awake ()\n  {\n    this.main = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"Main\", true, Engine.scene);\n    this.main.layer.layerMask = 3;\n    \n  }\n\n  Update ()\n  {\n\n  }\n\n  OnDestroy ()\n  {\n    this.main?.dispose();\n    Canvas._instance = null;\n  }\n}"
                    }
                ]
            },
            {
                "FileTypes": [
                    {
                        "Prefab": "class Prefab {\n\n  public static Get(name: string): string {\n    return getPrefab(name);\n  }\n\n  public static SimpleName(name: string) {\n    return name.slice(0, -7);\n  }\n\n  public static Create(name: string, goParent: GameObject = null): GameObject {\n    var prefabJson = getPrefab(name);\n\n    var parent = goParent ? goParent : new GameObject();\n    parent.name = this.SimpleName(name) + \" (Clone)\";\n    parent.prefabParent = parent;\n    parent.prefabName = name;\n    var clone: Scene = Serializer.FromJSON(prefabJson);\n    clone.rootObjs.forEach((go: GameObject) => {\n      go.transform.SetParent(parent.transform, false);\n    });\n\n    this.SetPrefabParent(clone.rootObjs, parent);\n\n    return parent;\n  }\n\n  private static SetPrefabParent(gos: GameObject[], prefab: GameObject) {\n    gos.forEach(go => {\n      if (go) {\n        go.prefabParent = prefab;\n        this.SetPrefabParent(go.transform.ser_children, prefab);\n      }\n    });\n  }\n}\n"
                    },
                    {
                        "Material": "class Material {\n\n  public static maxLightsPerMaterial = 10;\n\n  @SerializeField\n  isPBR: boolean = false;\n\n  onChange: BABYLON.Observable<string>;\n\n  private wasPBR: boolean;\n\n  private static activeMaterials : Material[] = new Array();\n\n  constructor(name: string) {\n    this.onChange = new BABYLON.Observable<string>();\n    this.UpdateShader();\n  }\n\n  private UpdateShader() {\n    if (this.isPBR) {\n      var pm = new BABYLON.PBRMaterial(name, Engine.scene);\n      pm.maxSimultaneousLights = Material.maxLightsPerMaterial;\n      this.shader = pm;\n    } else {\n      var sm = new BABYLON.StandardMaterial(name, Engine.scene);\n      sm.maxSimultaneousLights = Material.maxLightsPerMaterial;\n      this.shader = sm;\n    }\n    this.wasPBR = this.isPBR;\n    this._lastTexture = \"\";\n    this._lastNormalTexture = \"\";\n\n    this.onChange.notifyObservers(this.isPBR ? \"PBR\" : \"Standard\");\n  }\n\n  shader: BABYLON.PushMaterial;\n\n  @SerializeField\n  mainColor: Color = new Color();\n\n  @SerializeField\n  mainTexture: string = \"\";\n  _lastTexture: string = \"\";\n\n  @SerializeField\n  alpha: number = 1;\n\n  @SerializeField\n  normalTexture: string = \"\";\n  _lastNormalTexture: string = \"\";\n\n  @SerializeField uScale: number = 1;\n  @SerializeField vScale: number = 1;\n  @SerializeField uOffset: number = 1;\n  @SerializeField vOffset: number = 1;\n\n  @SerializeField\n  specularColor: Color = new Color(0, 0, 0);\n\n  @SerializeField\n  specularPower: number = 0;\n\n  @SerializeField\n  roughness: number = 0;\n\n  @SerializeField\n  alphaMode: number = 0;\n\n  @SerializeField\n  hasAlpha : boolean = false;\n\n  private Update() {\n    if (this.isPBR != this.wasPBR) {\n      this.UpdateShader();\n    }\n\n    this.shader.alphaMode = this.alphaMode;\n\n    if (this.isPBR) {\n      var pMat = this.shader as BABYLON.PBRMaterial;\n      Color.UtoB(this.mainColor, pMat.albedoColor);\n      Color.UtoB(this.specularColor, pMat.reflectionColor);\n\n      pMat.specularIntensity = this.specularPower;\n      pMat.alpha = this.alpha;\n      pMat.roughness = this.roughness;\n\n      if (this.mainTexture && this.mainTexture != this._lastTexture) {\n        pMat.albedoTexture = TextureSystem.GetSprite(this.mainTexture);\n        this._lastTexture = this.mainTexture;\n      }\n      if (this.normalTexture && this.normalTexture != this._lastNormalTexture) {\n        pMat.bumpTexture = TextureSystem.GetSprite(this.normalTexture);\n        this._lastNormalTexture = this.normalTexture;\n\n      }\n\n      var t = pMat.albedoTexture as BABYLON.Texture;\n\n      if (t) {\n        t.uScale = this.uScale;\n        t.vScale = this.vScale;\n        t.uOffset = this.uOffset;\n        t.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n\n      var b = pMat.bumpTexture as BABYLON.Texture;\n      if (b) {\n        b.uScale = this.uScale;\n        b.vScale = this.vScale;\n        b.uOffset = this.uOffset;\n        b.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n\n    } else {\n      var mat = this.shader as BABYLON.StandardMaterial;\n      Color.UtoB(this.mainColor, mat.diffuseColor);\n      Color.UtoB(this.specularColor, mat.specularColor);\n\n\n      mat.specularPower = this.specularPower;\n      mat.alpha = this.alpha;\n      mat.roughness = this.roughness;\n\n      if (this.mainTexture && this.mainTexture != this._lastTexture) {\n        mat.diffuseTexture = TextureSystem.GetSprite(this.mainTexture);\n        this._lastTexture = this.mainTexture;\n      }\n      if (this.normalTexture && this.normalTexture != this._lastNormalTexture) {\n        mat.bumpTexture = TextureSystem.GetSprite(this.normalTexture);\n        this._lastNormalTexture = this.normalTexture;\n\n      }\n\n      var t = mat.diffuseTexture as BABYLON.Texture;\n\n      if (t) {\n        t.uScale = this.uScale;\n        t.vScale = this.vScale;\n        t.uOffset = this.uOffset;\n        t.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n\n      var b = mat.bumpTexture as BABYLON.Texture;\n      if (b) {\n        b.uScale = this.uScale;\n        b.vScale = this.vScale;\n        b.uOffset = this.uOffset;\n        b.vOffset = this.vOffset;\n        t.hasAlpha = this.hasAlpha;\n      }\n    }\n\n  }\n\n  public Clone(): Material {\n    var matJson = Serializer.ToJSON(this);\n    var newMat = Serializer.FromJSON(matJson, false);;\n    Material.activeMaterials.push(newMat);\n    return newMat;\n  }\n\n  public Destroy ()\n  {\n    var i = Material.activeMaterials.indexOf(this);\n    if (i > -1)\n    {\n      Material.activeMaterials.splice(i, 1);\n    }\n  }\n\n\n  // #region static\n  public static Get(name: string): Material {\n    //Not in array or null?\n    if (!this.nameToMat.has(name) || !this.nameToMat.get(name)) {\n      //If no name is added, we just use default\n      if (name) {\n        var matJson = getMaterial(name);\n      }\n\n      var material: Material = null;\n      //If we we used a non-existent material matJson would not be there.\n      if (matJson) {\n        material = Serializer.FromJSON(matJson, false);\n      }\n\n      if (!material) {\n        material = new Material(name);\n      }\n\n      this.nameToMat.set(name, material);\n      this.activeMaterials.push(material);\n    }\n\n    return this.nameToMat.get(name);\n  }\n\n\n  public static SaveToJSON(name: string) {\n    //Not in array or null?\n    if (!this.nameToMat.has(name) || !this.nameToMat.get(name)) {\n      Debug.Log(\"Error saving material \" + name + \". This material does not exist!\");\n      return;\n    }\n    var matJson = Serializer.ToJSON(this.nameToMat.get(name));\n    saveMaterial(name, matJson);\n  }\n\n  public static nameToMat: Map<string, Material>;\n\n  public static Init() {\n    this.nameToMat = new Map<string, Material>();\n\n  }\n\n  public static Update() {\n    //We run an update method on all active materials \n    this.activeMaterials.forEach((value: Material) => {\n      value.Update();\n    });\n  }\n  // #endregion\n}\n"
                    },
                    {
                        "Scene": "//script:Scene\nclass Scene {\n  public name: string;\n\n  public objs: GameObject[];\n\n  //Null for scenes, the single root object for prefabs\n  public rootObj : GameObject;\n\n  //The objects that have no parent\n  @SerializeField\n  public rootObjs : GameObject[] = new Array();\n\n  //Any newly created GameObjects or Components\n  public newObjs : SceneObject[]\n\n  public constructor() {\n    this.objs = new Array();\n    this.newObjs = new Array();\n    this.isPrefabScene = SceneManager.prefabLoaded;\n  }\n\n  public isDirty : boolean;\n\n  isPrefabScene : boolean;\n\n  public Save ()\n  {\n    var jsonData = Serializer.ToJSON(this, false);\n    if (this.isPrefabScene)\n    {\n      savePrefab(this.name, jsonData);\n    } else {\n      saveScene(this.name, jsonData);  \n      \n    }     \n     \n    this.isDirty = false;    \n  }\n\n  public Unload(): void {\n    //A prefab auto-saves when we leave to a scene\n    if (this.isPrefabScene && !Engine.isPlaying)\n    {\n      this.Save();\n    }\n    for (var i = this.rootObjs.length - 1; i >= 0; i--) {\n      GameObject.Destroy(this.rootObjs[i]);      \n    }\n  }\n}"
                    }
                ]
            },
            {
                "Objects": [
                    {
                        "Color": "class Color  {\n\n    constructor (r :number = 1, g :number = 1, b : number = 1)\n    {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n\n    @SerializeField\n    public r : number;\n    @SerializeField\n    public g : number;\n    @SerializeField\n    public b : number;\n\n\n    public static UtoB (u: Color, b : BABYLON.Color3) : BABYLON.Color3\n    {\n        b.r = u.r;\n        b.g = u.g;\n        b.b = u.b\n        return b;\n    }\n\n    public static BtoU  (b : BABYLON.Color3, u : Color) : Color\n    {\n        u.r = b.r;\n        u.g = b.g;\n        u.b = b.b;\n        return u;\n    }\n}\n"
                    },
                    {
                        "BabylonExtensions": "//TODO Rework this class.\nclass Vector2 extends BABYLON.Vector2\n{\n    \n}\n\nclass Vector3 \n{\n    public onChange : BABYLON.Observable<number>;\n\n    constructor(x? : number, y? : number, z? : number) \n    {\n        this.onChange = new BABYLON.Observable();\n        this.x = x ? x : 0;\n        this.y = y ? y : 0;\n        this.z = z ? z : 0;\n    }\n\n    _x : number;\n    _y : number;    \n    _z : number;\n\n    @SerializeField\n    get x () : number\n    {\n        return this._x;\n    }\n\n    set x (value : number)\n    {\n        this._x = value\n        this.onChange.notifyObservers(0);\n    }\n\n    @SerializeField\n    get y () : number\n    {\n        return this._y;\n    }\n\n    set y (value : number)\n    {\n        this._y = value;\n        this.onChange.notifyObservers(1);\n    }\n    \n    @SerializeField\n    get z () : number\n    {\n        return this._z;\n    }\n    \n    set z (value : number)\n    {\n        this._z = value;\n        this.onChange.notifyObservers(2);\n    }\n\n    public add(v : Vector3)\n    {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n    }\n\n    public negate(v : Vector3)\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n    }\n\n    static One () : Vector3\n    {\n        return new Vector3(1.0, 1.0, 1.0);\n    }\n\n    static Zero() : Vector3\n    {\n        return new Vector3(0.0, 0.0, 0.0);\n    }\n\n    public static Lerp (a : Vector3, b : Vector3, l : number) : Vector3\n    {\n        var v : Vector3 = a.clone();\n        v.x = v.x + l * (b.x - v.x);\n        v.y = v.y + l * (b.y - v.y);\n        v.z = v.z + l * (b.z - v.z);\n        return v;\n    }\n\n    clone () : Vector3\n    {\n        return new Vector3(this.x, this.y, this.z);\n    }\n\n    public static VtoB (v: Vector3, b : BABYLON.Vector3) : BABYLON.Vector3\n    {\n        b.x = v._x;\n        b.y = v._y;\n        b.z = v._z;\n        return b;\n    }\n\n    public static BtoV  (b : BABYLON.Vector3, v : Vector3) : Vector3\n    {\n        v._x = b.x;\n        v._y = b.y;\n        v._z = b.z;\n        return v;\n    }\n\n    toString ()\n    {\n        return \"Vector3(\"+ this._x + \",\" + this._y + \",\" + this._z + \")\";\n    }\n\n    public get magnitude () : number\n    {\n        return Math.sqrt(this.sqrMagnitude);\n    }\n\n    public get sqrMagnitude () : number\n    {\n        return this.x*this.x + this.y * this.y + this.z*this.z;\n    }\n\n    public get normalized () : Vector3\n    {\n        var m = 1.0 / this.magnitude;\n        return new Vector3(this.x * m, this.y * m, this.z* m);\n    }\n}\n\nclass Quaternion \n{\n    public onChange : BABYLON.Observable<number>;\n\n    constructor(x? : number, y? : number, z? : number, w? : number) \n    {\n        this.onChange = new BABYLON.Observable();\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n\n    _x : number;\n    _y : number;\n    _z : number;\n    _w : number;\n\n    @SerializeField\n    get x () : number\n    {\n        return this._x;\n    }\n\n    set x (value : number)\n    {\n        this._x = value\n        this.onChange.notifyObservers(0);\n    }\n\n    @SerializeField\n    get y () : number\n    {\n        return this._y;\n    }\n\n    set y (value : number)\n    {\n        this._y = value;\n        this.onChange.notifyObservers(1);\n    }\n\n    @SerializeField\n    get z () : number\n    {\n        return this._z;\n    }\n    \n    set z (value : number)\n    {\n        this._z = value;\n        this.onChange.notifyObservers(2);\n    }\n\n    @SerializeField\n    get w () : number\n    {\n        return this._w;\n    }\n    \n    set w (value : number)\n    {\n        this._w = value;\n        this.onChange.notifyObservers(3);\n    }    \n\n    clone () : Quaternion\n    {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n\n    toString ()\n    {\n        return \"Quaternion(\"+ this._x + \",\" + this._y + \",\" + this._z + \",\" + this._w + \")\";\n    }\n\n    public static QtoB (v: Quaternion, b : BABYLON.Quaternion) : BABYLON.Quaternion\n    {\n        b.x = v._x;\n        b.y = v._y;\n        b.z = v._z;\n        b.w = v._w;\n        return b;\n    }\n\n    public static BtoQ  (b : BABYLON.Quaternion, v : Quaternion) : Quaternion\n    {\n        v._x = b.x;\n        v._y = b.y;\n        v._z = b.z;\n        v._w = b.w;\n        return v;\n    }\n\n    public static Inverse (q : Quaternion)\n    {\n        return new Quaternion(-q.x, -q.y, -q.z, -q.w);\n    }\n\n    //TODO Can we do this math without Babylon?\n    public static Euler (x : number, y : number, z : number, q? : Quaternion) : Quaternion\n    {\n        if (!q)\n        {\n            q = new Quaternion(0,0,0,0);\n        }\n\n        var newQuat = BABYLON.Quaternion.FromEulerAngles(x*Mathf.Deg2Rad,y*Mathf.Deg2Rad,z*Mathf.Deg2Rad);\n        return Quaternion.BtoQ(newQuat, q);\n    }\n\n    static ToEulerAngles(q : Quaternion, v : Vector3) : Vector3\n    {\n        var b = new BABYLON.Quaternion();\n        Quaternion.QtoB(q, b);\n\n        var bv : BABYLON.Vector3 = b.toEulerAngles();\n        bv.x *= Mathf.Rad2Deg;\n        bv.y *= Mathf.Rad2Deg;\n        bv.z *= Mathf.Rad2Deg;\n\n        return Vector3.BtoV(bv, v);\n    }\n}\n\n"
                    }
                ]
            },
            {
                "MainGame": "\n/*\nENABLE_EDITOR = true;\n\nenum Special\n{\n  Wizard,\n  Archer\n}\n\n@RegisterAsComponent \n@ExecuteInEditMode\nclass LightSettings extends MonoBehaviour {\n  //Start is called before the first frame update\n  Start() {\n    Lighting.mainLight.intensity = 0;\n  }\n}\n\n@RegisterAsComponent\nclass ClockArm extends MonoBehaviour {\n\n  @SerializeField\n  speed : number = 1;\n\n  //Start is called before the first frame update\n  Start() {\n  \n  }\n  \n  //Update is called once per frame\n  Update() {\n    this.transform.Rotate(0, Time.deltaTime * this.speed, 0, BABYLON.Space.WORLD);\n  }\n\n}\n/*\n@RegisterAsComponent\nclass RotationTest extends MonoBehaviour {\n\n  @SerializeField\n  pla: number = 4;\n\n  newParent = null;\n\n  Start() {\n\n\n  }\n\n  Update() {\n        Cursor.lockState = CursorLockMode.Locked;\n\n\n    Cursor.lockState = CursorLockMode.Locked;\n\n    var mouseXInput = Input.GetAxis(\"Mouse X\");\n    var mouseYInput = Input.GetAxis(\"Mouse Y\");\n    this.transform.Rotate(mouseYInput, mouseXInput, 0);\n\n  }\n}\n\n@RegisterAsComponent\nclass Ground extends MonoBehaviour {\n  Start() {\n    this.GetComponent(BoxCollider).layerMask = 2 | 4 | 8 | 16;\n  }\n}\n\n@RegisterAsComponent\nclass MyBox extends MonoBehaviour {\n\n  @SerializeField\n  triggerTime: number = 0;\n\n  @SerializeField\n  movement: number = 0;\n\n  mat: BABYLON.StandardMaterial;\n\n  @SerializeField\n  meshOffset: Vector3 = new Vector3(0, 0, 0);\n\n  m: BABYLON.Mesh;\n\n\n  //Start is called before the first frame update\n  Start() {\n\n  }\n\n  //Update is called once per frame\n  Update() {\n    // this.transform.eulerAngles.z += 1;\n    //this.transform.position.y += this.speed;\n    //this.transform.position.x += this.movement;\n    if (!this.m) {\n      this.m = this.renderer.GetMesh();\n      // var v : BABYLON.Vector3 = new BABYLON.Vector3();\n      // Vector3.VtoB(this.meshOffset, v);\n      this.m.locallyTranslate(new BABYLON.Vector3(13, 0, 50));\n      this.m.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);\n    }\n\n    if (this.m) {\n\n      // this.m.translate(new BABYLON.Vector3(0,0,1), 10);\n      //);\n    }\n  }\n\n  OnTriggerEnter(coll: Collider) {\n    this.renderer.material.shader.diffuseColor = BABYLON.Color3.Green();\n  }\n\n  OnTriggerExit(coll: Collider) {\n    this.renderer.material.shader.diffuseColor = BABYLON.Color3.Red();\n  }\n\n  OnTriggerStay(coll: Collider) {\n    this.triggerTime += Time.deltaTime;\n  }\n}\n\n/* */\n\n"
            }
        ],
        "model": [
            {
                "asteroid.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.asteroid.obj"
                }
            },
            {
                "ship.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ship.obj"
                }
            },
            {
                "virus.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.virus.obj"
                }
            },
            {
                "crate.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.crate.obj"
                }
            },
            {
                "fence.obj": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.fence.obj"
                }
            },
            {
                "wolf.glb": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.wolf.glb"
                }
            },
            {
                "wolf2.gltf": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.wolf2.gltf"
                }
            },
            {
                "Dancer.glb": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Dancer.glb"
                }
            }
        ],
        "texture": [
            {
                "laser.png": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.laser.png"
                }
            },
            {
                "EngineTextures": [
                    {
                        "play_button.png": {
                            "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.play_button.png"
                        }
                    },
                    {
                        "pause_button.png": {
                            "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.pause_button.png"
                        }
                    }
                ]
            },
            {
                "nebula.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.nebula.jpg"
                }
            },
            {
                "asteroid.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.asteroid.jpg"
                }
            },
            {
                "ship.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.ship.jpg"
                }
            },
            {
                "Grass.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Grass.jpg"
                }
            },
            {
                "Wood.png": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.Wood.png"
                }
            },
            {
                "synty.png": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.synty.png"
                }
            },
            {
                "board.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.board.jpg"
                }
            },
            {
                "board_normal.jpg": {
                    "uri": "https://s3.us-west-1.amazonaws.com/test.pixelpad.io/__PIXELPAD_ASSET__.4892.210651.board_normal.jpg"
                }
            }
        ],
        "sound": [],
        "library": {},
        "scene": [
            {
                "Simple.scn": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"Camera\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":-9.083319664001465},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"7377a109-f4fb-4e05-96bb-8a8805b4d9f0\",\"ser_children\":[]},{\"t\":\"Camera\"}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-5.130582332611084,\"y\":0,\"z\":0.9074119925498962},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"cad1a3b5-ebf2-456f-a264-a1bd10719acd\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"GameObject (NewCanvas)\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0.11728240549564362},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"933caedd-86e0-411e-9703-d637c3bd073d\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Button\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-2.4277751445770264,\"y\":3.7154197692871094,\"z\":0.000001862645149230957},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"1321f91a-48ac-4824-91de-f72af30d1cc4\",\"ser_children\":[]},{\"t\":\"Button\"}],\"prefabName\":null}]},{\"t\":\"NewCanvas\"}],\"prefabName\":null}]}"
            },
            {
                "Test2.scn": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"Camera\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":61.99066162109375,\"z\":-81.83799743652344},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":45.000000000000014,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.5199999999999998,\"y\":1,\"z\":1},\"uniqueId\":\"f088e1dc-458d-4b59-ba87-03fbf7838fbe\",\"ser_children\":[]},{\"t\":\"Camera\"}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":15.089681625366211,\"y\":34.05119705200195,\"z\":-14.132094383239746},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":66.26989120519565,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":1.5700000524520874,\"y\":-1.016029953956604,\"z\":3.6686325073242188},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-1.660000103440595,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":100,\"y\":-1.8999999962735254,\"z\":99.00074523683811},\"uniqueId\":\"7724c0f1-e85d-496d-a6cb-284b631af351\",\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"Red.mat\",\"scale\":1,\"castShadows\":false,\"receiveShadows\":true,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":3.7681894302368164,\"y\":0.8660547733306885,\"z\":33.63466262817383},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-1.660000000000001,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b6df72b3-b6b6-4391-99b5-984fce93bd9a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-1,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5810e78f-d6a6-4238-96de-a043f4b1abed\",\"ser_children\":[]}],\"prefabName\":null}]},{\"t\":\"Renderer\",\"meshName\":\"Dancer.glb\",\"materialName\":\"\",\"scale\":10,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":false},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-20.084897994995117,\"y\":0.8660547733306885,\"z\":33.63466262817383},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-1.660000000000001,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b6df72b3-b6b6-4391-99b5-984fce93bd9a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-1,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5810e78f-d6a6-4238-96de-a043f4b1abed\",\"ser_children\":[]}],\"prefabName\":null}]},{\"t\":\"Renderer\",\"meshName\":\"Dancer.glb\",\"materialName\":\"\",\"scale\":10,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":false},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-6.81019401550293,\"y\":0.8660547733306885,\"z\":33.63466262817383},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-1.660000000000001,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b6df72b3-b6b6-4391-99b5-984fce93bd9a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-1,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5810e78f-d6a6-4238-96de-a043f4b1abed\",\"ser_children\":[]}],\"prefabName\":null}]},{\"t\":\"Renderer\",\"meshName\":\"Dancer.glb\",\"materialName\":\"\",\"scale\":10,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":false},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":12.82483196258545,\"y\":0.8660547733306885,\"z\":33.63466262817383},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-1.660000000000001,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b6df72b3-b6b6-4391-99b5-984fce93bd9a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-1,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5810e78f-d6a6-4238-96de-a043f4b1abed\",\"ser_children\":[]}],\"prefabName\":null}]},{\"t\":\"Renderer\",\"meshName\":\"Dancer.glb\",\"materialName\":\"\",\"scale\":10,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":false},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":25.38028907775879,\"y\":0.8660547733306885,\"z\":33.63466262817383},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":-1.660000000000001,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"b6df72b3-b6b6-4391-99b5-984fce93bd9a\",\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-1,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"5810e78f-d6a6-4238-96de-a043f4b1abed\",\"ser_children\":[]}],\"prefabName\":null}]},{\"t\":\"Renderer\",\"meshName\":\"Dancer.glb\",\"materialName\":\"\",\"scale\":10,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":false},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":41.09465026855469,\"y\":34.05119705200195,\"z\":-14.132094383239746},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":66.26989120519566,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":5.2800000000000065,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":0.2331667941696689,\"g\":1,\"b\":0},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":52.809999999999995,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-12.598499298095703,\"y\":34.05119705200195,\"z\":-14.132094383239746},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":66.26989120519565,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":0,\"b\":0},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-39.526649475097656,\"y\":34.05119705200195,\"z\":-14.132094383239746},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":66.26989120519566,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":0,\"g\":0.003355274091913607,\"b\":1},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":26.898332595825195,\"y\":24.563772201538086,\"z\":-35.7142448425293},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":43.738496661837615,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":0.9850340922932402,\"g\":0.9541908299362832,\"b\":0.17642408799378073},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-0.123642697930336,\"y\":24.563772201538086,\"z\":-35.7142448425293},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":43.738496661837615,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":-23.254697799682617,\"y\":24.563772201538086,\"z\":-35.7142448425293},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":43.738496661837615,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":\"0b840604-e4e5-47a2-86ba-ba2741bef7eb\",\"ser_children\":[]},{\"t\":\"Light\",\"lightType\":1,\"color\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"castShadows\":true,\"intensity\":1.2700000000000005,\"range\":48.530000000000015,\"coneAngle\":37.980000000000004,\"exponent\":25,\"shadowFrustrumSize\":104.18999999999997,\"shadowFrustrumLength\":48.28}],\"prefabName\":null}]}"
            },
            {
                "Test3.scn": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"Light\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":10,\"y\":14,\"z\":-10},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":44.999999999999986,\"y\":-45.00000000000002,\"z\":-4.72288274471469e-14},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":1110,\"ser_children\":[]},{\"t\":\"Light\",\"castShadows\":true,\"intensity\":0.7,\"range\":25,\"frustrumSize\":25}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":1121,\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Box\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":29.19938850402832,\"y\":1.812365660786977,\"z\":47.39201978551633},\"uniqueId\":1113,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":false,\"receiveShadows\":true,\"mergeMeshes\":false},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}}],\"prefabName\":null}]}],\"prefabName\":null},{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":3,\"y\":3,\"z\":3},\"uniqueId\":1124,\"ser_children\":[{\"t\":\"GameObject\",\"name\":\"Sphere\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":2.803342342376709,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"uniqueId\":1122,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"sphere\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"SphereCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"radius\":1},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null}]}],\"prefabName\":null}]}"
            }
        ],
        "material": [
            {
                "Red.mat": "{\"t\":\"Material\",\"isPBR\":false,\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"board.jpg\",\"alpha\":1,\"normalTexture\":\"board_normal.jpg\",\"uScale\":1,\"vScale\":1,\"uOffset\":1,\"vOffset\":1,\"specularColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"specularPower\":3.1600000000000006,\"roughness\":0.30000000000000004,\"alphaMode\":0,\"hasAlpha\":false}"
            },
            {
                "Asteroid.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"asteroid.jpg\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}"
            },
            {
                "Grass.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"Grass.jpg\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":5,\"vScale\":5,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}"
            },
            {
                "Yellow.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":0.792158236747296,\"b\":0},\"mainTexture\":\"\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":0,\"roughness\":0}"
            },
            {
                "Synty.mat": "{\"t\":\"Material\",\"mainColor\":{\"t\":\"Color\",\"r\":1,\"g\":1,\"b\":1},\"mainTexture\":\"synty.png\",\"alpha\":1,\"normalTexture\":\"\",\"uScale\":1,\"vScale\":1,\"specularColor\":{\"t\":\"Color\",\"r\":0,\"g\":0,\"b\":0},\"specularPower\":9.260000000000003,\"roughness\":20.02000000000001}"
            },
            {
                "Flip.mat": "//material: Flip.mat\n\n"
            }
        ],
        "prefab": [
            {
                "Test.prefab": "{\"t\":\"Scene\",\"rootObjs\":[{\"t\":\"GameObject\",\"name\":\"GameObject\",\"components\":[{\"t\":\"Transform\",\"_position\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_eulerAngles\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0},\"_scale\":{\"t\":\"Vector3\",\"x\":0.11797763309128564,\"y\":-2.3257447407301215,\"z\":1},\"uniqueId\":3168,\"ser_children\":[]},{\"t\":\"Renderer\",\"meshName\":\"box\",\"materialName\":\"\",\"scale\":1,\"castShadows\":true,\"receiveShadows\":false,\"mergeMeshes\":true},{\"t\":\"BoxCollider\",\"_isTrigger\":false,\"_layer\":1,\"_layerMask\":1,\"_size\":{\"t\":\"Vector3\",\"x\":1,\"y\":1,\"z\":1},\"_center\":{\"t\":\"Vector3\",\"x\":0,\"y\":0,\"z\":0}},{\"t\":\"Rigidbody\",\"_mass\":10,\"_restitution\":0.5,\"_friction\":0.5,\"_isKinematic\":false}],\"prefabName\":null}]}"
            },
            {
                "Robot.prefab": "{\n   \"t\":\"Scene\",\n   \"rootObjs\":[\n      {\n         \"t\":\"GameObject\",\n         \"name\":\"GameObject\",\n         \"components\":[\n            {\n               \"t\":\"Transform\",\n               \"_position\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_eulerAngles\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":0,\n                  \"y\":0,\n                  \"z\":0\n               },\n               \"_scale\":\n               {\n                  \"t\":\"Vector3\",\n                  \"x\":1,\n                  \"y\":1,\n                  \"z\":1\n               },\n               \"uniqueId\":13009,\n               \"ser_children\":[\n                  {\n                     \"t\":\"GameObject\",\n                     \"name\":\"DASDas\",\n                     \"components\":[\n                        {\n                           \"t\":\"Transform\",\n                           \"_position\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0.7628781795501709,\n                              \"y\":0,\n                              \"z\":0\n                           },\n                           \"_eulerAngles\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":180\n                           },\n                           \"_scale\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0.35345974564552307,\n                              \"y\":-1,\n                              \"z\":1\n                           },\n                           \"uniqueId\":12985,\n                           \"ser_children\":[\n                              \n                           ]\n                        },\n                        {\n                           \"t\":\"Renderer\",\n                           \"meshName\":\"box\",\n                           \"materialName\":\"\",\n                           \"scale\":1,\n                           \"castShadows\":true,\n                           \"receiveShadows\":false,\n                           \"mergeMeshes\":true\n                        },\n                        {\n                           \"t\":\"BoxCollider\",\n                           \"_isTrigger\":false,\n                           \"_layer\":1,\n                           \"_layerMask\":1,\n                           \"_size\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":1,\n                              \"y\":1,\n                              \"z\":1\n                           },\n                           \"_center\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":0\n                           }\n                        },\n                        {\n                           \"t\":\"Rigidbody\",\n                           \"_mass\":10,\n                           \"_restitution\":0.5,\n                           \"_friction\":0.5,\n                           \"_isKinematic\":false\n                        }\n                     ],\n                     \"prefabName\":null\n                  },\n                  {\n                     \"t\":\"GameObject\",\n                     \"name\":\"ffg\",\n                     \"components\":[\n                        {\n                           \"t\":\"Transform\",\n                           \"_position\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":0\n                           },\n                           \"_eulerAngles\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":180\n                           },\n                           \"_scale\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0.35345974564552307,\n                              \"y\":-1,\n                              \"z\":1\n                           },\n                           \"uniqueId\":12993,\n                           \"ser_children\":[\n                              {\n                                 \"t\":\"GameObject\",\n                                 \"name\":\"Sphere\",\n                                 \"components\":[\n                                    {\n                                       \"t\":\"Transform\",\n                                       \"_position\":\n                                       {\n                                          \"t\":\"Vector3\",\n                                          \"x\":-3.5557232877801497e-22,\n                                          \"y\":1.9245442152023315,\n                                          \"z\":0\n                                       },\n                                       \"_eulerAngles\":\n                                       {\n                                          \"t\":\"Vector3\",\n                                          \"x\":0,\n                                          \"y\":0,\n                                          \"z\":0\n                                       },\n                                       \"_scale\":\n                                       {\n                                          \"t\":\"Vector3\",\n                                          \"x\":1,\n                                          \"y\":1,\n                                          \"z\":1\n                                       },\n                                       \"uniqueId\":13297,\n                                       \"ser_children\":[\n                                          \n                                       ]\n                                    },\n                                    {\n                                       \"t\":\"Renderer\",\n                                       \"meshName\":\"sphere\",\n                                       \"materialName\":\"\",\n                                       \"scale\":1,\n                                       \"castShadows\":true,\n                                       \"receiveShadows\":false,\n                                       \"mergeMeshes\":true\n                                    },\n                                    {\n                                       \"t\":\"SphereCollider\",\n                                       \"_isTrigger\":false,\n                                       \"_layer\":1,\n                                       \"_layerMask\":1,\n                                       \"radius\":1\n                                    },\n                                    {\n                                       \"t\":\"Rigidbody\",\n                                       \"_mass\":10,\n                                       \"_restitution\":0.5,\n                                       \"_friction\":0.5,\n                                       \"_isKinematic\":false\n                                    }\n                                 ],\n                                 \"prefabName\":null\n                              }\n                           ]\n                        },\n                        {\n                           \"t\":\"Renderer\",\n                           \"meshName\":\"box\",\n                           \"materialName\":\"\",\n                           \"scale\":1,\n                           \"castShadows\":true,\n                           \"receiveShadows\":false,\n                           \"mergeMeshes\":true\n                        },\n                        {\n                           \"t\":\"BoxCollider\",\n                           \"_isTrigger\":false,\n                           \"_layer\":1,\n                           \"_layerMask\":1,\n                           \"_size\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":1,\n                              \"y\":1,\n                              \"z\":1\n                           },\n                           \"_center\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":0\n                           }\n                        },\n                        {\n                           \"t\":\"Rigidbody\",\n                           \"_mass\":10,\n                           \"_restitution\":0.5,\n                           \"_friction\":0.5,\n                           \"_isKinematic\":false\n                        }\n                     ],\n                     \"prefabName\":null\n                  },\n                  {\n                     \"t\":\"GameObject\",\n                     \"name\":\"dasd\",\n                     \"components\":[\n                        {\n                           \"t\":\"Transform\",\n                           \"_position\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0.3695315718650818,\n                              \"y\":0.9485462307929993,\n                              \"z\":0\n                           },\n                           \"_eulerAngles\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":180\n                           },\n                           \"_scale\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0.35345974564552307,\n                              \"y\":-1,\n                              \"z\":1\n                           },\n                           \"uniqueId\":13001,\n                           \"ser_children\":[\n                              \n                           ]\n                        },\n                        {\n                           \"t\":\"BoxCollider\",\n                           \"_isTrigger\":false,\n                           \"_layer\":1,\n                           \"_layerMask\":1,\n                           \"_size\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":1,\n                              \"y\":1,\n                              \"z\":1\n                           },\n                           \"_center\":\n                           {\n                              \"t\":\"Vector3\",\n                              \"x\":0,\n                              \"y\":0,\n                              \"z\":0\n                           }\n                        },\n                        {\n                           \"t\":\"Rigidbody\",\n                           \"_mass\":10,\n                           \"_restitution\":0.5,\n                           \"_friction\":0.5,\n                           \"_isKinematic\":false\n                        }\n                     ],\n                     \"prefabName\":null\n                  }\n               ]\n            }\n         ],\n         \"prefabName\":null\n      }\n   ]\n}"
            }
        ]
    }
}